/**
* DevExpress Dashboard (_form-adapter.js)
* Version:  21.2.3
* Build date: Oct 25, 2021
* Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var form_1 = require("devextreme/ui/form");
var ko = require("knockout");
var _default_1 = require("../../data/localization/_default");
var _utils_1 = require("../../data/_utils");
var _form_adapter_editors_1 = require("./_form-adapter-editors");
exports.twoWayUpdateInterval = 1;
function extractFormAdapterItem(serializableInfo) {
    if (serializableInfo.formAdapterItem) {
        return serializableInfo.formAdapterItem;
    }
    else {
        return mapEditor(serializableInfo);
    }
}
function mapEditor(serializableInfo) {
    if (!serializableInfo.simpleFormAdapterItem) {
        return null;
    }
    switch (serializableInfo.simpleFormAdapterItem) {
        case 'dateBoxEditor':
            return _form_adapter_editors_1.dateBoxEditor();
        case 'numberBoxEditor':
            return _form_adapter_editors_1.numberBoxEditor();
        case 'checkBoxEditor':
            return _form_adapter_editors_1.checkBoxEditor({ text: _default_1.getLocalizationById(serializableInfo.displayName) });
        case 'textBoxEditor':
            return _form_adapter_editors_1.textBoxEditor();
        case 'guidEditor':
            return _form_adapter_editors_1.guidEditor();
        case 'selectBoxEditor':
            return _form_adapter_editors_1.selectBoxEditor(getEditorValues(serializableInfo));
        case 'onOffButtonGroupEditor':
            return _form_adapter_editors_1.buttonGroupEditor([{ value: true, displayValueId: 'DashboardWebStringId.ButtonOn' }, { value: false, displayValueId: 'DashboardWebStringId.ButtonOff' }]);
        case 'yesNoButtonGroupEditor':
            return _form_adapter_editors_1.buttonGroupEditor([{ value: true, displayValueId: 'DashboardWebStringId.ButtonYes' }, { value: false, displayValueId: 'DashboardWebStringId.ButtonNo' }]);
        case 'buttonGroupEditor':
            return _form_adapter_editors_1.buttonGroupEditor(getEditorValues(serializableInfo));
        case 'discreteContinuousButtonGroupEditor':
            return _form_adapter_editors_1.buttonGroupEditor([{ value: true, displayValueId: 'DashboardWebStringId.ButtonDiscrete' }, { value: false, displayValueId: 'DashboardWebStringId.ButtonContinuous' }]);
        case 'listEditor':
            return _form_adapter_editors_1.listEditor(getEditorValues(serializableInfo));
        default:
            throw new Error('Unsupported simple formAdapterItem type');
    }
}
function getFormAdapterItemOptions(serializationInfo, propertiesWrapper, bindingContext) {
    var dynamicEditor = propertiesWrapper.getDynamicEditor ? propertiesWrapper.getDynamicEditor(serializationInfo.propertyName) : null;
    var formAdapterItemProvider = dynamicEditor || serializationInfo;
    var formAdapterItem = extractFormAdapterItem(formAdapterItemProvider);
    var formAdapterContext = {
        bindingContext: bindingContext,
        widgetContainer: bindingContext.$root.getWidgetContainer()
    };
    return (typeof formAdapterItem === 'function') ? formAdapterItem(formAdapterContext) : formAdapterItem;
}
function getFormItems(target, context) {
    return target
        .getInfo()
        .map(function (serializationInfo) {
        if (serializationInfo.dxFormItem) {
            return serializationInfo.dxFormItem;
        }
        var formAdapterItemOptions = getFormAdapterItemOptions(serializationInfo, target, context);
        if (!formAdapterItemOptions) {
            return null;
        }
        return {
            dataField: serializationInfo.propertyName,
            name: serializationInfo.propertyName,
            label: __assign({ text: _default_1.getLocalizationById(serializationInfo.displayName), visible: !!serializationInfo.displayName }, formAdapterItemOptions.label),
            visible: target.isPropertyVisible ? target.isPropertyVisible(serializationInfo.propertyName) : true,
            validationRules: (serializationInfo.validationRules || []).concat((formAdapterItemOptions.validationRules || [])),
            editorType: formAdapterItemOptions.editorType,
            template: formAdapterItemOptions.template,
            customEditorType: formAdapterItemOptions.customEditorType,
            editorOptions: __assign({ disabled: target.isPropertyDisabled ? target.isPropertyDisabled(serializationInfo.propertyName) : false }, formAdapterItemOptions.editorOptions, serializationInfo.editorOptions),
        };
    }).filter(function (i) { return !!i; });
}
function getItemComparableOptions(propertyName, target, context) {
    var info = target.getInfo().filter(function (info) { return info.propertyName === propertyName; })[0];
    var itemOptions = info && getFormAdapterItemOptions(info, target, context);
    return itemOptions && itemOptions.comparableEditorOptions || [];
}
function updateFormItemsCore(form, target, bindingContext, propertiesToForceUpdate) {
    if (propertiesToForceUpdate === void 0) { propertiesToForceUpdate = []; }
    form.beginUpdate();
    getFormItems(target, bindingContext).forEach(function (newItem) {
        var itemOptions = form.itemOption(newItem.dataField);
        if (itemOptions.visible !== newItem.visible) {
            form.itemOption(newItem.dataField, 'visible', newItem.visible);
        }
        if (itemOptions.editorOptions && newItem.editorOptions) {
            var isOptionsChanged = ['disabled'].concat(getItemComparableOptions(newItem.dataField, target, bindingContext)).reduce(function (acc, prop) { return acc || (newItem.editorOptions[prop] !== itemOptions.editorOptions[prop]); }, false);
            isOptionsChanged && form.itemOption(newItem.dataField, 'editorOptions', newItem.editorOptions);
        }
        if (itemOptions['customEditorType'] !== newItem['customEditorType'] || itemOptions.editorType !== newItem.editorType ||
            _utils_1.type.isDefined(propertiesToForceUpdate) && propertiesToForceUpdate.filter(function (f) { return f === newItem.dataField; }).length > 0) {
            form.itemOption(newItem.dataField, newItem);
        }
    });
    form.endUpdate();
}
exports.updateFormItemsCore = updateFormItemsCore;
function transformValuesDictionary(values) {
    return Object.keys(values).map(function (k) { return ({ value: k, displayValueId: values[k] }); });
}
exports.transformValuesDictionary = transformValuesDictionary;
function getEditorValues(propertyEditorInfo) {
    if (propertyEditorInfo.values) {
        var values = ko.unwrap(propertyEditorInfo.values);
        return transformValuesDictionary(values);
    }
    else if (propertyEditorInfo.valuesArray)
        return propertyEditorInfo.valuesArray.map(function (val) { return ({ value: val.value, displayValueId: val.displayValue }); });
    return undefined;
}
ko.bindingHandlers['dx-dashboard-form-adapter'] = {
    init: function (element, valueAccessor, _, __, bindingContext) {
        var subscriptions = [];
        var params = ko.unwrap(valueAccessor());
        var target = ko.unwrap(params.target);
        var onFormInitialized = ko.unwrap(params.onFormInitialized);
        var updateFormItems = function (form, propertiesToForceUpdate) {
            updateFormItemsCore(form, target, bindingContext, propertiesToForceUpdate);
        };
        var twoWayTimeout;
        var twoWayPropsUpdated = [];
        var clearTwoWayTimeout = function (propsToClear) {
            twoWayPropsUpdated = twoWayPropsUpdated.filter(function (tw) { return propsToClear.filter(function (tc) { return tc === tw; }).length === 0; });
            if (twoWayPropsUpdated.length === 0) {
                clearTimeout(twoWayTimeout);
                twoWayTimeout = null;
            }
        };
        var updateTwoWay = function (prop) {
            clearTimeout(twoWayTimeout);
            twoWayPropsUpdated.push(prop);
            twoWayTimeout = setTimeout(function () {
                var force = twoWayPropsUpdated;
                clearTwoWayTimeout(twoWayPropsUpdated);
                updateFormItems(form, force);
            }, exports.twoWayUpdateInterval);
        };
        var form = new form_1.default(element, {
            formData: target,
            colCount: 1,
            labelLocation: 'top',
            showColonAfterLabel: false,
            items: getFormItems(target, bindingContext),
            onContentReady: function (e) {
                target.onContentReady && target.onContentReady(e);
            },
            onInitialized: function (e) {
                onFormInitialized && onFormInitialized(e);
                target.onInitialized && target.onInitialized(e);
            },
            onFieldDataChanged: function (e) {
                if (twoWayTimeout)
                    clearTwoWayTimeout([e.dataField]);
                updateFormItems(e.component);
                target.onFieldDataChanged && target.onFieldDataChanged(e);
            }
        });
        target.assignValidationPovider(form);
        target.getInfo()
            .filter(function (propInfo) { return propInfo.externalUpdateCallback; })
            .forEach(function (propInfo) { return subscriptions.push(propInfo.externalUpdateCallback(function (_a) {
            var forceValidate = _a.forceValidate;
            updateFormItems(form);
            if (forceValidate)
                form.validate();
        })); });
        target.getInfo()
            .filter(function (propInfo) { return propInfo.isTwoWay; })
            .forEach(function (propInfo) {
            var property = target[propInfo.propertyName];
            if (property && ko.isObservable(property)) {
                subscriptions.push(property.subscribe(function (newValue) {
                    updateTwoWay(propInfo.propertyName);
                }));
            }
        });
        ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
            target.assignValidationPovider(null);
            subscriptions.forEach(function (d) { return d.dispose(); });
            subscriptions = [];
        });
        return { controlsDescendantBindings: true };
    }
};
