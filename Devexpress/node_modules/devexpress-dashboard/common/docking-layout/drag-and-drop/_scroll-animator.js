/**
* DevExpress Dashboard (_scroll-animator.js)
* Version:  21.2.3
* Build date: Oct 25, 2021
* Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var ScrollAnimator = (function () {
    function ScrollAnimator(_scrollViewProvider) {
        this._scrollViewProvider = _scrollViewProvider;
    }
    ScrollAnimator.prototype._requestAnimationFrame = function () {
        var _this = this;
        this._nextAnimationFrame = window.requestAnimationFrame(function () { return _this._animationStep(); });
    };
    ScrollAnimator.prototype._animationStep = function () {
        if (this._cursorPosition && this._scrollViewBoundary && this._scrollViewProvider) {
            processScrollStep(this._cursorPosition.x, this._cursorPosition.y, this._scrollViewProvider, this._scrollViewBoundary);
        }
        this._requestAnimationFrame();
    };
    ScrollAnimator.prototype.start = function () {
        this._scrollViewBoundary = this._scrollViewProvider.getBoundingClientRect();
        this._requestAnimationFrame();
    };
    ScrollAnimator.prototype.updateCursorPosition = function (cursorX, cursorY) {
        if (cursorX > 0 && cursorY > 0) {
            this._cursorPosition = { x: cursorX, y: cursorY };
        }
        else {
            this.resetCursorPosition();
        }
    };
    ScrollAnimator.prototype.resetCursorPosition = function () {
        this._cursorPosition = null;
    };
    ScrollAnimator.prototype.stop = function () {
        window.cancelAnimationFrame(this._nextAnimationFrame);
        this._scrollViewBoundary = null;
        this.resetCursorPosition();
    };
    ScrollAnimator.prototype.dispose = function () {
        this.stop();
        this._scrollViewProvider = undefined;
    };
    ScrollAnimator.scrollSpeed = 30;
    ScrollAnimator.scrollSensitivity = 60;
    return ScrollAnimator;
}());
exports.ScrollAnimator = ScrollAnimator;
var processScrollStep = function (cursorX, cursorY, scrollViewInstance, scrollViewBoundaries) {
    var distanceToTop = cursorY - scrollViewBoundaries.top;
    var distanceToBottom = scrollViewBoundaries.bottom - cursorY;
    var distanceToLeft = cursorX - scrollViewBoundaries.left;
    var distanceToRight = scrollViewBoundaries.right - cursorX;
    if (distanceToTop >= 0 && distanceToBottom >= 0 && distanceToLeft >= 0 && distanceToRight >= 0) {
        var scrollSpeed = __assign({}, calculateScrollSpeed(distanceToTop, 'top', -1), calculateScrollSpeed(distanceToBottom, 'top', 1), calculateScrollSpeed(distanceToLeft, 'left', -1), calculateScrollSpeed(distanceToRight, 'left', 1));
        if (scrollSpeed.left || scrollSpeed.top) {
            var currentOffset = scrollViewInstance.getScrollOffset();
            scrollViewInstance.setScrollOffset({
                top: currentOffset.top + (scrollSpeed.top || 0),
                left: currentOffset.left + (scrollSpeed.left || 0)
            });
        }
    }
};
var calculateScrollSpeed = function (distanceToBorder, mainAxisDirection, scrollAxisDirection) {
    var _a;
    if (distanceToBorder <= ScrollAnimator.scrollSensitivity) {
        var sensitivity = ScrollAnimator.scrollSensitivity;
        var maxSpeed = ScrollAnimator.scrollSpeed;
        return _a = {},
            _a[mainAxisDirection] = scrollAxisDirection * Math.ceil(Math.pow((sensitivity - distanceToBorder) / sensitivity, 2) * maxSpeed),
            _a;
    }
    return null;
};
