/**
* DevExpress Dashboard (_chart-data-controller-base.js)
* Version:  21.2.3
* Build date: Oct 25, 2021
* Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var color_1 = require("devextreme/color");
var _item_data_axis_helper_1 = require("../item-data/internal/_item-data-axis-helper");
var item_data_axis_names_1 = require("../item-data/item-data-axis-names");
var _localization_ids_1 = require("../_localization-ids");
var _localizer_1 = require("../_localizer");
var _utils_1 = require("../_utils");
var _data_controller_base_1 = require("./_data-controller-base");
var chartDataControllerBase = (function (_super) {
    __extends(chartDataControllerBase, _super);
    function chartDataControllerBase(options) {
        return _super.call(this, options) || this;
    }
    chartDataControllerBase._getLegendSeriesName = function (seriesName) {
    };
    chartDataControllerBase._getLegendSeriesDisplayName = function (seriesName) {
    };
    chartDataControllerBase.prototype.getArgument = function (argumentAxisPoint) {
        if (this.isQualitativeArgument()) {
            return this.getTitle(argumentAxisPoint, '\n');
        }
        else if (this.isDiscreteArgument()) {
            if (argumentAxisPoint.getParent() != null) {
                return argumentAxisPoint.getDisplayText() || '';
            }
            else {
                return _localizer_1.localizer.getString(_localization_ids_1.localizationId.ChartTotalValue);
            }
        }
        else {
            return argumentAxisPoint.getValue();
        }
    };
    chartDataControllerBase.prototype.getArgumentAxisPoints = function (argumentId) {
        if (this.viewModel) {
            var id = argumentId ? argumentId : this.viewModel.Argument.SummaryArgumentMember, argumentAxis = this._getArgumentAxis();
            return argumentAxis ? argumentAxis.getPointsByDimension(id) : [];
        }
        else {
            return [];
        }
    };
    chartDataControllerBase.prototype.getSeriesAxisPoints = function (seriesId) {
        var seriesAxis = this._getSeriesAxis(), id = seriesId ? seriesId : this.viewModel.SummarySeriesMember;
        return seriesAxis ? seriesAxis.getPointsByDimension(id) : [];
    };
    chartDataControllerBase.prototype.getSingleArgumentDimensionFormat = function () {
        var argumentDimension = this._getSingleArgumentDimension();
        return argumentDimension ? argumentDimension.getFormat() : undefined;
    };
    chartDataControllerBase.prototype.getColor = function (argumentAxisPoint, seriesAxisPoint, measuesIds, colorMeasureId) {
        var that = this, color;
        if (that.viewModel.IsDefaultColorizationDisabled)
            color = that.styleSettingsProvider.getDefaultBackColor();
        else
            color = that._getColorFromData(argumentAxisPoint, seriesAxisPoint, colorMeasureId);
        var cfColor = that.getConditionalFormattingPointColor(argumentAxisPoint, seriesAxisPoint, measuesIds[0]);
        if (cfColor)
            color = cfColor;
        return that._getElementCustomColor(argumentAxisPoint, seriesAxisPoint, measuesIds, color);
    };
    chartDataControllerBase.prototype.getConditionalFormattingColorCore = function (argumentAxisPoint, seriesAxisPoint, seriesMeasureId, seriesElement) {
        var color = null;
        if (this.cfModel) {
            var styleSettingsInfo = this._getStyleSettingsInfo(argumentAxisPoint, seriesAxisPoint, seriesMeasureId, seriesElement);
            if (styleSettingsInfo && styleSettingsInfo.styleIndexes.length > 0)
                color = this.styleSettingsProvider.getBackColor(styleSettingsInfo);
        }
        return color;
    };
    chartDataControllerBase.prototype.getConditionalFormattingSeriesColor = function (seriesAxisPoint, seriesMeasureId) {
        return this.getConditionalFormattingColorCore(null, seriesAxisPoint, seriesMeasureId, 'LineOrArea');
    };
    chartDataControllerBase.prototype.getConditionalFormattingPointColor = function (argumentAxisPoint, seriesAxisPoint, seriesMeasureId) {
        return this.getConditionalFormattingColorCore(argumentAxisPoint, seriesAxisPoint, seriesMeasureId, 'Point');
    };
    chartDataControllerBase.prototype.isDiscreteArgument = function () {
        return this.viewModel && (this.viewModel.Argument.Type === 'String');
    };
    chartDataControllerBase.prototype.isQualitativeArgument = function () {
        return this._getArgumentAxisDimensions().length > 1 && !this.drillDownState[item_data_axis_names_1.itemDataAxisNames.chartArgumentAxis];
    };
    chartDataControllerBase.prototype.isSingleArgument = function () {
        return this._getArgumentAxisDimensions().length == 1 || this.drillDownState[item_data_axis_names_1.itemDataAxisNames.chartArgumentAxis] != null;
    };
    chartDataControllerBase.prototype.hasSeriesPoints = function () {
        return this.viewModel && !!this.viewModel.SummarySeriesMember;
    };
    chartDataControllerBase.prototype._getElementCustomColor = function (argumentAxisPoint, seriesAxisPoint, measuesIds, color) {
        var that = this, dxColor = new color_1.default(color), newColor;
        if (that.elementCustomColor && color) {
            var customElementColorEventArgs = {
                targetElement: [argumentAxisPoint, seriesAxisPoint],
                measureIds: measuesIds,
                color: dxColor.toHex()
            };
            that.elementCustomColor(customElementColorEventArgs);
            newColor = new color_1.default(customElementColorEventArgs.color);
            if (!newColor.colorIsInvalid && customElementColorEventArgs.color !== dxColor.toHex()) {
                return customElementColorEventArgs.color;
            }
        }
        return color;
    };
    chartDataControllerBase.prototype._getColorFromData = function (argumentAxisPoint, seriesAxisPoint, colorMeasureId) {
        var that = this, colorArgumentAxisPoint = argumentAxisPoint ? argumentAxisPoint.getParentByDimensionId(that.viewModel.ArgumentColorDimension) : undefined, colorSeriesAxisPoint = seriesAxisPoint.getParentByDimensionId(that.viewModel.SeriesColorDimension);
        if (_utils_1.type.isDefined(colorMeasureId)) {
            try {
                var colorValue = that._getCrossSlice(colorArgumentAxisPoint, colorSeriesAxisPoint).getColorMeasureValue(colorMeasureId);
                return colorValue !== null ? _utils_1.toColor(colorValue) : undefined;
            }
            catch (e) {
                return undefined;
            }
        }
        return undefined;
    };
    chartDataControllerBase.prototype._getStyleSettingsInfo = function (argumentAxisPoint, seriesAxisPoint, seriesMeasureId, chartElement) {
        if (this.cfModel) {
            var rules = [], seriesInfo = {
                argumentAxisPoint: argumentAxisPoint,
                seriesAxisPoint: seriesAxisPoint,
                chartElement: chartElement
            };
            rules = this.cfModel.RuleModels.filter(function (rule) { return rule.ApplyToSeriesId === seriesMeasureId && rule.ApplyToChartElement === chartElement; });
            return this._getStyleSettingsInfoCore(seriesInfo, rules, this.viewModel.ColumnAxisName, item_data_axis_names_1.itemDataAxisNames.defaultAxis);
        }
    };
    chartDataControllerBase.prototype._getStyleIndexes = function (rule, seriesInfo, points) {
        var isExpressionRule = rule.CalcByDataId ? false : true;
        var isDimensionRule = this.multiData.getDimensions(item_data_axis_names_1.itemDataAxisNames.chartSeriesAxis).concat(this.multiData.getDimensions(item_data_axis_names_1.itemDataAxisNames.chartArgumentAxis)).filter(function (dimension) { return dimension.id === rule.CalcByDataId; }).length > 0;
        if (seriesInfo.chartElement === 'Point') {
            if (isExpressionRule) {
                var seriesPointPath = seriesInfo.seriesAxisPoint.getAxisPath();
                var argumentPointPath = seriesInfo.argumentAxisPoint.getAxisPath();
                if (seriesPointPath.length > 0 && argumentPointPath.length > 0)
                    return this.findStylesOnPointPathsIntersection(seriesPointPath, argumentPointPath, rule.FormatConditionMeasureId);
                else if (seriesPointPath.length > 0)
                    return this.findStylesOnPointPath(seriesPointPath, null, rule.FormatConditionMeasureId);
                else
                    return this.findStylesOnPointPath(argumentPointPath, null, rule.FormatConditionMeasureId);
            }
            else if (isDimensionRule)
                return this.findStylesForDimension(seriesInfo.seriesAxisPoint, seriesInfo.argumentAxisPoint, rule.CalcByDataId, rule.FormatConditionMeasureId);
            return this.findStylesOnPointIntersection([seriesInfo.seriesAxisPoint, seriesInfo.argumentAxisPoint], rule.FormatConditionMeasureId);
        }
        else if (seriesInfo.chartElement === 'LineOrArea')
            return this.getStyleIndexesOnArgumentAxis(seriesInfo.seriesAxisPoint, rule.FormatConditionMeasureId, isExpressionRule, isDimensionRule, rule.CalcByDataId);
        return null;
    };
    chartDataControllerBase.prototype.findStylesForDimension = function (seriesPoint, argumentPoint, idDimensionCalculateBy, formatRuleMeasureId) {
        var isSeriesDimension = this.multiData.getDimensions(item_data_axis_names_1.itemDataAxisNames.chartSeriesAxis).filter(function (dimension) { return dimension.id === idDimensionCalculateBy; }).length > 0, slicePoint = (isSeriesDimension ? seriesPoint : argumentPoint).getParentByDimensionId(idDimensionCalculateBy);
        return this.findStylesOnPointIntersection([slicePoint], formatRuleMeasureId);
    };
    chartDataControllerBase.prototype.findStylesOnPointIntersection = function (points, ruleMeasureId) {
        return this._getMeasureValueByAxisPoints(points.filter(function (point) { return point; }), ruleMeasureId);
    };
    chartDataControllerBase.prototype.findStylesOnPointPath = function (pointPath, intercestionPoint, ruleMeasureId) {
        var styles;
        for (var _i = 0, pointPath_1 = pointPath; _i < pointPath_1.length; _i++) {
            var point = pointPath_1[_i];
            styles = this.findStylesOnPointIntersection([point, intercestionPoint], ruleMeasureId);
            if (styles)
                break;
        }
        return styles;
    };
    chartDataControllerBase.prototype.findStylesOnPointPathsIntersection = function (firstPointPath, secondPointPath, ruleMeasureId) {
        var styles;
        for (var _i = 0, firstPointPath_1 = firstPointPath; _i < firstPointPath_1.length; _i++) {
            var point = firstPointPath_1[_i];
            styles = this.findStylesOnPointPath(secondPointPath, point, ruleMeasureId);
            if (styles)
                break;
        }
        return styles;
    };
    chartDataControllerBase.prototype.getStyleIndexesOnArgumentAxis = function (seriesAxisPoint, cfMeasureId, isExpressionRule, isDimensionRule, idDimensionCalculateBy) {
        var _this = this;
        var helper = _item_data_axis_helper_1.itemDataAxisHelper, styles = [], rootArgumentPoint = this.multiData.getAxis(item_data_axis_names_1.itemDataAxisNames.chartArgumentAxis).getRootPoint();
        var targetSeriesPoint = seriesAxisPoint ? seriesAxisPoint : this.multiData.getAxis(item_data_axis_names_1.itemDataAxisNames.chartArgumentAxis).getRootPoint();
        helper.eachPoint(rootArgumentPoint, function (point) {
            var currentStyles;
            if (isExpressionRule)
                currentStyles = _this.findStylesOnPointPath(targetSeriesPoint.getAxisPath(), point, cfMeasureId);
            else if (isDimensionRule)
                currentStyles = _this.findStylesForDimension(targetSeriesPoint, point, idDimensionCalculateBy, cfMeasureId);
            else
                currentStyles = _this.findStylesOnPointIntersection([point, targetSeriesPoint], cfMeasureId);
            if (currentStyles && currentStyles.length > 0) {
                styles = styles.concat(currentStyles);
                return false;
            }
        });
        return styles;
    };
    chartDataControllerBase.prototype._getCrossSlice = function (argumentAxisPoint, seriesAxisPoint) {
        var slice = this.multiData.getSlice(seriesAxisPoint);
        return argumentAxisPoint ? slice.getSlice(argumentAxisPoint) : slice;
    };
    chartDataControllerBase.prototype._getArgumentAxis = function () {
        return this.multiData ? this.multiData.getAxis(item_data_axis_names_1.itemDataAxisNames.chartArgumentAxis) : undefined;
    };
    chartDataControllerBase.prototype._getSeriesAxis = function () {
        return this.multiData ? this.multiData.getAxis(item_data_axis_names_1.itemDataAxisNames.chartSeriesAxis) : undefined;
    };
    chartDataControllerBase.prototype._getArgumentAxisDimensions = function () {
        var argumentAxis = this._getArgumentAxis(), dimensions = argumentAxis ? argumentAxis.getDimensions() : [];
        return dimensions ? dimensions : [];
    };
    chartDataControllerBase.prototype._getSingleArgumentDimension = function () {
        var argumentDimensions = this._getArgumentAxisDimensions();
        if (argumentDimensions.length > 0) {
            return argumentDimensions[argumentDimensions.length - 1];
        }
        else {
            return undefined;
        }
    };
    return chartDataControllerBase;
}(_data_controller_base_1.dataControllerBase));
exports.chartDataControllerBase = chartDataControllerBase;
