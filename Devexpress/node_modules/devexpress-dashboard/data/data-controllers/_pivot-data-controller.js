/**
* DevExpress Dashboard (_pivot-data-controller.js)
* Version:  21.2.3
* Build date: Oct 25, 2021
* Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _pivot_grid_item_helper_1 = require("../../viewer-parts/viewer-items/pivot-grid-item/_pivot-grid-item-helper");
var item_data_axis_names_1 = require("../item-data/item-data-axis-names");
var _utils_1 = require("../_utils");
var _data_controller_base_1 = require("./_data-controller-base");
var GT_UNIQUE_PATH = 'GT';
var pivotDataController = (function (_super) {
    __extends(pivotDataController, _super);
    function pivotDataController(options) {
        var _this = _super.call(this, options) || this;
        _this._measureIds = _this._getMeasureIds();
        _this._collapseStateCache = {};
        _this._conditionalFormattingInfoCache = [];
        return _this;
    }
    pivotDataController.prototype.getStyleSettingsInfo = function (cellItem, collapseStateCache, conditionalFormattingInfoCache, pointsCache) {
        if (this.cfModel && this.cfModel.RuleModels.length !== 0) {
            var cellInfo = this._getCellInfo(cellItem, pointsCache), rules = this._getFormatRules(cellItem, cellInfo);
            this._collapseStateCache = collapseStateCache;
            this._conditionalFormattingInfoCache = conditionalFormattingInfoCache;
            return this._getStyleSettingsInfoCore(cellInfo, rules, item_data_axis_names_1.itemDataAxisNames.pivotColumnAxis, item_data_axis_names_1.itemDataAxisNames.pivotRowAxis);
        }
    };
    pivotDataController.prototype._getMeasureIds = function () {
        var measureIds = [];
        for (var i = 0; i < this.viewModel.Values.length; i++)
            measureIds.push(this.viewModel.Values[i].DataId);
        return measureIds;
    };
    pivotDataController.prototype._getColumnAxis = function () {
        return _pivot_grid_item_helper_1.pivotHelper.getColumnAxis(this.multiData);
    };
    pivotDataController.prototype._getRowAxis = function () {
        return _pivot_grid_item_helper_1.pivotHelper.getRowAxis(this.multiData);
    };
    pivotDataController.prototype._getCellInfo = function (cellItem, pointsCache) {
        var columnAxisPoint;
        var rowAxisPoint;
        if (cellItem.area === _utils_1.pivotArea.column || cellItem.area === _utils_1.pivotArea.data)
            columnAxisPoint = this._getAxisPointByPath(pointsCache.columns, cellItem.columnPath, cellItem.columnType);
        if (cellItem.area === _utils_1.pivotArea.row || cellItem.area === _utils_1.pivotArea.data)
            rowAxisPoint = this._getAxisPointByPath(pointsCache.rows, cellItem.rowPath, cellItem.rowType);
        return {
            columnAxisPoint: columnAxisPoint,
            rowAxisPoint: rowAxisPoint
        };
    };
    pivotDataController.prototype._getStyleIndexes = function (rule, cellInfo, points) {
        var that = this, currentStyleIndexes, styleIndexes = [];
        if (rule.ApplyToRow) {
            currentStyleIndexes = that._findStyleSettingsOnAxis(cellInfo.rowAxisPoint, cellInfo.columnAxisPoint, rule.FormatConditionMeasureId, true);
            if (currentStyleIndexes.length > 0)
                styleIndexes = styleIndexes.concat(currentStyleIndexes);
        }
        if (rule.ApplyToColumn) {
            currentStyleIndexes = that._findStyleSettingsOnAxis(cellInfo.rowAxisPoint, cellInfo.columnAxisPoint, rule.FormatConditionMeasureId, false);
            if (currentStyleIndexes.length > 0)
                styleIndexes = styleIndexes.concat(currentStyleIndexes);
        }
        if (!rule.ApplyToRow && !rule.ApplyToColumn) {
            if (cellInfo.columnAxisPoint)
                points.push(cellInfo.columnAxisPoint);
            if (cellInfo.rowAxisPoint)
                points.push(cellInfo.rowAxisPoint);
            currentStyleIndexes = that._getMeasureValueByAxisPoints(points, rule.FormatConditionMeasureId);
            if (currentStyleIndexes)
                styleIndexes = styleIndexes.concat(currentStyleIndexes);
        }
        return styleIndexes;
    };
    pivotDataController.prototype._findStyleSettingsOnAxis = function (rowAxisPoint, columnAxisPoint, measureId, isRowAxis) {
        var that = this, styleIndexes = [], rowPoint = rowAxisPoint ? rowAxisPoint : this._getRowAxis().getRootPoint(), columnPoint = columnAxisPoint ? columnAxisPoint : this._getColumnAxis().getRootPoint(), slicePoint = isRowAxis ? rowPoint : columnPoint, intersectingRootPoint, slice, intersectingPoints = [], cfAxisPoint, conditionalFormattingInfo = {
            slicePoint: slicePoint,
            measureId: measureId,
            styleIndexes: [],
            toString: function () {
                return this.slicePoint.getUniquePath() + this.measureId;
            }
        }, iteratePoints = function (intersectingPoints, point) {
            var children = point.getChildren(), child, collapseStateKey = point.getUniquePath().concat(isRowAxis ? 'column' : 'row'), wasCollapsed = that._collapseStateCache[collapseStateKey];
            if (wasCollapsed === undefined) {
                intersectingPoints.push(point);
                if (children && children.length > 0) {
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        iteratePoints(intersectingPoints, child);
                    }
                }
            }
        };
        cfAxisPoint = this._conditionalFormattingInfoCache[conditionalFormattingInfo];
        if (cfAxisPoint)
            return cfAxisPoint.styleIndexes;
        slice = this.multiData.getSlice(slicePoint);
        intersectingRootPoint = isRowAxis ? this._getColumnAxis().getRootPoint() : this._getRowAxis().getRootPoint();
        iteratePoints(intersectingPoints, intersectingRootPoint);
        intersectingPoints.forEach(function (intersectingPoint) {
            var finalSlice = slice.getSlice(intersectingPoint), currentStyleIndexes = finalSlice.getConditionalFormattingMeasureValue(measureId);
            if (currentStyleIndexes)
                styleIndexes = styleIndexes.concat(currentStyleIndexes);
        });
        conditionalFormattingInfo.styleIndexes = styleIndexes;
        this._conditionalFormattingInfoCache[conditionalFormattingInfo] = conditionalFormattingInfo;
        return styleIndexes;
    };
    pivotDataController.prototype._getFormatRules = function (cellItem, cellInfo) {
        var that = this, dataId, rules = [];
        switch (cellItem.area) {
            case _utils_1.pivotArea.column:
                dataId = that._getPointId(cellInfo.columnAxisPoint);
                rules = rules.concat(that._getFormatRulesByDataId(dataId));
                break;
            case _utils_1.pivotArea.row:
                dataId = that._getPointId(cellInfo.rowAxisPoint);
                rules = rules.concat(that._getFormatRulesByDataId(dataId));
                break;
            default: {
                dataId = that._measureIds[cellItem.cellIndex];
                rules = that.cfModel.RuleModels.filter(function (rule) {
                    return rule.ApplyToRow || (that._isRowValuePosition() && rule.ApplyToColumn) || rule.ApplyToDataId === dataId;
                });
                break;
            }
        }
        return rules;
    };
    pivotDataController.prototype._isRowValuePosition = function () {
        return this.viewModel.ValuesPosition === 'Rows';
    };
    pivotDataController.prototype._getAxisPointByPath = function (pointsCache, path, type) {
        var correctedPath = path, axisPoint;
        if (type === GT_UNIQUE_PATH)
            correctedPath = GT_UNIQUE_PATH;
        axisPoint = pointsCache[correctedPath];
        if (!axisPoint)
            axisPoint = this._getColumnAxis().getPointByUniqueValues(path);
        return axisPoint;
    };
    pivotDataController.prototype._getFormatRulesByDataId = function (dataId) {
        var that = this, formatRules = [];
        if (that.cfModel) {
            that.cfModel.RuleModels.forEach(function (rule) {
                if (rule.ApplyToDataId === dataId) {
                    formatRules.push(rule);
                }
            });
        }
        return formatRules;
    };
    pivotDataController.prototype._getPointId = function (point) {
        var dimension, columnPointId;
        if (point) {
            dimension = point.getDimension();
            columnPointId = dimension ? dimension.id : undefined;
        }
        return columnPointId;
    };
    return pivotDataController;
}(_data_controller_base_1.dataControllerBase));
exports.pivotDataController = pivotDataController;
