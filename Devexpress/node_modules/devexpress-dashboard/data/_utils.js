/**
* DevExpress Dashboard (_utils.js)
* Version:  21.2.3
* Build date: Oct 25, 2021
* Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = require("devextreme/core/utils/data");
var $ = require("jquery");
var special_values_1 = require("./special-values");
exports.type = {
    isDefined: function (object) {
        return null !== object && void 0 !== object;
    },
    isFunction: function (object) {
        return 'function' === typeof object;
    },
    isString: function (object) {
        return 'string' === typeof object;
    },
    isNumeric: function (object) {
        return 'number' === typeof object && isFinite(object) || !isNaN(object - parseFloat(object));
    },
    isBoolean: function (object) {
        return 'boolean' === typeof object;
    }
};
exports.KpiValueMode = {
    Measure: 'Measure',
    Delta: 'Delta'
}, exports.pivotArea = {
    column: 'column',
    row: 'row',
    data: 'data'
}, exports.gaugeViewType = {
    CircularFull: 'CircularFull',
    CircularHalf: 'CircularHalf',
    CircularQuarterRight: 'CircularQuarterRight',
    CircularQuarterLeft: 'CircularQuarterLeft',
    CircularThreeFourth: 'CircularThreeFourth',
    LinearHorizontal: 'LinearHorizontal',
    LinearVertical: 'LinearVertical'
}, exports.tooltipContainerSelector = '.dx-dashboard-container';
function toColor(numericColorValue) {
    var number = numericColorValue >>> 0;
    var b = number & 0xFF, g = (number & 0xFF00) >>> 8, r = (number & 0xFF0000) >>> 16, a = ((number & 0xFF000000) >>> 24) / 255;
    return this.getRGBColor(r, g, b, a);
}
exports.toColor = toColor;
function getRGBColor(r, g, b, a) {
    if (typeof a === 'number' && a >= 0 && a < 1)
        return 'rgba(' + [r, g, b, a].join(',') + ')';
    return 'rgb(' + [r, g, b].join(',') + ')';
}
exports.getRGBColor = getRGBColor;
function allowSelectValue(values) {
    var result = true;
    if (values) {
        $.each(values, function (_, value) {
            result = result && (value !== special_values_1.specialValues.othersValueGuid) &&
                (value !== special_values_1.specialValues.errorValueGuid);
        });
    }
    return result;
}
exports.allowSelectValue = allowSelectValue;
function isVulnerable(value) {
    if (!value)
        return false;
    var re = new RegExp('^\s*(data|javascript)\s*:\s*');
    return !!value.match(re);
}
exports.isVulnerable = isVulnerable;
function encodeHtml(str) {
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}
exports.encodeHtml = encodeHtml;
function decodeHtml(value) {
    return String(value)
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&');
}
exports.decodeHtml = decodeHtml;
function moveContent(source, dest, clearSource) {
    $(source).contents().appendTo($(dest));
    if (clearSource) {
        source.innerHTML = '';
    }
}
exports.moveContent = moveContent;
function arrayContains(container, part) {
    var currentValueIndex = -1;
    if (!!container) {
        $.each(container, function (index, item) {
            if (arrayEquals(part, item)) {
                currentValueIndex = index;
                return false;
            }
        });
    }
    return currentValueIndex >= 0;
}
exports.arrayContains = arrayContains;
function arrayEquals(array1, array2) {
    if (!array1 && !array2)
        return true;
    if (!array1 || !array2)
        return false;
    if (Array.isArray(array1)) {
        if (array1.length !== array2.length)
            return false;
        for (var key in array1) {
            if (!arrayEquals(array1[key], array2[key]))
                return false;
        }
    }
    else {
        return data_1.toComparable(array1, true) === data_1.toComparable(array2, true);
    }
    return true;
}
exports.arrayEquals = arrayEquals;
function checkValuesAreEqual(value1, value2, nullValuesEquals, emptyArraysEquals) {
    if (nullValuesEquals === void 0) { nullValuesEquals = false; }
    if (emptyArraysEquals === void 0) { emptyArraysEquals = false; }
    if (!nullValuesEquals && (value1 == null || value2 == null)) {
        return false;
    }
    var list1 = Array.isArray(value1) ? value1 : [value1], list2 = Array.isArray(value2) ? value2 : [value2];
    if (list1.length !== list2.length || (list1.length === 0 && !emptyArraysEquals)) {
        return false;
    }
    else {
        for (var i = 0; i < list1.length; i++) {
            if (data_1.toComparable(list1[i], true) !== data_1.toComparable(list2[i], true))
                return false;
        }
        return true;
    }
}
exports.checkValuesAreEqual = checkValuesAreEqual;
function checkTuplesAreEqual(tuple1, tuple2) {
    if (!tuple1 || !tuple2) {
        return false;
    }
    var containsCount = 0;
    $.each(tuple1, function (_, tuple1AxisValue) {
        var value = $.grep(tuple2, function (tuple2AxisValue) {
            return tuple2AxisValue.AxisName == tuple1AxisValue.AxisName;
        })[0].Value;
        if (checkValuesAreEqual(tuple1AxisValue.Value, value)) {
            containsCount = containsCount + 1;
        }
    });
    return containsCount == tuple1.length;
}
exports.checkTuplesAreEqual = checkTuplesAreEqual;
function checkArrayContainsTuple(array, tuple) {
    var that = this, contains, currentIndex;
    $.each(array, function (index, aTuple) {
        contains = that.checkTuplesAreEqual(aTuple, tuple);
        if (contains)
            currentIndex = index;
        return !contains;
    });
    return currentIndex;
}
exports.checkArrayContainsTuple = checkArrayContainsTuple;
function getAxisPointValue(tuple, axisName) {
    var axisPoints = $.grep(tuple, function (axisValue) {
        return axisValue.AxisName == axisName;
    });
    return axisPoints.length > 0 ? axisPoints[0].Value : null;
}
exports.getAxisPointValue = getAxisPointValue;
function getTagValue(tag) {
    var axisPoint = tag.axisPoint;
    return axisPoint ? axisPoint.getUniquePath() : tag;
}
exports.getTagValue = getTagValue;
function getValueIndex(matrix, vector) {
    if (matrix && vector) {
        for (var i = 0; i < matrix.length; i++) {
            if (this.checkValuesAreEqual(matrix[i], vector)) {
                return i;
            }
        }
    }
    return -1;
}
exports.getValueIndex = getValueIndex;
function treeWalker(rootNode, childrenFunc) {
    return {
        walk: function (func) {
            this._walkInternal(rootNode, null, func, function () { return true; });
        },
        walkLeaf: function (func) {
            this._walkInternal(rootNode, null, func, function (node, parent, isLeaf) { return isLeaf; });
        },
        _walkInternal: function (node, parent, func, callPredicate) {
            var that = this, children = childrenFunc(node), isLeaf = !children || children.length === 0;
            if (callPredicate(node, parent, isLeaf)) {
                func(node, parent, isLeaf);
            }
            if (!isLeaf) {
                $.each(children, function (i, branch) {
                    that._walkInternal(branch, node, func, callPredicate);
                });
            }
        }
    };
}
exports.treeWalker = treeWalker;
function getParentClasses($obj) {
    var parents = [$obj.attr('class')];
    $.each($obj.parents(), function (_, parent) {
        var name = $(parent).attr('class');
        if (name)
            parents.push(name);
    });
    return parents.reverse();
}
exports.getParentClasses = getParentClasses;
function wrapHash(valuesArray) {
    var hash = {};
    if (valuesArray) {
        $.each(valuesArray, function (_, value) {
            hash[value] = true;
        });
    }
    return hash;
}
exports.wrapHash = wrapHash;
function areNotOrderedListsEqual(list1, list2) {
    if (list1.length != list2.length)
        return false;
    list1 = list1.slice();
    list2 = list2.slice();
    list1.sort();
    list2.sort();
    for (var i = 0; i < list1.length; i++) {
        if (list1[i] !== list2[i])
            return false;
    }
    return true;
}
exports.areNotOrderedListsEqual = areNotOrderedListsEqual;
function pxToNumber(px) {
    var result = 0;
    if (px != null && px != '') {
        try {
            var indexOfPx = px.indexOf('px');
            if (indexOfPx > -1)
                result = parseInt(px.substr(0, indexOfPx));
        }
        catch (e) { }
    }
    return result;
}
exports.pxToNumber = pxToNumber;
function debounce(func, wait) {
    var timeout;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var that = this;
        clearTimeout(timeout);
        timeout = setTimeout(function () {
            clearTimeout(timeout);
            timeout = null;
            func.apply(that, args);
        }, wait);
    };
}
exports.debounce = debounce;
function asyncDebounce(func, action) {
    var _this = this;
    var actualPromise;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var that = _this;
        var promise = func.call.apply(func, [that].concat(args));
        actualPromise = promise;
        promise.done(function () {
            var actionArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                actionArgs[_i] = arguments[_i];
            }
            if (promise === actualPromise) {
                action.apply(that, actionArgs);
            }
        });
    };
}
exports.asyncDebounce = asyncDebounce;
function containsInIndex(array, value, index, compare) {
    return index >= 0 && findIndex(array, function (cur) { return compare(value, cur); }) === index;
}
function distinct(array, compare) {
    if (compare)
        return array.filter(function (value, index, arr) { return containsInIndex(arr, value, index, compare); });
    else
        return array.filter(function (value, index, arr) { return arr.indexOf(value) === index; });
}
exports.distinct = distinct;
function intersect(array1, array2, compare) {
    if (compare)
        return array1.filter(function (value) { return findIndex(array2, function (cur) { return compare(value, cur); }) !== -1; });
    else
        return array1.filter(function (value) { return array2.indexOf(value) !== -1; });
}
exports.intersect = intersect;
function union(array1, array2, compare) {
    return distinct(array1.concat(array2));
}
exports.union = union;
function minus(array1, array2, compare) {
    if (compare)
        return array1.filter(function (value) { return findIndex(array2, function (cur) { return compare(value, cur); }) === -1; });
    else
        return array1.filter(function (value) { return array2.indexOf(value) === -1; });
}
exports.minus = minus;
function groupByProperty(array, property) {
    return groupBy(array, function (item) { return item[property]; });
}
exports.groupByProperty = groupByProperty;
function groupBy(array, getKey) {
    return array.reduce(function (result, item) {
        var key = getKey(item);
        var group = result.filter(function (gr) { return gr && gr.length > 0 && getKey(gr[0]) === key; })[0];
        if (!group) {
            result.push([item]);
        }
        else {
            group.push(item);
        }
        return result;
    }, []);
}
exports.groupBy = groupBy;
function mapMany(array, callbackfn) {
    return array.map(callbackfn).reduce(function (a, b) { return a.concat(b); }, []);
}
exports.mapMany = mapMany;
function deepStrictEquals(x, y) {
    return strictEquals(x, y, function (obj1, obj2) {
        if (Array.isArray(obj1) || Array.isArray(obj2))
            throw new Error('Arrays comparison is not supported.');
        switch (typeof (obj1)) {
            case 'object':
                for (var p1 in obj1) {
                    if (obj1.hasOwnProperty(p1) !== obj2.hasOwnProperty(p1))
                        return false;
                    if (!deepStrictEquals(obj1[p1], obj2[p1]))
                        return false;
                }
                for (var p2 in obj2)
                    if (!obj1.hasOwnProperty(p2))
                        return false;
                break;
            case 'number':
            case 'boolean':
            case 'string':
            case 'bigint':
            case 'symbol':
                if (obj1 !== obj2)
                    return false;
                break;
            default:
                throw new Error('The object type ' + typeof (obj1) + ' is not supported in comparison.');
        }
        return true;
    });
}
exports.deepStrictEquals = deepStrictEquals;
function strictEquals(x, y, equalsCore) {
    if (x === y)
        return true;
    if (!exports.type.isDefined(x) || !exports.type.isDefined(y))
        return false;
    if (typeof (x) !== typeof (y))
        return false;
    return equalsCore(x, y);
}
exports.strictEquals = strictEquals;
var LocalStorageHelper = (function () {
    function LocalStorageHelper() {
    }
    LocalStorageHelper._getLocalStorage = function () {
        try {
            if (window.localStorage)
                return window.localStorage;
        }
        catch (_) { }
        return undefined;
    };
    LocalStorageHelper.getItem = function (key, defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        var localStorage = LocalStorageHelper._getLocalStorage();
        if (localStorage) {
            return localStorage.getItem(key);
        }
        return defaultValue;
    };
    LocalStorageHelper.setItem = function (key, value) {
        var localStorage = LocalStorageHelper._getLocalStorage();
        if (localStorage) {
            return localStorage.setItem(key, value);
        }
    };
    return LocalStorageHelper;
}());
exports.LocalStorageHelper = LocalStorageHelper;
function findIndex(array, predicate) {
    for (var i = 0; i < array.length; i++) {
        if (predicate(array[i]))
            return i;
    }
    return -1;
}
exports.findIndex = findIndex;
function findLastIndex(array, predicate) {
    for (var i = array.length - 1; i >= 0; --i) {
        if (predicate(array[i]))
            return i;
    }
    return -1;
}
exports.findLastIndex = findLastIndex;
function createSvgIconElement(iconId) {
    var svgNS = 'http://www.w3.org/2000/svg';
    var xlinkNS = 'http://www.w3.org/1999/xlink';
    var useElement = document.createElementNS(svgNS, 'use');
    useElement.setAttributeNS(xlinkNS, 'xlink:href', '#' + iconId);
    var template = document.createElementNS(svgNS, 'svg');
    template.appendChild(useElement);
    return template;
}
exports.createSvgIconElement = createSvgIconElement;
var RedBlackTree = (function () {
    function RedBlackTree(compare) {
        this._root = null;
        this._compare = null;
        this._compare = compare;
    }
    RedBlackTree.prototype.getOrAdd = function (key, getValue) {
        if (this._root == null) {
            var value = getValue();
            this._root = new RedBlackNode(null, key, value);
            this._root.isRed = false;
            return { added: true, value: value };
        }
        var last = this._root;
        while (true) {
            var relation = this._compare(key, last.key);
            if (relation === 0)
                return { added: false, value: last.value };
            if (relation < 0) {
                if (last.left == null) {
                    var value = getValue();
                    last.left = new RedBlackNode(last, key, value);
                    this._rebalance(last.left);
                    return { added: true, value: value };
                }
                else {
                    last = last.left;
                }
            }
            else {
                if (last.right == null) {
                    var value = getValue();
                    last.right = new RedBlackNode(last, key, value);
                    this._rebalance(last.right);
                    return { added: true, value: value };
                }
                else {
                    last = last.right;
                }
            }
        }
    };
    RedBlackTree.prototype._rebalance = function (node) {
        if (node.parent == null) {
            node.isRed = false;
            return;
        }
        while (node.parent != null && node.parent.isRed) {
            if (node.parent.parent.isRed) {
                node.parent.isRed = false;
                return;
            }
            if (node.parent == node.parent.parent.left) {
                var uncle = node.parent.parent.right;
                if (uncle != null && uncle.isRed) {
                    node.parent.isRed = false;
                    uncle.isRed = false;
                    node.parent.parent.isRed = true;
                    node = node.parent.parent;
                }
                else {
                    if (node == node.parent.right) {
                        node = node.parent;
                        this._rotateLeft(node);
                    }
                    node.parent.isRed = false;
                    node.parent.parent.isRed = true;
                    this._rotateRight(node.parent.parent);
                }
            }
            else {
                var uncle = node.parent.parent.left;
                if (uncle != null && uncle.isRed == true) {
                    node.parent.isRed = false;
                    uncle.isRed = false;
                    node.parent.parent.isRed = true;
                    node = node.parent.parent;
                }
                else {
                    if (node == node.parent.left) {
                        node = node.parent;
                        this._rotateRight(node);
                    }
                    node.parent.isRed = false;
                    node.parent.parent.isRed = true;
                    this._rotateLeft(node.parent.parent);
                }
            }
        }
        this._root.isRed = false;
    };
    RedBlackTree.prototype._rotateLeft = function (node) {
        var right = node.right;
        node.right = right.left;
        if (right.left != null)
            right.left.parent = node;
        right.parent = node.parent;
        if (node.parent == null) {
            this._root = right;
        }
        else if (node == node.parent.left) {
            node.parent.left = right;
        }
        else {
            node.parent.right = right;
        }
        right.left = node;
        node.parent = right;
    };
    RedBlackTree.prototype._rotateRight = function (node) {
        var left = node.left;
        node.left = left.right;
        if (left.right != null) {
            left.right.parent = node;
        }
        left.parent = node.parent;
        if (node.parent == null) {
            this._root = left;
        }
        else if (node == node.parent.left) {
            node.parent.left = left;
        }
        else {
            node.parent.right = left;
        }
        left.right = node;
        node.parent = left;
    };
    return RedBlackTree;
}());
exports.RedBlackTree = RedBlackTree;
var RedBlackNode = (function () {
    function RedBlackNode(parent, key, value) {
        this.left = null;
        this.right = null;
        this.parent = parent;
        this.key = key;
        this.value = value;
        this.isRed = true;
    }
    return RedBlackNode;
}());
function unwrapSpecialNullValue(value) {
    return value === special_values_1.specialValues.nullValueGuid ? null : value;
}
exports.unwrapSpecialNullValue = unwrapSpecialNullValue;
