/**
* DevExpress Dashboard (_item-data.js)
* Version:  21.2.3
* Build date: Oct 25, 2021
* Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _formatter_1 = require("../_formatter");
var _utils_1 = require("../_utils");
var _item_meta_data_1 = require("./internal/_item-meta-data");
var item_data_axis_names_1 = require("./item-data-axis-names");
var _item_data_axis_1 = require("./_item-data-axis");
var _item_data_axis_point_1 = require("./_item-data-axis-point");
var _item_data_tuple_1 = require("./_item-data-tuple");
var itemData = (function () {
    function itemData(metaData, storage, rootItems) {
        this._metaData = metaData;
        this._storage = storage;
        this._rootItems = rootItems;
    }
    itemData.prototype.isEmpty = function () {
        return this._storage.isEmpty();
    };
    itemData.prototype.getCurrentFilterValues = function (dimensionIds, axisName, selectedValues) {
        var that = this, dimensionCount = dimensionIds.length;
        if (dimensionCount > 0) {
            var axis = this.getAxis(axisName), tuples = [];
            if (selectedValues) {
                for (var valueIndex = 0; valueIndex < selectedValues.length; valueIndex++) {
                    var point = selectedValues[valueIndex];
                    var value = point[0];
                    var axisPoint = axis.getPointsByDimension(dimensionIds[0]).filter(function (point) {
                        return _utils_1.checkValuesAreEqual(value, point.getUniqueValue());
                    })[0];
                    for (var i = 1; i < dimensionCount; i++) {
                        value = point[i];
                        axisPoint = axisPoint.getChildren().filter(function (point) {
                            return _utils_1.checkValuesAreEqual(value, point.getUniqueValue());
                        })[0];
                    }
                    tuples.push(new _item_data_tuple_1.itemDataTuple([axisPoint]));
                }
            }
            return tuples;
        }
        return null;
    };
    itemData.prototype.getCurrentDrillDownValues = function (dimensionIds, axisName) {
        var dimensionCount = dimensionIds.length;
        if (dimensionCount > 0) {
            var axis = this.getAxis(axisName);
            if (axis) {
                var axisPoints = axis.getPointsByDimension(dimensionIds[0]);
                if (axisPoints.length > 0) {
                    var parentPoint = axisPoints[0].getParent();
                    if (parentPoint.getParent() != null) {
                        return new _item_data_tuple_1.itemDataTuple([parentPoint]);
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
            else {
                return null;
            }
        }
        return null;
    };
    itemData.prototype.getAvailableTuples = function (dimensionIds, axisName) {
        var that = this, dimensionCount = dimensionIds.length;
        if (dimensionCount > 0) {
            var axis = this.getAxis(axisName);
            if (axis) {
                var tuples = [];
                axis.getPointsByDimension(dimensionIds[dimensionCount - 1]).forEach(function (axisPoint) {
                    tuples.push(new _item_data_tuple_1.itemDataTuple([axisPoint]));
                });
                return tuples;
            }
        }
        return null;
    };
    itemData.prototype.getAllSelectionValues = function (dimensionIds) {
        var multiData = this, allAxisNames = multiData.getAxisNames(), axisNames = [], selectionList = [], fillAvailableValues = function (axes, row, inputSelection) {
            var firstAxis = multiData.getAxis(axes[0]), nextAxes = axes.slice(1, axes.length), axisPoints = firstAxis.getPoints() || [];
            axisPoints.forEach(function (axisPoint) {
                var newRow = row.slice();
                axisPoint.getAxisPath().forEach(function (pathPoint) {
                    if (dimensionIds.filter(function (id) { return id === pathPoint.getDimension().id; }).length > 0) {
                        newRow.push(pathPoint.getUniqueValue());
                    }
                });
                if (axes.length > 1) {
                    fillAvailableValues(nextAxes, newRow, inputSelection);
                }
                else {
                    inputSelection.push(newRow);
                }
            });
        };
        if (dimensionIds && dimensionIds.length > 0) {
            dimensionIds.forEach(function (id) {
                allAxisNames.forEach(function (axisName) {
                    if (multiData.getAxis(axisName).getDimensions().filter(function (descr) {
                        return descr.id === id;
                    }).length > 0
                        && axisNames.indexOf(axisName) === -1) {
                        axisNames.push(axisName);
                    }
                });
            });
            fillAvailableValues(axisNames, [], selectionList);
        }
        return selectionList;
    };
    itemData.prototype.getMeasuresByIds = function (measureIds) {
        var that = this, measures = [];
        measureIds.forEach(function (id) {
            measures.push(that.getMeasureById(id));
        });
        return measures;
    };
    itemData.prototype.getAxisNames = function () {
        return this._metaData.getAxisNames();
    };
    itemData.prototype.getAxis = function (axisName) {
        if (axisName === undefined) {
            axisName = item_data_axis_names_1.itemDataAxisNames.defaultAxis;
        }
        var dimensions = this.getDimensions(axisName), root = this._rootItems[axisName];
        return root ? new _item_data_axis_1.itemDataAxis(dimensions, root) : null;
    };
    itemData.prototype.getDimensions = function (axisName) {
        return this._metaData.getDimensions(axisName);
    };
    itemData.prototype.getColorMeasures = function () {
        return this._metaData.getColorMeasures();
    };
    itemData.prototype.getMeasures = function () {
        return this._metaData.getMeasures();
    };
    itemData.prototype.getDeltas = function () {
        return this._metaData.getDeltas();
    };
    itemData.prototype.getMeasureById = function (id) {
        return this._metaData.getMeasureById(id);
    };
    itemData.prototype.getDeltaById = function (id) {
        return this._metaData.getDeltaById(id);
    };
    itemData.prototype.getSlice = function (value) {
        return (value instanceof _item_data_tuple_1.itemDataTuple) ? this._getSliceByTuple(value) :
            (value instanceof _item_data_axis_point_1.itemDataAxisPoint) ? this._getSliceByAxisPoint(value) : null;
    };
    itemData.prototype.getMeasureFormat = function (measureId) {
        return this._metaData.getMeasureFormat(measureId);
    };
    itemData.prototype.getMeasureExpression = function (measureId) {
        return this._metaData.getMeasureExpression(measureId);
    };
    itemData.prototype.getMeasureCalculation = function (measureId) {
        return this._metaData.getMeasureCalculation(measureId);
    };
    itemData.prototype.getMeasureWindowDefinition = function (measureId) {
        return this._metaData.getMeasureWindowDefinition(measureId);
    };
    itemData.prototype.getDimensionFormat = function (dimensionId) {
        return this._metaData.getDimensionFormat(dimensionId);
    };
    itemData.prototype.getColorMeasureValue = function (colorMeasureId) {
        return this._getValue(colorMeasureId);
    };
    itemData.prototype.getConditionalFormattingMeasureValue = function (cfMeasureId) {
        return this._getValue(cfMeasureId);
    };
    itemData.prototype.getMeasureValue = function (measureId) {
        var that = this, format = that.getMeasureFormat(measureId);
        return that._getMeasureValueByKeys(that._getKeys(), measureId, format);
    };
    itemData.prototype.getPointsByDimensionId = function (dimensionId) {
        var points = [], root, axis;
        var that = this;
        var axes = that._metaData.getAxes();
        Object.keys(axes).forEach(function (axisName) {
            var dimensions = axes[axisName];
            var foundDimensions = dimensions.filter(function (dimension) {
                return dimension.id === dimensionId;
            });
            if (foundDimensions) {
                root = that._rootItems[axisName];
                axis = new _item_data_axis_1.itemDataAxis(dimensions, root);
                points = axis.getPointsByDimension(dimensionId);
                return false;
            }
        });
        return points;
    };
    itemData.prototype._getKeys = function (points) {
        var that = this, rootItems = that._rootItems, keysList = [];
        Object.keys(rootItems).forEach(function (axisName) {
            var userPoint = (points && points[axisName]), point = userPoint || rootItems[axisName];
            keysList.push(point.getKey());
        });
        return keysList;
    };
    itemData.prototype._getValue = function (measureId) {
        var that = this;
        return that._getCellValue(that._getKeys(), measureId);
    };
    itemData.prototype._getMeasureValueByKeys = function (keys, mId, format) {
        var that = this;
        return {
            getValue: function () {
                return that._getCellValue(keys, mId);
            },
            getDisplayText: function () {
                return that._getCellDisplayText(keys, mId, format);
            }
        };
    };
    itemData.prototype._getDeltaValueByKeys = function (keys, deltaIds, formats) {
        var that = this, names = _item_meta_data_1.deltaValueNames, getValueItem = function (valueName) {
            return {
                getValue: function () {
                    return that._getCellValue(keys, deltaIds[valueName]);
                },
                getDisplayText: function () {
                    var format = formats[valueName];
                    if (format) {
                        format = {
                            NumericFormat: format
                        };
                    }
                    return that._getCellDisplayText(keys, deltaIds[valueName], format);
                }
            };
        };
        return {
            getActualValue: function () {
                return getValueItem(names.actualValue);
            },
            getTargetValue: function () {
                return getValueItem(names.targetValue);
            },
            getAbsoluteVariation: function () {
                return getValueItem(names.absoluteVariation);
            },
            getPercentVariation: function () {
                return getValueItem(names.percentVariation);
            },
            getPercentOfTarget: function () {
                return getValueItem(names.percentOfTarget);
            },
            getIsGood: function () {
                return getValueItem(names.isGood);
            },
            getIndicatorType: function () {
                return getValueItem(names.indicatorType);
            },
            getDisplayValue: function () {
                return getValueItem(names.mainValue);
            },
            getDisplaySubValue1: function () {
                return getValueItem(names.subValue1);
            },
            getDisplaySubValue2: function () {
                return getValueItem(names.subValue2);
            }
        };
    };
    itemData.prototype._createPointsCache = function (axisPoints) {
        var cache = {};
        for (var i = 0; i < axisPoints.length; i++) {
            var areaName = axisPoints[i].getAxisName();
            cache[areaName] = axisPoints[i];
        }
        return cache;
    };
    itemData.prototype.getMeasureValueByAxisPoints = function (measureId, axisPoints) {
        var that = this, format = that.getMeasureFormat(measureId), pointsCache = that._createPointsCache(axisPoints);
        return that._getMeasureValueByKeys(that._getKeys(pointsCache), measureId, format);
    };
    itemData.prototype.getDeltaValue = function (deltaId) {
        var that = this, metaData = that._metaData, deltaIds = metaData.getDeltaValueIds(deltaId), formats = metaData.getDeltaFormats(deltaId);
        return that._getDeltaValueByKeys(that._getKeys(), deltaIds, formats);
    };
    itemData.prototype.getDeltaValueByAxisPoints = function (deltaId, axisPoints) {
        var that = this, metaData = this._metaData, deltaIds = metaData.getDeltaValueIds(deltaId), formats = metaData.getDeltaFormats(deltaId), pointsCache = this._createPointsCache(axisPoints);
        return this._getDeltaValueByKeys(that._getKeys(pointsCache), deltaIds, formats);
    };
    itemData.prototype.getDataMembers = function () {
        return this._metaData.getDataMembers();
    };
    itemData.prototype.createTuple = function (values) {
        var that = this, axisPoints = [];
        if (values[0] instanceof _item_data_axis_point_1.itemDataAxisPoint) {
            axisPoints = values;
        }
        else {
            values.forEach(function (axisValue) {
                var axis = that.getAxis(axisValue.AxisName), axisPoint = axis.getPointByUniqueValues(axisValue.Value);
                axisPoints.push(axisPoint);
            });
        }
        return new _item_data_tuple_1.itemDataTuple(axisPoints);
    };
    itemData.prototype._getCellValue = function (keys, valueId) {
        return this._storage.getCrossValue(keys, valueId);
    };
    itemData.prototype._getCellDisplayText = function (keys, valueId, format) {
        return format ? _formatter_1.format(this._getCellValue(keys, valueId), format) : undefined;
    };
    itemData.prototype._getSliceByAxisPoint = function (axisPoint) {
        var that = this, rootItems = that._rootItems, newRootItems = {};
        Object.keys(rootItems).forEach(function (name) {
            newRootItems[name] = axisPoint.getAxisName() === name ? axisPoint : rootItems[name];
        });
        return new itemData(that._metaData, that._storage, newRootItems);
    };
    itemData.prototype._getSliceByTuple = function (tuple) {
        var data = this;
        tuple._axisPoints.forEach(function (axisPoint) {
            data = data._getSliceByAxisPoint(axisPoint);
        });
        return data;
    };
    return itemData;
}());
exports.itemData = itemData;
