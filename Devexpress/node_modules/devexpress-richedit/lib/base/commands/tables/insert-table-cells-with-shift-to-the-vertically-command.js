"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var table_cell_properties_history_items_1 = require("../../../core/model/history/items/tables/table-cell-properties-history-items");
var merge_table_cells_operation_1 = require("../../../core/model/manipulators/tables/merge-table-cells-operation");
var control_1 = require("../../../core/model/options/control");
var sub_document_1 = require("../../../core/model/sub-document");
var table_1 = require("../../../core/model/tables/main-structures/table");
var table_base_structures_1 = require("../../../core/model/tables/secondary-structures/table-base-structures");
var table_utils_1 = require("../../../core/model/tables/table-utils");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var list_1 = require("@devexpress/utils/lib/utils/list");
var selection_history_item_1 = require("../../model/history/selection/selection-history-item");
var command_base_1 = require("../command-base");
var command_states_1 = require("../command-states");
var InsertTableCellsWithShiftToTheVerticallyCommand = (function (_super) {
    tslib_1.__extends(InsertTableCellsWithShiftToTheVerticallyCommand, _super);
    function InsertTableCellsWithShiftToTheVerticallyCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InsertTableCellsWithShiftToTheVerticallyCommand.prototype.getState = function () {
        return new command_states_1.SimpleCommandState(this.isEnabled());
    };
    InsertTableCellsWithShiftToTheVerticallyCommand.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && control_1.ControlOptions.isEnabled(this.control.modelManager.richOptions.control.tables) && this.selection.tableInfo.extendedData.areCellsSelectedInSeries;
    };
    InsertTableCellsWithShiftToTheVerticallyCommand.prototype.executeCore = function (_state, options) {
        var _this = this;
        this.history.beginTransaction();
        var tableInfo = this.selection.tableInfo;
        var table = tableInfo.table;
        var newCells = [];
        tableInfo.extendedData.foreach(function (rowInfo) {
            return list_1.ListUtils.addListOnTail(newCells, _this.insertTableCellWithShiftToTheVertically(_this.selection.activeSubDocument, table, rowInfo));
        }, function () { });
        var newCellIntervals = [];
        for (var i = 0, newCell = void 0; newCell = newCells[i]; i++)
            newCellIntervals.push(newCell.interval);
        table_utils_1.TableConditionalFormattingCalculator.updateTable(this.control.modelManager, table, options.subDocument);
        this.history.addAndRedo(new selection_history_item_1.SelectionHistoryItem(this.modelManipulator, this.selection, this.selection.getState(), this.selection.getState().setIntervals(newCellIntervals)));
        this.history.endTransaction();
        return true;
    };
    InsertTableCellsWithShiftToTheVerticallyCommand.prototype.insertTableCellWithShiftToTheVertically = function (subDocument, table, rowInfo) {
        if (list_1.ListUtils.allOf(rowInfo.cells, function (c) { return c.cell.verticalMerging == table_base_structures_1.TableCellMergingState.Continue; }))
            return [];
        var startCellIndex = rowInfo.cells[0].cellIndex;
        var endCellIndex = startCellIndex + rowInfo.cells.length - 1;
        var insertedRowsCount = this.calculateInsertedRowsCount(table, rowInfo.rowIndex, startCellIndex, endCellIndex);
        var newCells = [];
        for (var i = 0; i < insertedRowsCount; i++) {
            this.modelManipulator.table.insertRowBelow(subDocument, table, table.rows.length - 1, this.inputPosition);
            for (var cellIndex = endCellIndex; cellIndex >= startCellIndex; cellIndex--) {
                newCells = newCells.concat(this.insertCellWithShiftToTheDown(subDocument, table, rowInfo.rowIndex + i, cellIndex));
            }
        }
        this.deleteTextInCell(subDocument, table, rowInfo.rowIndex, insertedRowsCount);
        return newCells;
    };
    InsertTableCellsWithShiftToTheVerticallyCommand.prototype.calculateInsertedRowsCount = function (table, rowIndex, startCellIndex, endCellIndex) {
        var row = table.rows[rowIndex];
        var result = Number.MAX_VALUE;
        for (var i = startCellIndex; i <= endCellIndex; i++) {
            var cell = row.cells[i];
            var columnIndex = table_utils_1.TableCellUtils.getStartColumnIndex(cell);
            result = Math.min(result, table_utils_1.TableCellUtils.getVerticalSpanCellPositions(table_1.TablePosition.createAndInit(table, rowIndex, i), columnIndex).length);
        }
        return result;
    };
    InsertTableCellsWithShiftToTheVerticallyCommand.prototype.insertCellWithShiftToTheDown = function (subDocument, table, rowIndex, cellIndex) {
        var newCells = [];
        for (var i = table.rows.length - 1; i > rowIndex; i--) {
            var currentRow = table.rows[i];
            var cellsCountInCurrentRow = currentRow.cells.length;
            var previousRow = table.rows[i - 1];
            if (cellIndex >= previousRow.cells.length)
                continue;
            if (cellIndex >= cellsCountInCurrentRow) {
                var previousRowLastCell = previousRow.cells[previousRow.cells.length - 1];
                this.insertTableCells(subDocument, table, i, currentRow.cells.length - 1, cellIndex - cellsCountInCurrentRow + 1, previousRowLastCell.preferredWidth);
            }
            new merge_table_cells_operation_1.InsertTableCellWithShiftToTheDownOperation(this.control.modelManager, subDocument).execute(table_1.TablePosition.createAndInit(table, i, cellIndex), false, this.inputPosition);
            newCells.push(table.rows[i].cells[cellIndex]);
        }
        this.deleteContentInCell(subDocument, table, rowIndex, cellIndex);
        this.modelManipulator.table.normalizeTableGrid(subDocument, table);
        this.modelManipulator.table.normalizeCellColumnSpans(subDocument, table, true);
        return newCells;
    };
    InsertTableCellsWithShiftToTheVerticallyCommand.prototype.insertTableCells = function (subDocument, table, patternRowIndex, patternCellIndex, insertedCellsCount, preferredWidth) {
        for (var i = 0; i < insertedCellsCount; i++) {
            var lastCellIndex = patternCellIndex + i;
            this.modelManipulator.table.insertCellToTheRight(subDocument, table, patternRowIndex, lastCellIndex, this.inputPosition, false, true, false);
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellPreferredWidthHistoryItem(this.modelManipulator, subDocument, table.index, patternRowIndex, lastCellIndex + 1, preferredWidth.clone()));
        }
    };
    InsertTableCellsWithShiftToTheVerticallyCommand.prototype.deleteTextInCell = function (subDocument, table, rowIndex, rowsCount) {
        var startRowIndex = rowIndex + 1;
        var endRowIndex = startRowIndex + rowsCount;
        for (var i = startRowIndex; i < endRowIndex; i++) {
            var row = table.rows[i];
            for (var cellIndex = 0, cell = void 0; cell = row.cells[cellIndex]; cellIndex++) {
                if (cell.verticalMerging === table_base_structures_1.TableCellMergingState.Continue)
                    this.deleteContentInCell(subDocument, table, i, cellIndex);
            }
        }
    };
    InsertTableCellsWithShiftToTheVerticallyCommand.prototype.deleteContentInCell = function (subDocument, table, rowIndex, cellIndex) {
        var cell = table.rows[rowIndex].cells[cellIndex];
        if (cell.endParagrapPosition.value - cell.startParagraphPosition.value > 1)
            this.modelManipulator.range.removeInterval(new sub_document_1.SubDocumentInterval(subDocument, fixed_1.FixedInterval.fromPositions(cell.startParagraphPosition.value, cell.endParagrapPosition.value - 1)), true, false);
    };
    return InsertTableCellsWithShiftToTheVerticallyCommand;
}(command_base_1.CommandBase));
exports.InsertTableCellsWithShiftToTheVerticallyCommand = InsertTableCellsWithShiftToTheVerticallyCommand;
