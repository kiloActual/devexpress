"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var border_helper_1 = require("../../../core/layout-formatter/table/borders/border-helper");
var border_info_1 = require("../../../core/model/borders/border-info");
var table_cell_properties_history_items_1 = require("../../../core/model/history/items/tables/table-cell-properties-history-items");
var table_properties_history_items_1 = require("../../../core/model/history/items/tables/table-properties-history-items");
var control_1 = require("../../../core/model/options/control");
var table_1 = require("../../../core/model/tables/main-structures/table");
var table_cell_properties_merger_1 = require("../../../core/model/tables/properties-mergers/table-cell-properties-merger");
var table_properties_merger_1 = require("../../../core/model/tables/properties-mergers/table-properties-merger");
var table_base_structures_1 = require("../../../core/model/tables/secondary-structures/table-base-structures");
var client_command_1 = require("../client-command");
var command_base_1 = require("../command-base");
var command_states_1 = require("../command-states");
var ToggleTableCellsBorderCommandBase = (function (_super) {
    tslib_1.__extends(ToggleTableCellsBorderCommandBase, _super);
    function ToggleTableCellsBorderCommandBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.affectNeighbours = true;
        _this.affectInner = true;
        _this.affectOuter = true;
        _this.affectOnStateFlags = TableBorderGridCellInfo.All;
        return _this;
    }
    Object.defineProperty(ToggleTableCellsBorderCommandBase.prototype, "colorProvider", {
        get: function () { return this.control.modelManager.model.colorProvider; },
        enumerable: true,
        configurable: true
    });
    ToggleTableCellsBorderCommandBase.prototype.DEPRECATEDConvertOptionsParameter = function (parameter) {
        return parameter instanceof border_info_1.BorderInfo ? parameter : this.control.modelManager.model.repositoryBorderItem;
    };
    ToggleTableCellsBorderCommandBase.prototype.getRelatedCommands = function () {
        var _a;
        return _a = {},
            _a[client_command_1.RichEditClientCommand.ToggleTableCellAllBorders] = true,
            _a[client_command_1.RichEditClientCommand.ToggleTableCellInsideBorders] = true,
            _a[client_command_1.RichEditClientCommand.ToggleTableCellInsideHorizontalBorders] = true,
            _a[client_command_1.RichEditClientCommand.ToggleTableCellInsideVerticalBorders] = true,
            _a[client_command_1.RichEditClientCommand.ToggleTableCellNoBorder] = true,
            _a[client_command_1.RichEditClientCommand.ToggleTableCellOutsideBorders] = true,
            _a[client_command_1.RichEditClientCommand.ToggleTableCellsBottomBorder] = true,
            _a[client_command_1.RichEditClientCommand.ToggleTableCellsLeftBorder] = true,
            _a[client_command_1.RichEditClientCommand.ToggleTableCellsRightBorder] = true,
            _a[client_command_1.RichEditClientCommand.ToggleTableCellsTopBorder] = true,
            _a;
    };
    ToggleTableCellsBorderCommandBase.prototype.getState = function (options) {
        if (options === void 0) { options = this.convertToCommandOptions(null); }
        var tableInfo = this.selection.tableInfo;
        var enabled = this.isEnabled() && this.selection.tableInfo.extendedData.areCellsSelectedInSeries;
        var state = new command_states_1.SimpleCommandState(enabled);
        if (state.enabled)
            state.value = this.isChecked(tableInfo, options.param);
        return state;
    };
    ToggleTableCellsBorderCommandBase.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && control_1.ControlOptions.isEnabled(this.control.modelManager.richOptions.control.tables);
    };
    ToggleTableCellsBorderCommandBase.prototype.isChecked = function (tableInfo, patternBorder) {
        var table = tableInfo.table;
        if (tableInfo.extendedData.isSelectedEntireTable)
            return this.checkBorderInEntireTable(patternBorder, table);
        var tableBordersInfo = new border_helper_1.TableBorderInfoProvider(this.control.modelManager.model, table, function (v) { return v; });
        var bordersGrid = this.createCellBorderGrid(table, tableInfo, tableBordersInfo);
        return this.isCheckedInParticallyTableSelection(table, bordersGrid, tableBordersInfo, patternBorder);
    };
    ToggleTableCellsBorderCommandBase.prototype.executeCore = function (state, options) {
        this.history.beginTransaction();
        var tableInfo = this.selection.tableInfo;
        var table = tableInfo.table;
        var patternBorder = options.param;
        var subDocument = this.selection.activeSubDocument;
        if (tableInfo.extendedData.isSelectedEntireTable)
            this.applyBorderToTable(subDocument, table, state.value ? null : patternBorder);
        var tblBrdProv = new border_helper_1.TableBorderInfoProvider(this.control.modelManager.model, table, function (v) { return v; });
        var grid = this.createCellBorderGrid(table, tableInfo, tblBrdProv);
        for (var i = 0, gridRow = void 0; gridRow = grid[i]; i++) {
            var cellIndex = -1;
            var prevCell = null;
            for (var j = 0, gridCell = void 0; gridCell = gridRow[j]; j++) {
                if (gridCell.cell != prevCell)
                    cellIndex++;
                prevCell = gridCell.cell;
                if (!gridCell.cell || gridCell.cell.verticalMerging === table_base_structures_1.TableCellMergingState.Continue)
                    continue;
                this.applyBorderToCell(subDocument, table, gridCell, i, cellIndex, state.value ? null : patternBorder.clone());
            }
        }
        this.history.endTransaction();
        return true;
    };
    ToggleTableCellsBorderCommandBase.prototype.isCheckedInParticallyTableSelection = function (table, grid, tableBordersInfo, patternBorder) {
        var hasAffectedCells = false;
        for (var i = 0, gridRow = void 0; gridRow = grid[i]; i++) {
            for (var j = 0, gridCell = void 0; gridCell = gridRow[j]; j++) {
                if (!gridCell.cell || gridCell.cell.verticalMerging === table_base_structures_1.TableCellMergingState.Continue || gridCell.info === TableBorderGridCellInfo.None)
                    continue;
                if (!(gridCell.info & this.affectOnStateFlags))
                    continue;
                hasAffectedCells = true;
                if (!this.checkBorderInParticallyTableSelection(patternBorder, table, grid, gridCell, i, j, tableBordersInfo))
                    return false;
            }
        }
        return hasAffectedCells;
    };
    ToggleTableCellsBorderCommandBase.prototype.createCellBorderGrid = function (table, tableInfo, tableBordersInfo) {
        var grid = this.createCellBorderGridCore(table, tableInfo);
        var rowsCount = grid.length;
        var columnsCount = grid[0].length;
        for (var rowIndex = 0, row = void 0; row = table.rows[rowIndex]; rowIndex++) {
            var columnIndex = row.gridBefore;
            var isLastRow = rowIndex + 1 === rowsCount;
            var hasSpacing = tableBordersInfo.cellSpacings[rowIndex] > 0;
            for (var cellIndex = 0, cell = void 0; cell = row.cells[cellIndex]; cellIndex++) {
                var isLastCell = columnIndex + cell.columnSpan === columnsCount;
                var gridCell = grid[rowIndex][columnIndex];
                if (cell.verticalMerging === table_base_structures_1.TableCellMergingState.Continue) {
                    if (isLastRow && grid[rowIndex - 1][columnIndex].info & TableBorderGridCellInfo.BottomOuter) {
                        var prevRowIndex = rowIndex;
                        do {
                            prevRowIndex--;
                            grid[prevRowIndex][columnIndex].info |= TableBorderGridCellInfo.BottomTableOuter;
                        } while (grid[prevRowIndex][columnIndex].cell.verticalMerging !== table_base_structures_1.TableCellMergingState.Restart);
                    }
                    gridCell.info = grid[rowIndex - 1][columnIndex].info;
                }
                else if (!gridCell.selected) {
                    if (!hasSpacing && this.affectNeighbours) {
                        if (!isLastRow && this.checkBottomSibling(grid, rowIndex, columnIndex, ToggleTableCellsBorderCommandBase.checkVSiblingSelected))
                            gridCell.info |= TableBorderGridCellInfo.TopNeighbour;
                        if (this.checkLeftRightSiblingSelected(cell, rowIndex, columnIndex, columnIndex - 1, TableBorderGridCellInfo.RightNeighbour, grid))
                            gridCell.info |= TableBorderGridCellInfo.RightNeighbour;
                        if (ToggleTableCellsBorderCommandBase.checkVSiblingSelected(cell.columnSpan, rowIndex - 1, columnIndex, grid))
                            gridCell.info |= TableBorderGridCellInfo.BottomNeighbour;
                        if (!isLastCell && this.checkLeftRightSiblingSelected(cell, rowIndex, columnIndex, columnIndex + cell.columnSpan, TableBorderGridCellInfo.LeftNeighbour, grid))
                            gridCell.info |= TableBorderGridCellInfo.LeftNeighbour;
                    }
                }
                else {
                    if (this.affectInner) {
                        if (ToggleTableCellsBorderCommandBase.checkVSiblingSelected(cell.columnSpan, rowIndex - 1, columnIndex, grid))
                            gridCell.info |= TableBorderGridCellInfo.TopInner;
                        if (!isLastRow && this.checkBottomSibling(grid, rowIndex, columnIndex, ToggleTableCellsBorderCommandBase.checkVSiblingSelected))
                            gridCell.info |= TableBorderGridCellInfo.BottomInner;
                        if (this.checkLeftRightSiblingSelected(cell, rowIndex, columnIndex, columnIndex - 1, TableBorderGridCellInfo.LeftInner, grid))
                            gridCell.info |= TableBorderGridCellInfo.LeftInner;
                        if (!isLastCell && this.checkLeftRightSiblingSelected(cell, rowIndex, columnIndex, columnIndex + cell.columnSpan, TableBorderGridCellInfo.RightInner, grid))
                            gridCell.info |= TableBorderGridCellInfo.RightInner;
                    }
                    if (this.affectOuter) {
                        if (ToggleTableCellsBorderCommandBase.checkVSiblingUnselected(cell.columnSpan, rowIndex - 1, columnIndex, grid))
                            gridCell.info |= TableBorderGridCellInfo.TopOuter;
                        if (isLastRow || this.checkBottomSibling(grid, rowIndex, columnIndex, ToggleTableCellsBorderCommandBase.checkVSiblingUnselected))
                            gridCell.info |= TableBorderGridCellInfo.BottomOuter;
                        if (!this.checkLeftRightSiblingSelected(cell, rowIndex, columnIndex, columnIndex - 1, TableBorderGridCellInfo.LeftInner, grid))
                            gridCell.info |= TableBorderGridCellInfo.LeftOuter;
                        if (isLastCell || !this.checkLeftRightSiblingSelected(cell, rowIndex, columnIndex, columnIndex + cell.columnSpan, TableBorderGridCellInfo.RightInner, grid))
                            gridCell.info |= TableBorderGridCellInfo.RightOuter;
                        if (columnIndex === 0)
                            gridCell.info |= TableBorderGridCellInfo.LeftTableOuter;
                        if (columnIndex + cell.columnSpan === columnsCount)
                            gridCell.info |= TableBorderGridCellInfo.RightTableOuter;
                        if (rowIndex === 0)
                            gridCell.info |= TableBorderGridCellInfo.TopTableOuter;
                        if (rowIndex === rowsCount - 1)
                            gridCell.info |= TableBorderGridCellInfo.BottomTableOuter;
                    }
                }
                columnIndex += cell.columnSpan;
            }
        }
        return grid;
    };
    ToggleTableCellsBorderCommandBase.prototype.createCellBorderGridCore = function (table, tableInfo) {
        var grid = [];
        var selectedCellsVIndex = 0;
        var selectedCellsHIndex = -1;
        for (var rowIndex = 0, row = void 0; row = table.rows[rowIndex]; rowIndex++) {
            var horSelectedRowInfo = tableInfo.extendedData.rows[selectedCellsVIndex];
            if (horSelectedRowInfo && horSelectedRowInfo.row === row) {
                selectedCellsVIndex++;
                selectedCellsHIndex = 0;
            }
            else
                selectedCellsHIndex = -1;
            grid.push([]);
            for (var i = 0; i < row.gridBefore; i++)
                grid[rowIndex].push({ cell: null, info: TableBorderGridCellInfo.None, selected: false });
            var columnIndex = row.gridBefore;
            for (var cellIndex = 0, cell = void 0; cell = row.cells[cellIndex]; cellIndex++) {
                var borderGridCell = { cell: cell, info: TableBorderGridCellInfo.None, selected: false };
                if (cell.verticalMerging === table_base_structures_1.TableCellMergingState.Continue && grid[rowIndex - 1][columnIndex].selected) {
                    if (grid[rowIndex - 1][columnIndex].selected)
                        borderGridCell.selected = true;
                }
                if (selectedCellsHIndex > -1 && horSelectedRowInfo.cells[selectedCellsHIndex] && horSelectedRowInfo.cells[selectedCellsHIndex].cell === cell) {
                    borderGridCell.selected = true;
                    selectedCellsHIndex++;
                }
                for (var i = 0; i < cell.columnSpan; i++)
                    grid[rowIndex].push(borderGridCell);
                columnIndex += cell.columnSpan;
            }
            for (var i = 0; i < row.gridAfter; i++)
                grid[rowIndex].push({ cell: null, info: TableBorderGridCellInfo.None, selected: false });
        }
        return grid;
    };
    ToggleTableCellsBorderCommandBase.prototype.checkBottomSibling = function (grid, rowIndex, columnIndex, testFunc) {
        var gridCell = grid[rowIndex][columnIndex];
        if (gridCell.cell.verticalMerging === table_base_structures_1.TableCellMergingState.Restart) {
            while (grid[rowIndex]) {
                rowIndex++;
                if (!grid[rowIndex] || grid[rowIndex][columnIndex].cell.verticalMerging !== table_base_structures_1.TableCellMergingState.Continue)
                    break;
            }
        }
        else
            rowIndex++;
        return testFunc(gridCell.cell.columnSpan, rowIndex, columnIndex, grid);
    };
    ToggleTableCellsBorderCommandBase.checkVSiblingSelected = function (columnSpan, checkingRowIndex, columnIndex, grid) {
        if (checkingRowIndex < 0)
            return false;
        if (!grid[checkingRowIndex])
            return false;
        for (var i = 0; i < columnSpan; i++) {
            if (!grid[checkingRowIndex][columnIndex + i].selected)
                return false;
        }
        return true;
    };
    ToggleTableCellsBorderCommandBase.checkVSiblingUnselected = function (columnSpan, checkingRowIndex, columnIndex, grid) {
        if (checkingRowIndex < 0)
            return true;
        if (!grid[checkingRowIndex])
            return true;
        for (var i = 0; i < columnSpan; i++) {
            if (grid[checkingRowIndex][columnIndex + i].selected)
                return false;
        }
        return true;
    };
    ToggleTableCellsBorderCommandBase.prototype.checkLeftRightSiblingSelected = function (cell, rowIndex, columnIndex, sibColumnIndex, testingPosition, grid) {
        if (sibColumnIndex < 0)
            return false;
        if (!grid[rowIndex][sibColumnIndex].selected)
            return false;
        if (cell.verticalMerging === table_base_structures_1.TableCellMergingState.Restart) {
            while (true) {
                rowIndex++;
                if (!grid[rowIndex] || !grid[rowIndex][columnIndex].cell || grid[rowIndex][columnIndex].cell.verticalMerging !== table_base_structures_1.TableCellMergingState.Continue)
                    break;
                if (!grid[rowIndex][sibColumnIndex].selected)
                    return false;
            }
        }
        else if (cell.verticalMerging === table_base_structures_1.TableCellMergingState.Continue) {
            while (rowIndex > 0) {
                rowIndex--;
                if (grid[rowIndex][columnIndex].cell.verticalMerging === table_base_structures_1.TableCellMergingState.Restart) {
                    if (!(grid[rowIndex][columnIndex].info & testingPosition))
                        return false;
                    break;
                }
            }
        }
        return true;
    };
    ToggleTableCellsBorderCommandBase.prototype.getActualLeftBorder = function (tableBordersInfo, table, rowIndex, columnIndex) {
        var pos = new table_1.TablePosition(table, rowIndex, columnIndex).init();
        return border_helper_1.BorderHelper.getLeftBorder(this.colorProvider, pos, pos.row.cells[pos.cellIndex - 1], tableBordersInfo, function (v) { return v; });
    };
    ToggleTableCellsBorderCommandBase.prototype.getActualRightBorder = function (tableBordersInfo, table, rowIndex, columnIndex) {
        var pos = new table_1.TablePosition(table, rowIndex, columnIndex).init();
        return border_helper_1.BorderHelper.getRightBorder(this.colorProvider, pos, pos.row.cells[pos.cellIndex + 1], tableBordersInfo, function (v) { return v; });
    };
    ToggleTableCellsBorderCommandBase.prototype.getActualTopBorder = function (grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex) {
        var cellSpacing = tableBordersInfo.cellSpacings[rowIndex];
        var sibling = rowIndex > 0 ? grid[rowIndex - 1][columnIndex] : null;
        if (cellSpacing > 0)
            return border_helper_1.BorderHelper.mergeThreeBorders(this.colorProvider, currentCell.cell, table_cell_properties_merger_1.TableCellPropertiesMergerBorderTop, null, null, !sibling, tableBordersInfo.horizontalBorder, table.style, function (v) { return v; });
        if (currentCell.info & TableBorderGridCellInfo.TopTableOuter)
            return border_helper_1.BorderHelper.mergeThreeBorders(this.colorProvider, currentCell.cell, table_cell_properties_merger_1.TableCellPropertiesMergerBorderTop, null, null, true, tableBordersInfo.topBorder, table.style, function (v) { return v; });
        return border_helper_1.BorderHelper.mergeThreeBorders(this.colorProvider, currentCell.cell, table_cell_properties_merger_1.TableCellPropertiesMergerBorderTop, sibling.cell, table_cell_properties_merger_1.TableCellPropertiesMergerBorderBottom, false, tableBordersInfo.horizontalBorder, table.style, function (v) { return v; });
    };
    ToggleTableCellsBorderCommandBase.prototype.getActualBottomBorder = function (grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex) {
        var cellSpacing = tableBordersInfo.cellSpacings[rowIndex];
        var sibling = rowIndex + 1 < grid.length ? grid[rowIndex + 1][columnIndex] : null;
        if (cellSpacing > 0)
            return border_helper_1.BorderHelper.mergeThreeBorders(this.colorProvider, currentCell.cell, table_cell_properties_merger_1.TableCellPropertiesMergerBorderBottom, null, null, !sibling, tableBordersInfo.horizontalBorder, table.style, function (v) { return v; });
        if (currentCell.info & TableBorderGridCellInfo.BottomTableOuter)
            return border_helper_1.BorderHelper.mergeThreeBorders(this.colorProvider, currentCell.cell, table_cell_properties_merger_1.TableCellPropertiesMergerBorderBottom, null, null, true, tableBordersInfo.bottomBorder, table.style, function (v) { return v; });
        return border_helper_1.BorderHelper.mergeThreeBorders(this.colorProvider, currentCell.cell, table_cell_properties_merger_1.TableCellPropertiesMergerBorderBottom, sibling.cell, table_cell_properties_merger_1.TableCellPropertiesMergerBorderTop, false, tableBordersInfo.horizontalBorder, table.style, function (v) { return v; });
    };
    return ToggleTableCellsBorderCommandBase;
}(command_base_1.CommandBase));
exports.ToggleTableCellsBorderCommandBase = ToggleTableCellsBorderCommandBase;
var ToggleSingleTableCellsBorderCommand = (function (_super) {
    tslib_1.__extends(ToggleSingleTableCellsBorderCommand, _super);
    function ToggleSingleTableCellsBorderCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ToggleSingleTableCellsBorderCommand.prototype.getGeneralizedBorder = function () {
        var actualBorder = null;
        var tableInfo = this.selection.tableInfo;
        var table = tableInfo.table;
        var tableBordersInfo = new border_helper_1.TableBorderInfoProvider(this.control.modelManager.model, table, function (v) { return v; });
        var grid = this.createCellBorderGrid(table, tableInfo, tableBordersInfo);
        for (var i = 0, gridRow = void 0; gridRow = grid[i]; i++) {
            for (var j = 0, gridCell = void 0; gridCell = gridRow[j]; j++) {
                if (!gridCell.cell || gridCell.cell.verticalMerging === table_base_structures_1.TableCellMergingState.Continue || gridCell.info === TableBorderGridCellInfo.None)
                    continue;
                if (!(gridCell.info & this.affectOnStateFlags))
                    continue;
                if (!actualBorder) {
                    actualBorder = this.getActualCellBorder(table, grid, gridCell, i, j, tableBordersInfo);
                    continue;
                }
                if (!actualBorder.equals(this.getActualCellBorder(table, grid, gridCell, i, j, tableBordersInfo)))
                    return null;
            }
        }
        return actualBorder;
    };
    return ToggleSingleTableCellsBorderCommand;
}(ToggleTableCellsBorderCommandBase));
exports.ToggleSingleTableCellsBorderCommand = ToggleSingleTableCellsBorderCommand;
var ToggleTableCellsTopBorderCommand = (function (_super) {
    tslib_1.__extends(ToggleTableCellsTopBorderCommand, _super);
    function ToggleTableCellsTopBorderCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.affectOnStateFlags = TableBorderGridCellInfo.TopOuter;
        _this.affectInner = false;
        return _this;
    }
    ToggleTableCellsTopBorderCommand.prototype.getActualCellBorder = function (table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return this.getActualTopBorder(grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex);
    };
    ToggleTableCellsTopBorderCommand.prototype.checkBorderInParticallyTableSelection = function (patternBorder, table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return patternBorder.equals(this.getActualCellBorder(table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo));
    };
    ToggleTableCellsTopBorderCommand.prototype.checkBorderInEntireTable = function (patternBorder, table) {
        return patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderTop().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties));
    };
    ToggleTableCellsTopBorderCommand.prototype.applyBorderToTable = function (subDocument, table, borderInfo) {
        if (!borderInfo) {
            borderInfo = table.properties.borders.topBorder.clone();
            borderInfo.width = 0;
        }
        else
            borderInfo = borderInfo.clone();
        this.history.addAndRedo(new table_properties_history_items_1.TableBordersHistoryItem(this.modelManipulator, subDocument, table.index, [borderInfo, undefined, undefined, undefined, undefined, undefined], [true, undefined, undefined, undefined, undefined, undefined]));
    };
    ToggleTableCellsTopBorderCommand.prototype.applyBorderToCell = function (subDocument, table, gridCell, rowIndex, cellIndex, borderInfo) {
        if (gridCell.info & TableBorderGridCellInfo.TopOuter) {
            if (!borderInfo) {
                borderInfo = gridCell.cell.properties.borders.topBorder.clone();
                borderInfo.width = 0;
            }
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [borderInfo, undefined, undefined, undefined, undefined, undefined], [true, undefined, undefined, undefined, undefined, undefined]));
        }
        if (gridCell.info & TableBorderGridCellInfo.TopNeighbour) {
            if (!borderInfo) {
                borderInfo = gridCell.cell.properties.borders.bottomBorder.clone();
                borderInfo.width = 0;
            }
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [undefined, undefined, borderInfo, undefined, undefined, undefined], [undefined, undefined, true, undefined, undefined, undefined]));
        }
    };
    return ToggleTableCellsTopBorderCommand;
}(ToggleSingleTableCellsBorderCommand));
exports.ToggleTableCellsTopBorderCommand = ToggleTableCellsTopBorderCommand;
var ToggleTableCellsRightBorderCommand = (function (_super) {
    tslib_1.__extends(ToggleTableCellsRightBorderCommand, _super);
    function ToggleTableCellsRightBorderCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.affectInner = false;
        _this.affectOnStateFlags = TableBorderGridCellInfo.RightOuter;
        return _this;
    }
    ToggleTableCellsRightBorderCommand.prototype.getActualCellBorder = function (table, _grid, _currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return this.getActualRightBorder(tableBordersInfo, table, rowIndex, columnIndex);
    };
    ToggleTableCellsRightBorderCommand.prototype.checkBorderInParticallyTableSelection = function (patternBorder, table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return patternBorder.equals(this.getActualCellBorder(table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo));
    };
    ToggleTableCellsRightBorderCommand.prototype.checkBorderInEntireTable = function (patternBorder, table) {
        return patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderRight().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties));
    };
    ToggleTableCellsRightBorderCommand.prototype.applyBorderToTable = function (subDocument, table, borderInfo) {
        if (!borderInfo) {
            borderInfo = table.properties.borders.rightBorder.clone();
            borderInfo.width = 0;
        }
        else
            borderInfo = borderInfo.clone();
        this.history.addAndRedo(new table_properties_history_items_1.TableBordersHistoryItem(this.modelManipulator, subDocument, table.index, [undefined, borderInfo, undefined, undefined, undefined, undefined], [undefined, true, undefined, undefined, undefined, undefined]));
    };
    ToggleTableCellsRightBorderCommand.prototype.applyBorderToCell = function (subDocument, table, gridCell, rowIndex, cellIndex, borderInfo) {
        if (gridCell.info & TableBorderGridCellInfo.RightOuter) {
            if (!borderInfo) {
                borderInfo = gridCell.cell.properties.borders.rightBorder.clone();
                borderInfo.width = 0;
            }
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [undefined, borderInfo, undefined, undefined, undefined, undefined], [undefined, true, undefined, undefined, undefined, undefined]));
        }
        if (gridCell.info & TableBorderGridCellInfo.RightNeighbour) {
            if (!borderInfo) {
                borderInfo = gridCell.cell.properties.borders.leftBorder.clone();
                borderInfo.width = 0;
            }
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [undefined, undefined, undefined, borderInfo, undefined, undefined], [undefined, undefined, undefined, true, undefined, undefined]));
        }
    };
    return ToggleTableCellsRightBorderCommand;
}(ToggleSingleTableCellsBorderCommand));
exports.ToggleTableCellsRightBorderCommand = ToggleTableCellsRightBorderCommand;
var ToggleTableCellsBottomBorderCommand = (function (_super) {
    tslib_1.__extends(ToggleTableCellsBottomBorderCommand, _super);
    function ToggleTableCellsBottomBorderCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.affectInner = false;
        _this.affectOnStateFlags = TableBorderGridCellInfo.BottomOuter;
        return _this;
    }
    ToggleTableCellsBottomBorderCommand.prototype.getActualCellBorder = function (table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return this.getActualBottomBorder(grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex);
    };
    ToggleTableCellsBottomBorderCommand.prototype.checkBorderInParticallyTableSelection = function (patternBorder, table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return patternBorder.equals(this.getActualCellBorder(table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo));
    };
    ToggleTableCellsBottomBorderCommand.prototype.checkBorderInEntireTable = function (patternBorder, table) {
        return patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderBottom().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties));
    };
    ToggleTableCellsBottomBorderCommand.prototype.applyBorderToTable = function (subDocument, table, borderInfo) {
        if (!borderInfo) {
            borderInfo = table.properties.borders.bottomBorder.clone();
            borderInfo.width = 0;
        }
        else
            borderInfo = borderInfo.clone();
        this.history.addAndRedo(new table_properties_history_items_1.TableBordersHistoryItem(this.modelManipulator, subDocument, table.index, [undefined, undefined, borderInfo, undefined, undefined, undefined], [undefined, undefined, true, undefined, undefined, undefined]));
    };
    ToggleTableCellsBottomBorderCommand.prototype.applyBorderToCell = function (subDocument, table, gridCell, rowIndex, cellIndex, borderInfo) {
        if (gridCell.info & TableBorderGridCellInfo.BottomOuter) {
            if (!borderInfo) {
                borderInfo = gridCell.cell.properties.borders.bottomBorder.clone();
                borderInfo.width = 0;
            }
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [undefined, undefined, borderInfo, undefined, undefined, undefined], [undefined, undefined, true, undefined, undefined, undefined]));
        }
        if (gridCell.info & TableBorderGridCellInfo.BottomNeighbour) {
            if (!borderInfo) {
                borderInfo = gridCell.cell.properties.borders.topBorder.clone();
                borderInfo.width = 0;
            }
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [borderInfo, undefined, undefined, undefined, undefined, undefined], [true, undefined, undefined, undefined, undefined, undefined]));
        }
    };
    return ToggleTableCellsBottomBorderCommand;
}(ToggleSingleTableCellsBorderCommand));
exports.ToggleTableCellsBottomBorderCommand = ToggleTableCellsBottomBorderCommand;
var ToggleTableCellsLeftBorderCommand = (function (_super) {
    tslib_1.__extends(ToggleTableCellsLeftBorderCommand, _super);
    function ToggleTableCellsLeftBorderCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.affectInner = false;
        _this.affectOnStateFlags = TableBorderGridCellInfo.LeftOuter;
        return _this;
    }
    ToggleTableCellsLeftBorderCommand.prototype.getActualCellBorder = function (table, _grid, _currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return this.getActualLeftBorder(tableBordersInfo, table, rowIndex, columnIndex);
    };
    ToggleTableCellsLeftBorderCommand.prototype.checkBorderInParticallyTableSelection = function (patternBorder, table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return patternBorder.equals(this.getActualCellBorder(table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo));
    };
    ToggleTableCellsLeftBorderCommand.prototype.checkBorderInEntireTable = function (patternBorder, table) {
        return patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderLeft().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties));
    };
    ToggleTableCellsLeftBorderCommand.prototype.applyBorderToTable = function (subDocument, table, borderInfo) {
        if (!borderInfo) {
            borderInfo = table.properties.borders.leftBorder.clone();
            borderInfo.width = 0;
        }
        else
            borderInfo = borderInfo.clone();
        this.history.addAndRedo(new table_properties_history_items_1.TableBordersHistoryItem(this.modelManipulator, subDocument, table.index, [undefined, undefined, undefined, borderInfo, undefined, undefined], [undefined, undefined, undefined, true, undefined, undefined]));
    };
    ToggleTableCellsLeftBorderCommand.prototype.applyBorderToCell = function (subDocument, table, gridCell, rowIndex, cellIndex, borderInfo) {
        if (gridCell.info & TableBorderGridCellInfo.LeftOuter) {
            if (!borderInfo) {
                borderInfo = gridCell.cell.properties.borders.leftBorder.clone();
                borderInfo.width = 0;
            }
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [undefined, undefined, undefined, borderInfo, undefined, undefined], [undefined, undefined, undefined, true, undefined, undefined]));
        }
        if (gridCell.info & TableBorderGridCellInfo.LeftNeighbour) {
            if (!borderInfo) {
                borderInfo = gridCell.cell.properties.borders.rightBorder.clone();
                borderInfo.width = 0;
            }
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [undefined, borderInfo, undefined, undefined, undefined, undefined], [undefined, true, undefined, undefined, undefined, undefined]));
        }
    };
    return ToggleTableCellsLeftBorderCommand;
}(ToggleSingleTableCellsBorderCommand));
exports.ToggleTableCellsLeftBorderCommand = ToggleTableCellsLeftBorderCommand;
var ToggleTableCellAllBordersCommand = (function (_super) {
    tslib_1.__extends(ToggleTableCellAllBordersCommand, _super);
    function ToggleTableCellAllBordersCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.affectOnStateFlags = TableBorderGridCellInfo.BottomInner | TableBorderGridCellInfo.BottomOuter | TableBorderGridCellInfo.LeftInner |
            TableBorderGridCellInfo.LeftOuter | TableBorderGridCellInfo.RightInner | TableBorderGridCellInfo.RightOuter |
            TableBorderGridCellInfo.TopInner | TableBorderGridCellInfo.TopOuter;
        return _this;
    }
    ToggleTableCellAllBordersCommand.prototype.checkBorderInParticallyTableSelection = function (patternBorder, table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return patternBorder.equals(this.getActualTopBorder(grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex)) &&
            patternBorder.equals(this.getActualBottomBorder(grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex)) &&
            patternBorder.equals(this.getActualLeftBorder(tableBordersInfo, table, rowIndex, columnIndex)) &&
            patternBorder.equals(this.getActualRightBorder(tableBordersInfo, table, rowIndex, columnIndex));
    };
    ToggleTableCellAllBordersCommand.prototype.checkBorderInEntireTable = function (patternBorder, table) {
        return patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderTop().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties)) &&
            patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderRight().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties)) &&
            patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderBottom().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties)) &&
            patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderLeft().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties)) &&
            patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderHorizontal().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties)) &&
            patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderVertical().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties));
    };
    ToggleTableCellAllBordersCommand.prototype.applyBorderToTable = function (subDocument, table, borderInfo) {
        borderInfo = borderInfo || new border_info_1.BorderInfo();
        this.history.addAndRedo(new table_properties_history_items_1.TableBordersHistoryItem(this.modelManipulator, subDocument, table.index, [
            borderInfo.clone(), borderInfo.clone(), borderInfo.clone(), borderInfo.clone(), borderInfo.clone(), borderInfo.clone()
        ], [true, true, true, true, true, true]));
    };
    ToggleTableCellAllBordersCommand.prototype.applyBorderToCell = function (subDocument, table, gridCell, rowIndex, cellIndex, borderInfo) {
        var topBorder, rightBorder, bottomBorder, leftBorder;
        if (gridCell.info & TableBorderGridCellInfo.TopOuter || gridCell.info & TableBorderGridCellInfo.TopInner || gridCell.info & TableBorderGridCellInfo.BottomNeighbour)
            topBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.RightOuter || gridCell.info & TableBorderGridCellInfo.RightInner || gridCell.info & TableBorderGridCellInfo.LeftNeighbour)
            rightBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.BottomOuter || gridCell.info & TableBorderGridCellInfo.BottomInner || gridCell.info & TableBorderGridCellInfo.TopNeighbour)
            bottomBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.LeftOuter || gridCell.info & TableBorderGridCellInfo.LeftInner || gridCell.info & TableBorderGridCellInfo.RightNeighbour)
            leftBorder = true;
        borderInfo = borderInfo || new border_info_1.BorderInfo();
        if (topBorder || rightBorder || bottomBorder || leftBorder) {
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [topBorder ? borderInfo.clone() : undefined, rightBorder ? borderInfo.clone() : undefined, bottomBorder ? borderInfo.clone() : undefined, leftBorder ? borderInfo.clone() : undefined, undefined, undefined], [topBorder, rightBorder, bottomBorder, leftBorder, undefined, undefined]));
        }
    };
    return ToggleTableCellAllBordersCommand;
}(ToggleTableCellsBorderCommandBase));
exports.ToggleTableCellAllBordersCommand = ToggleTableCellAllBordersCommand;
var ToggleTableCellNoBorderCommand = (function (_super) {
    tslib_1.__extends(ToggleTableCellNoBorderCommand, _super);
    function ToggleTableCellNoBorderCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ToggleTableCellNoBorderCommand.prototype.isChecked = function (_tableInfo) {
        return false;
    };
    ToggleTableCellNoBorderCommand.prototype.applyBorderToTable = function (subDocument, table, _borderInfo) {
        _super.prototype.applyBorderToTable.call(this, subDocument, table, new border_info_1.BorderInfo());
    };
    ToggleTableCellNoBorderCommand.prototype.applyBorderToCell = function (subDocument, table, gridCell, rowIndex, cellIndex, _borderInfo) {
        _super.prototype.applyBorderToCell.call(this, subDocument, table, gridCell, rowIndex, cellIndex, new border_info_1.BorderInfo());
    };
    return ToggleTableCellNoBorderCommand;
}(ToggleTableCellAllBordersCommand));
exports.ToggleTableCellNoBorderCommand = ToggleTableCellNoBorderCommand;
var ToggleTableCellInsideBordersCommand = (function (_super) {
    tslib_1.__extends(ToggleTableCellInsideBordersCommand, _super);
    function ToggleTableCellInsideBordersCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.affectOuter = false;
        _this.affectNeighbours = false;
        _this.affectOnStateFlags = TableBorderGridCellInfo.BottomInner | TableBorderGridCellInfo.LeftInner | TableBorderGridCellInfo.RightInner | TableBorderGridCellInfo.TopInner;
        return _this;
    }
    ToggleTableCellInsideBordersCommand.prototype.checkBorderInParticallyTableSelection = function (patternBorder, table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        if (currentCell.info & TableBorderGridCellInfo.TopInner)
            return patternBorder.equals(this.getActualTopBorder(grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex));
        if (currentCell.info & TableBorderGridCellInfo.RightInner)
            return patternBorder.equals(this.getActualRightBorder(tableBordersInfo, table, rowIndex, columnIndex));
        if (currentCell.info & TableBorderGridCellInfo.BottomInner)
            return patternBorder.equals(this.getActualBottomBorder(grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex));
        if (currentCell.info & TableBorderGridCellInfo.LeftInner)
            return patternBorder.equals(this.getActualLeftBorder(tableBordersInfo, table, rowIndex, columnIndex));
    };
    ToggleTableCellInsideBordersCommand.prototype.checkBorderInEntireTable = function (patternBorder, table) {
        return patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderHorizontal().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties)) &&
            patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderVertical().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties));
    };
    ToggleTableCellInsideBordersCommand.prototype.applyBorderToTable = function (subDocument, table, borderInfo) {
        borderInfo = borderInfo || new border_info_1.BorderInfo();
        this.history.addAndRedo(new table_properties_history_items_1.TableBordersHistoryItem(this.modelManipulator, subDocument, table.index, [
            undefined, undefined, undefined, undefined, borderInfo.clone(), borderInfo.clone()
        ], [undefined, undefined, undefined, undefined, true, true]));
    };
    ToggleTableCellInsideBordersCommand.prototype.applyBorderToCell = function (subDocument, table, gridCell, rowIndex, cellIndex, borderInfo) {
        var topBorder, rightBorder, bottomBorder, leftBorder;
        if (gridCell.info & TableBorderGridCellInfo.TopInner)
            topBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.RightInner)
            rightBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.BottomInner)
            bottomBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.LeftInner)
            leftBorder = true;
        borderInfo = borderInfo || new border_info_1.BorderInfo();
        if (topBorder || rightBorder || bottomBorder || leftBorder) {
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [topBorder ? borderInfo.clone() : undefined, rightBorder ? borderInfo.clone() : undefined, bottomBorder ? borderInfo.clone() : undefined, leftBorder ? borderInfo.clone() : undefined, undefined, undefined], [topBorder, rightBorder, bottomBorder, leftBorder, undefined, undefined]));
        }
    };
    return ToggleTableCellInsideBordersCommand;
}(ToggleTableCellsBorderCommandBase));
exports.ToggleTableCellInsideBordersCommand = ToggleTableCellInsideBordersCommand;
var ToggleTableCellInsideHorizontalBordersCommand = (function (_super) {
    tslib_1.__extends(ToggleTableCellInsideHorizontalBordersCommand, _super);
    function ToggleTableCellInsideHorizontalBordersCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.affectOuter = false;
        _this.affectNeighbours = false;
        _this.affectOnStateFlags = TableBorderGridCellInfo.BottomInner | TableBorderGridCellInfo.TopInner;
        return _this;
    }
    ToggleTableCellInsideHorizontalBordersCommand.prototype.getActualCellBorder = function (table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        var border1, border2;
        if (currentCell.info & TableBorderGridCellInfo.TopInner)
            border1 = this.getActualTopBorder(grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex);
        if (currentCell.info & TableBorderGridCellInfo.BottomInner)
            border2 = this.getActualBottomBorder(grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex);
        if (border1 && border2)
            return border1.equals(border2) ? border1 : null;
        return border1 || border2;
    };
    ToggleTableCellInsideHorizontalBordersCommand.prototype.checkBorderInParticallyTableSelection = function (patternBorder, table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return patternBorder.equals(this.getActualCellBorder(table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo));
    };
    ToggleTableCellInsideHorizontalBordersCommand.prototype.checkBorderInEntireTable = function (patternBorder, table) {
        return patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderHorizontal().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties));
    };
    ToggleTableCellInsideHorizontalBordersCommand.prototype.applyBorderToTable = function (subDocument, table, borderInfo) {
        borderInfo = borderInfo || new border_info_1.BorderInfo();
        this.history.addAndRedo(new table_properties_history_items_1.TableBordersHistoryItem(this.modelManipulator, subDocument, table.index, [
            undefined, undefined, undefined, undefined, borderInfo.clone(), undefined
        ], [undefined, undefined, undefined, undefined, true, undefined]));
    };
    ToggleTableCellInsideHorizontalBordersCommand.prototype.applyBorderToCell = function (subDocument, table, gridCell, rowIndex, cellIndex, borderInfo) {
        var topBorder, bottomBorder;
        if (gridCell.info & TableBorderGridCellInfo.TopInner)
            topBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.BottomInner)
            bottomBorder = true;
        borderInfo = borderInfo || new border_info_1.BorderInfo();
        if (topBorder || bottomBorder) {
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [topBorder ? borderInfo.clone() : undefined, undefined, bottomBorder ? borderInfo.clone() : undefined, undefined, undefined, undefined], [topBorder, undefined, bottomBorder, undefined, undefined, undefined]));
        }
    };
    return ToggleTableCellInsideHorizontalBordersCommand;
}(ToggleSingleTableCellsBorderCommand));
exports.ToggleTableCellInsideHorizontalBordersCommand = ToggleTableCellInsideHorizontalBordersCommand;
var ToggleTableCellInsideVerticalBordersCommand = (function (_super) {
    tslib_1.__extends(ToggleTableCellInsideVerticalBordersCommand, _super);
    function ToggleTableCellInsideVerticalBordersCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.affectOuter = false;
        _this.affectNeighbours = false;
        _this.affectOnStateFlags = TableBorderGridCellInfo.LeftInner | TableBorderGridCellInfo.RightInner;
        return _this;
    }
    ToggleTableCellInsideVerticalBordersCommand.prototype.getActualCellBorder = function (table, _grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        var border1, border2;
        if (currentCell.info & TableBorderGridCellInfo.LeftInner)
            border1 = this.getActualLeftBorder(tableBordersInfo, table, rowIndex, columnIndex);
        if (currentCell.info & TableBorderGridCellInfo.RightInner)
            border2 = this.getActualRightBorder(tableBordersInfo, table, rowIndex, columnIndex);
        if (border1 && border2)
            return border1.equals(border2) ? border1 : null;
        return border1 || border2;
    };
    ToggleTableCellInsideVerticalBordersCommand.prototype.checkBorderInParticallyTableSelection = function (patternBorder, table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        return patternBorder.equals(this.getActualCellBorder(table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo));
    };
    ToggleTableCellInsideVerticalBordersCommand.prototype.checkBorderInEntireTable = function (patternBorder, table) {
        return patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderVertical().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties));
    };
    ToggleTableCellInsideVerticalBordersCommand.prototype.applyBorderToTable = function (subDocument, table, borderInfo) {
        borderInfo = borderInfo || new border_info_1.BorderInfo();
        this.history.addAndRedo(new table_properties_history_items_1.TableBordersHistoryItem(this.modelManipulator, subDocument, table.index, [
            undefined, undefined, undefined, undefined, undefined, borderInfo.clone()
        ], [undefined, undefined, undefined, undefined, undefined, true]));
    };
    ToggleTableCellInsideVerticalBordersCommand.prototype.applyBorderToCell = function (subDocument, table, gridCell, rowIndex, cellIndex, borderInfo) {
        var leftBorder, rightBorder;
        if (gridCell.info & TableBorderGridCellInfo.LeftInner)
            leftBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.RightInner)
            rightBorder = true;
        borderInfo = borderInfo || new border_info_1.BorderInfo();
        if (rightBorder || leftBorder) {
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [undefined, rightBorder ? borderInfo.clone() : undefined, undefined, leftBorder ? borderInfo.clone() : undefined, undefined, undefined], [undefined, rightBorder, undefined, leftBorder, undefined, undefined]));
        }
    };
    return ToggleTableCellInsideVerticalBordersCommand;
}(ToggleSingleTableCellsBorderCommand));
exports.ToggleTableCellInsideVerticalBordersCommand = ToggleTableCellInsideVerticalBordersCommand;
var ToggleTableCellOutsideBordersCommand = (function (_super) {
    tslib_1.__extends(ToggleTableCellOutsideBordersCommand, _super);
    function ToggleTableCellOutsideBordersCommand() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.affectInner = false;
        _this.affectOnStateFlags = TableBorderGridCellInfo.LeftOuter | TableBorderGridCellInfo.RightOuter | TableBorderGridCellInfo.TopOuter | TableBorderGridCellInfo.BottomOuter;
        return _this;
    }
    ToggleTableCellOutsideBordersCommand.prototype.checkBorderInParticallyTableSelection = function (patternBorder, table, grid, currentCell, rowIndex, columnIndex, tableBordersInfo) {
        if (currentCell.info & TableBorderGridCellInfo.TopOuter && !patternBorder.equals(this.getActualTopBorder(grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex)))
            return false;
        if (currentCell.info & TableBorderGridCellInfo.RightOuter && !patternBorder.equals(this.getActualRightBorder(tableBordersInfo, table, rowIndex, columnIndex)))
            return false;
        if (currentCell.info & TableBorderGridCellInfo.BottomOuter && !patternBorder.equals(this.getActualBottomBorder(grid, currentCell, tableBordersInfo, table, rowIndex, columnIndex)))
            return false;
        if (currentCell.info & TableBorderGridCellInfo.LeftOuter && !patternBorder.equals(this.getActualLeftBorder(tableBordersInfo, table, rowIndex, columnIndex)))
            return false;
        return true;
    };
    ToggleTableCellOutsideBordersCommand.prototype.checkBorderInEntireTable = function (patternBorder, table) {
        return patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderTop().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties)) &&
            patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderRight().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties)) &&
            patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderBottom().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties)) &&
            patternBorder.equals(new table_properties_merger_1.TablePropertiesMergerBorderLeft().getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, this.control.modelManager.model.defaultTableProperties));
    };
    ToggleTableCellOutsideBordersCommand.prototype.applyBorderToTable = function (subDocument, table, borderInfo) {
        borderInfo = borderInfo || new border_info_1.BorderInfo();
        this.history.addAndRedo(new table_properties_history_items_1.TableBordersHistoryItem(this.modelManipulator, subDocument, table.index, [
            borderInfo.clone(), borderInfo.clone(), borderInfo.clone(), borderInfo.clone(), undefined, undefined
        ], [true, true, true, true, undefined, undefined]));
    };
    ToggleTableCellOutsideBordersCommand.prototype.applyBorderToCell = function (subDocument, table, gridCell, rowIndex, cellIndex, borderInfo) {
        var topBorder, rightBorder, bottomBorder, leftBorder;
        if (gridCell.info & TableBorderGridCellInfo.TopOuter || gridCell.info & TableBorderGridCellInfo.BottomNeighbour)
            topBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.RightOuter || gridCell.info & TableBorderGridCellInfo.LeftNeighbour)
            rightBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.BottomOuter || gridCell.info & TableBorderGridCellInfo.TopNeighbour)
            bottomBorder = true;
        if (gridCell.info & TableBorderGridCellInfo.LeftOuter || gridCell.info & TableBorderGridCellInfo.RightNeighbour)
            leftBorder = true;
        borderInfo = borderInfo || new border_info_1.BorderInfo();
        if (topBorder || rightBorder || bottomBorder || leftBorder) {
            this.history.addAndRedo(new table_cell_properties_history_items_1.TableCellBordersHistoryItem(this.modelManipulator, subDocument, table.index, rowIndex, cellIndex, [topBorder ? borderInfo.clone() : undefined, rightBorder ? borderInfo.clone() : undefined, bottomBorder ? borderInfo.clone() : undefined, leftBorder ? borderInfo.clone() : undefined, undefined, undefined], [topBorder, rightBorder, bottomBorder, leftBorder, undefined, undefined]));
        }
    };
    return ToggleTableCellOutsideBordersCommand;
}(ToggleTableCellsBorderCommandBase));
exports.ToggleTableCellOutsideBordersCommand = ToggleTableCellOutsideBordersCommand;
var TableBorderGridCellInfo;
(function (TableBorderGridCellInfo) {
    TableBorderGridCellInfo[TableBorderGridCellInfo["None"] = 0] = "None";
    TableBorderGridCellInfo[TableBorderGridCellInfo["LeftOuter"] = 1] = "LeftOuter";
    TableBorderGridCellInfo[TableBorderGridCellInfo["RightOuter"] = 2] = "RightOuter";
    TableBorderGridCellInfo[TableBorderGridCellInfo["BottomOuter"] = 4] = "BottomOuter";
    TableBorderGridCellInfo[TableBorderGridCellInfo["TopOuter"] = 8] = "TopOuter";
    TableBorderGridCellInfo[TableBorderGridCellInfo["RightNeighbour"] = 16] = "RightNeighbour";
    TableBorderGridCellInfo[TableBorderGridCellInfo["TopNeighbour"] = 32] = "TopNeighbour";
    TableBorderGridCellInfo[TableBorderGridCellInfo["LeftNeighbour"] = 64] = "LeftNeighbour";
    TableBorderGridCellInfo[TableBorderGridCellInfo["BottomNeighbour"] = 128] = "BottomNeighbour";
    TableBorderGridCellInfo[TableBorderGridCellInfo["RightInner"] = 256] = "RightInner";
    TableBorderGridCellInfo[TableBorderGridCellInfo["TopInner"] = 512] = "TopInner";
    TableBorderGridCellInfo[TableBorderGridCellInfo["LeftInner"] = 1024] = "LeftInner";
    TableBorderGridCellInfo[TableBorderGridCellInfo["BottomInner"] = 2048] = "BottomInner";
    TableBorderGridCellInfo[TableBorderGridCellInfo["LeftTableOuter"] = 4096] = "LeftTableOuter";
    TableBorderGridCellInfo[TableBorderGridCellInfo["RightTableOuter"] = 8192] = "RightTableOuter";
    TableBorderGridCellInfo[TableBorderGridCellInfo["TopTableOuter"] = 16384] = "TopTableOuter";
    TableBorderGridCellInfo[TableBorderGridCellInfo["BottomTableOuter"] = 32768] = "BottomTableOuter";
    TableBorderGridCellInfo[TableBorderGridCellInfo["All"] = -1] = "All";
})(TableBorderGridCellInfo = exports.TableBorderGridCellInfo || (exports.TableBorderGridCellInfo = {}));
