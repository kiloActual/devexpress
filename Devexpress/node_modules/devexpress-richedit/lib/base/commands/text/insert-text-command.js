"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var insert_text_history_item_1 = require("../../../core/model/history/items/insert-text-history-item");
var insert_text_manipulator_params_1 = require("../../../core/model/manipulators/text-manipulator/insert-text-manipulator-params");
var run_type_1 = require("../../../core/model/runs/run-type");
var selection_history_item_1 = require("../../model/history/selection/selection-history-item");
var model_states_1 = require("../../scroll/model-states");
var command_base_1 = require("../command-base");
var command_states_1 = require("../command-states");
var InsertTextCommand = (function (_super) {
    tslib_1.__extends(InsertTextCommand, _super);
    function InsertTextCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InsertTextCommand.prototype.getState = function () {
        return new command_states_1.SimpleCommandState(this.isEnabled());
    };
    InsertTextCommand.prototype.DEPRECATEDCorrectlMainCommandOptions = function (options) {
        options.intervalsInfo.intervals = [this.selection.lastSelectedInterval.clone()];
    };
    InsertTextCommand.prototype.executeCore = function (_state, options) {
        if (options.param.length === 0)
            return false;
        var interval = options.intervalsInfo.interval;
        if (interval.length > 0 &&
            options.intervalsInfo.subDocInterval.subDocument.getParagraphByPosition(interval.end - 1).getEndPosition() == interval.end)
            options.intervalsInfo.interval.length -= 1;
        this.removedInterval = !!interval.length;
        var canMergeWithPreviousCommand = this.control.commandManager.assertLastExecutedCommandsChain(true, InsertTextCommand);
        if (canMergeWithPreviousCommand && options.intervalsInfo.isCollapsed &&
            this.correctPrevHistoryRun(new insert_text_manipulator_params_1.InsertTextManipulatorParams(options.intervalsInfo.subDocPosition, this.control.inputPosition.charPropsBundle, run_type_1.RunType.TextRun, options.param))) {
        }
        else
            this.insertTextWithSelection(options.intervalsInfo.subDocInterval, options.param);
        this.control.commandManager.lastTextInsertDate = new Date();
        if (!interval.length)
            this.control.inputPositionModelChangesListener.resetOccurredEvents();
        return true;
    };
    InsertTextCommand.prototype.correctPrevHistoryRun = function (params) {
        var currDate = new Date();
        if (currDate.getTime() - this.control.commandManager.lastTextInsertDate.getTime() < 2.7 * 1000) {
            var insertTextHistoryInfo = this.modelManipulator.text.getLastModifiableHistoryItemNode(function (hi) { return hi instanceof insert_text_history_item_1.InsertTextHistoryItem; });
            var selectionHistoryItem = this.modelManipulator.text.getLastModifiableHistoryItemNode(function (hi) { return hi instanceof selection_history_item_1.SelectionHistoryItem; });
            if (insertTextHistoryInfo && selectionHistoryItem) {
                var oldParams = insertTextHistoryInfo.item.params;
                if (oldParams.subDocPos.subDocument.id == params.subDocPos.subDocument.id &&
                    oldParams.subDocPos.position + oldParams.text.length == params.subDocPos.position &&
                    oldParams.charPropsBundle.style.equalsByName(params.charPropsBundle.style) &&
                    oldParams.charPropsBundle.props.equals(params.charPropsBundle.props) &&
                    !selectionHistoryItem.item.newState.intervalsInfo.multiselection &&
                    selectionHistoryItem.item.newState.intervalsInfo.intervals[0].length == 0 &&
                    selectionHistoryItem.item.newState.intervalsInfo.interval.start == params.subDocPos.position) {
                    this.modelManipulator.text.insertTextInner(params);
                    selectionHistoryItem.item.newState.intervalsInfo.interval.start += params.text.length;
                    oldParams.text += params.text;
                    insertTextHistoryInfo.root.item.uniqueId = -1;
                    var newPos_1 = selectionHistoryItem.item.newState.intervalsInfo.interval.start;
                    this.selection.changeState(function (newState) { return newState.setPosition(newPos_1); });
                    this.selection.scrollManager.setScroll(new model_states_1.ScrollState()
                        .byModelPosition(this.selection).setModelPosition(newPos_1).useStdRelativePosition().useStdOffset());
                    return true;
                }
            }
        }
        return false;
    };
    InsertTextCommand.prototype.lockBarHolderUpdate = function (prevModifiedState) {
        return !this.removedInterval && prevModifiedState === this.control.getModifiedState();
    };
    InsertTextCommand.prototype.lockInputPositionUpdating = function (prevModifiedState) {
        return !this.removedInterval && prevModifiedState === this.control.getModifiedState();
    };
    return InsertTextCommand;
}(command_base_1.CommandBase));
exports.InsertTextCommand = InsertTextCommand;
