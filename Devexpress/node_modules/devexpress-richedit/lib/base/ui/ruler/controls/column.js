"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var min_max_1 = require("@devexpress/utils/lib/class/min-max");
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var dom_1 = require("@devexpress/utils/lib/utils/dom");
var list_1 = require("@devexpress/utils/lib/utils/list");
var document_renderer_1 = require("../../../canvas/renderes/common/document-renderer");
var client_command_1 = require("../../../commands/client-command");
var settings_1 = require("../settings");
var owner_1 = require("./owner");
var vertical_line_1 = require("./vertical-line");
var MinColumnWidth = unit_converter_1.UnitConverter.centimeterToPixel(1.5);
var MinColumnSpace = unit_converter_1.UnitConverter.centimeterToPixel(0.25);
var COLUMN_HANDLE_CLASS_NAME = settings_1.RICH_EDIT_CLASS_NAME_PREFIX + "columnHandle";
var COLUMN_LEFT_PART_HANDLE_CLASS_NAME = settings_1.RICH_EDIT_CLASS_NAME_PREFIX + "columnHandleLeftPart";
var COLUMN_RIGHT_PART_HANDLE_CLASS_NAME = settings_1.RICH_EDIT_CLASS_NAME_PREFIX + "columnHandleRightPart";
var ColumnSectionProperties = (function () {
    function ColumnSectionProperties(width, space) {
        this.width = width;
        this.space = space;
    }
    ColumnSectionProperties.prototype.clone = function () {
        return new ColumnSectionProperties(this.width, this.space);
    };
    ColumnSectionProperties.prototype.equals = function (obj) {
        return this.width == obj.width &&
            this.space == obj.space;
    };
    return ColumnSectionProperties;
}());
var ColumnAction;
(function (ColumnAction) {
    ColumnAction[ColumnAction["None"] = 0] = "None";
    ColumnAction[ColumnAction["ColumnMove"] = 1] = "ColumnMove";
    ColumnAction[ColumnAction["ColumnSpace"] = 2] = "ColumnSpace";
    ColumnAction[ColumnAction["ColumnWidth"] = 3] = "ColumnWidth";
})(ColumnAction = exports.ColumnAction || (exports.ColumnAction = {}));
var RulerColumnModelState = (function () {
    function RulerColumnModelState(leftPos, width, space) {
        this.leftPos = leftPos;
        this.width = width;
        this.space = space;
    }
    Object.defineProperty(RulerColumnModelState.prototype, "rightPos", {
        get: function () { return this.leftPos + this.width; },
        enumerable: true,
        configurable: true
    });
    RulerColumnModelState.prototype.clone = function () {
        return new RulerColumnModelState(this.leftPos, this.width, this.space);
    };
    RulerColumnModelState.prototype.equals = function (obj) {
        return this.leftPos == obj.leftPos &&
            this.width == obj.width &&
            this.space == obj.space;
    };
    return RulerColumnModelState;
}());
exports.RulerColumnModelState = RulerColumnModelState;
var RulerColumnsModelState = (function () {
    function RulerColumnsModelState(columns, equalWidth, columnActiveIndex, enabled) {
        this.columns = columns;
        this.equalWidth = equalWidth;
        this.columnActiveIndex = columnActiveIndex;
        this.enabled = enabled;
    }
    Object.defineProperty(RulerColumnsModelState.prototype, "activeColumn", {
        get: function () { return this.columns[this.columnActiveIndex]; },
        enumerable: true,
        configurable: true
    });
    RulerColumnsModelState.prototype.clone = function () {
        return new RulerColumnsModelState(list_1.ListUtils.deepCopy(this.columns), this.equalWidth, this.columnActiveIndex, this.enabled);
    };
    return RulerColumnsModelState;
}());
exports.RulerColumnsModelState = RulerColumnsModelState;
var RulerColumnsControl = (function (_super) {
    tslib_1.__extends(RulerColumnsControl, _super);
    function RulerColumnsControl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RulerColumnsControl.prototype.getModelState = function () {
        var state = this.modelData.commandManager.getCommand(client_command_1.RichEditClientCommand.RulerSectionColumnsSettings).getState();
        var prevColumnLeftPos = 0;
        var modelColumns = list_1.ListUtils.map(state.value, function (column) {
            var result = new RulerColumnModelState(prevColumnLeftPos, column.width, column.space);
            prevColumnLeftPos = result.rightPos + result.space;
            return result;
        });
        return new RulerColumnsModelState(modelColumns, state.equalWidth, state.activeIndex, state.enabled);
    };
    RulerColumnsControl.prototype.updateView = function () {
        if (this.controls.tables.currModelState.columnSeparators.hasItems || !this.modelData.selection.activeSubDocument.isMain()) {
            this.viewState = [];
            this.setCount(0);
        }
        else {
            var offset_1 = this.controls.leftMargin.currModelState.modelValue;
            this.viewState = list_1.ListUtils.map(this.currModelState.columns, function (column) {
                var result = column.clone();
                result.leftPos += offset_1;
                return result;
            }, 0, this.currModelState.columns.length - 1);
            this.setCount(this.viewState.length);
            list_1.ListUtils.forEach2(this.subControls, this.viewState, function (control, viewState) { return control.setValue(viewState); });
        }
    };
    RulerColumnsControl.prototype.createSubControl = function () {
        return new RulerColumnState(this.controls);
    };
    RulerColumnsControl.prototype.marginsChanged = function (diff) {
        if (this.prevModelState.equalWidth) {
            var colCount = this.prevModelState.columns.length;
            var columnWidthDiff_1 = diff / colCount;
            var prevColumnLeftPos_1 = 0;
            this.currModelState.columns = this.prevModelState.columns.map(function (oldColumn) {
                var result = new RulerColumnModelState(prevColumnLeftPos_1, oldColumn.width - columnWidthDiff_1, oldColumn.space);
                prevColumnLeftPos_1 = result.rightPos + result.space;
                return result;
            });
        }
    };
    RulerColumnsControl.prototype.onMouseDown = function (source, _evt) {
        var _this = this;
        if (!this.currModelState.enabled)
            return false;
        if (list_1.ListUtils.unsafeAnyOf(this.subControls, function (subControl, index) {
            _this.action = subControl.getAction(source);
            if (_this.action != ColumnAction.None) {
                _this.handleControlIndex = index;
                return true;
            }
            return false;
        })) {
            this.controls.lineControl.show(vertical_line_1.RulerLineDisplayType.Normal);
            this.activeSubControl.lineControlSetPosition();
            this.activeSubControl.showShadow();
            return true;
        }
        return false;
    };
    RulerColumnsControl.prototype.onMouseUp = function () {
        this.modelData.commandManager.getCommand(client_command_1.RichEditClientCommand.RulerSectionColumnsSettings)
            .execute(this.modelData.commandManager.isPublicApiCall, this.currModelState.columns.map(function (col) { return new ColumnSectionProperties(col.width, col.space); }));
        this.finishHandle();
    };
    RulerColumnsControl.prototype.calculateNewModelState = function (distance) {
        switch (this.action) {
            case ColumnAction.ColumnMove:
                this.calculateNewModelStateColumnMove(distance);
                return;
            case ColumnAction.ColumnSpace:
                this.calculateNewModelStateColumnSpace(distance, false);
                return;
            case ColumnAction.ColumnWidth:
                this.calculateNewModelStateColumnSpace(distance, true);
                return;
        }
    };
    RulerColumnsControl.prototype.calculateNewModelStateColumnMove = function (distance) {
        var leftMargin = this.controls.leftMargin.prevModelState.modelValue;
        var column = this.prevModelState.columns[this.handleControlIndex];
        var initialPos = leftMargin + column.rightPos;
        var newPos = this.controls.chooseClosestAnchorPosition(initialPos + distance, [initialPos], new min_max_1.MinMaxNumber(leftMargin + column.leftPos + MinColumnWidth, leftMargin + this.prevModelState.columns[this.handleControlIndex + 1].rightPos - MinColumnWidth - column.space));
        var correctedDistance = newPos - initialPos;
        var currColumn = this.currModelState.columns[this.handleControlIndex] = this.prevModelState.columns[this.handleControlIndex].clone();
        var nextColumn = this.currModelState.columns[this.handleControlIndex + 1] = this.prevModelState.columns[this.handleControlIndex + 1].clone();
        currColumn.width += correctedDistance;
        nextColumn.leftPos += correctedDistance;
        nextColumn.width -= correctedDistance;
    };
    RulerColumnsControl.prototype.calculateNewModelStateColumnSpace = function (distance, leftEdge) {
        if (this.prevModelState.equalWidth) {
            var columnCount_1 = this.currModelState.columns.length;
            var leftMargin = this.controls.leftMargin.prevModelState.modelValue;
            var column = this.prevModelState.columns[this.handleControlIndex];
            var maxColumnSpace = (list_1.ListUtils.last(this.prevModelState.columns).rightPos - MinColumnWidth * columnCount_1) / (columnCount_1 - 1);
            var maxColumnWidth = (list_1.ListUtils.last(this.prevModelState.columns).rightPos - MinColumnSpace * (columnCount_1 - 1)) / columnCount_1;
            var bounds = leftEdge ?
                new min_max_1.MinMaxNumber(leftMargin + MinColumnWidth * (this.handleControlIndex + 1) + maxColumnSpace * this.handleControlIndex, leftMargin + maxColumnWidth * (this.handleControlIndex + 1) + MinColumnSpace * this.handleControlIndex) :
                new min_max_1.MinMaxNumber(leftMargin + (maxColumnWidth + MinColumnSpace) * (this.handleControlIndex + 1), leftMargin + (MinColumnWidth + maxColumnSpace) * (this.handleControlIndex + 1));
            var initialPos = leftMargin + column.rightPos + (leftEdge ? 0 : column.space);
            var newPos = this.controls.chooseClosestAnchorPosition(initialPos + distance, [initialPos], bounds);
            var correctedDistance = newPos - initialPos;
            var diffS_1 = leftEdge ?
                -correctedDistance * columnCount_1 / (columnCount_1 - (this.handleControlIndex + 1)) :
                correctedDistance * columnCount_1 / (this.handleControlIndex + 1);
            var diffW_1 = leftEdge ?
                diffS_1 - diffS_1 / columnCount_1 :
                diffS_1 - diffS_1 / columnCount_1;
            this.currModelState = this.prevModelState.clone();
            var prevColumnLeftPos_2 = 0;
            list_1.ListUtils.forEach(this.currModelState.columns, function (col, index) {
                col.leftPos = prevColumnLeftPos_2;
                col.space += index == columnCount_1 - 1 ? 0 : diffS_1;
                col.width -= diffW_1;
                prevColumnLeftPos_2 = col.rightPos + col.space;
            });
        }
        else {
            var leftMargin = this.controls.leftMargin.prevModelState.modelValue;
            var column = this.prevModelState.columns[this.handleControlIndex];
            var bounds = leftEdge ?
                new min_max_1.MinMaxNumber(leftMargin + column.leftPos + MinColumnWidth, leftMargin + this.prevModelState.columns[this.handleControlIndex + 1].leftPos - MinColumnSpace) :
                new min_max_1.MinMaxNumber(leftMargin + column.rightPos + MinColumnSpace, leftMargin + this.prevModelState.columns[this.handleControlIndex + 1].rightPos - MinColumnWidth);
            var initialPos = leftMargin + column.rightPos + (leftEdge ? 0 : column.space);
            var newPos = this.controls.chooseClosestAnchorPosition(initialPos + distance, [initialPos], bounds);
            var correctedDistance = newPos - initialPos;
            var currColumn = this.currModelState.columns[this.handleControlIndex] = this.prevModelState.columns[this.handleControlIndex].clone();
            var nextColumn = this.currModelState.columns[this.handleControlIndex + 1] = this.prevModelState.columns[this.handleControlIndex + 1].clone();
            if (leftEdge) {
                currColumn.width += correctedDistance;
                currColumn.space -= correctedDistance;
            }
            else {
                currColumn.space += correctedDistance;
                nextColumn.leftPos += correctedDistance;
                nextColumn.width -= correctedDistance;
            }
        }
    };
    return RulerColumnsControl;
}(owner_1.RulerMultiControl));
exports.RulerColumnsControl = RulerColumnsControl;
var RulerColumnState = (function () {
    function RulerColumnState(controls) {
        this.controls = controls;
        this.rootElement = document_renderer_1.DocumentRenderer.renderContainer(COLUMN_HANDLE_CLASS_NAME);
        this.leftElement = document_renderer_1.DocumentRenderer.renderContainer(COLUMN_LEFT_PART_HANDLE_CLASS_NAME);
        this.rightElement = document_renderer_1.DocumentRenderer.renderContainer(COLUMN_RIGHT_PART_HANDLE_CLASS_NAME);
        this.rootElement.appendChild(this.leftElement);
        this.rootElement.appendChild(this.rightElement);
        controls.ruler.rootElement.appendChild(this.rootElement);
    }
    RulerColumnState.prototype.dispose = function () {
        dom_1.DomUtils.hideNode(this.rootElement);
        this.rootElement = null;
    };
    RulerColumnState.prototype.showShadow = function () { };
    RulerColumnState.prototype.hideShadow = function () { };
    RulerColumnState.prototype.lineControlSetPosition = function () {
        var pos;
        switch (this.controls.columns.action) {
            case ColumnAction.ColumnMove:
                pos = this.viewState.rightPos + this.viewState.space / 2;
                break;
            case ColumnAction.ColumnSpace:
                pos = this.viewState.rightPos + this.viewState.space;
                break;
            case ColumnAction.ColumnWidth:
                pos = this.viewState.rightPos;
                break;
        }
        this.controls.lineControl.setPosition(pos, vertical_line_1.SnapTo.LeftSide);
    };
    RulerColumnState.prototype.setValue = function (viewState) {
        if (!this.viewState || !this.viewState.equals(viewState)) {
            this.viewState = viewState.clone();
            this.rootElement.style.left = settings_1.RULLER_NUMBER_CORRECTION + viewState.rightPos + "px";
            this.rootElement.style.width = viewState.space + "px";
        }
    };
    RulerColumnState.prototype.getAction = function (source) {
        if (source == this.rightElement)
            return ColumnAction.ColumnSpace;
        if (source == this.leftElement)
            return ColumnAction.ColumnWidth;
        if (source == this.rootElement && !this.controls.columns.currModelState.equalWidth)
            return ColumnAction.ColumnMove;
        return ColumnAction.None;
    };
    return RulerColumnState;
}());
