"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var layout_box_iterator_main_sub_document_1 = require("../../../core/layout-engine/layout-box-iterator/layout-box-iterator-main-sub-document");
var layout_position_creator_1 = require("../../../core/layout-engine/layout-position-creator");
var document_layout_details_level_1 = require("../../../core/layout/document-layout-details-level");
var layout_page_1 = require("../../../core/layout/main-structures/layout-page");
var enums_1 = require("../../../core/model/character/enums");
var anchor_info_1 = require("../../../core/model/floating-objects/anchor-info");
var enums_2 = require("../../../core/model/floating-objects/enums");
var run_type_1 = require("../../../core/model/runs/run-type");
var table_base_structures_1 = require("../../../core/model/tables/secondary-structures/table-base-structures");
var log_1 = require("../../../core/rich-utils/debug/logger/base-logger/log");
var log_list_helper_1 = require("../../../core/rich-utils/debug/logger/base-logger/log-list-helper");
var log_obj_to_str_1 = require("../../../core/rich-utils/debug/logger/base-logger/log-obj-to-str");
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var enum_1 = require("@devexpress/utils/lib/utils/enum");
var list_1 = require("@devexpress/utils/lib/utils/list");
var number_1 = require("@devexpress/utils/lib/utils/map/number");
var string_1 = require("@devexpress/utils/lib/utils/string");
var model_scroll_manager_1 = require("../../scroll/model-scroll-manager");
var TEST_CLASS = (function () {
    function TEST_CLASS() {
    }
    TEST_CLASS.pagesIntervals = function (control) {
        console.log(list_1.ListUtils.map(control.layout.pages, TEST_CLASS.pageIntervals).join("\n"));
    };
    TEST_CLASS.pageIntervals = function (page) {
        return "\tPage[" + page.index + "]Intervals: " +
            log_list_helper_1.LogListHelper.level_1(log_obj_to_str_1.LogObjToStr.fixedInterval, page.getContentIntervals(), "\t\t", "\t")();
    };
    TEST_CLASS.getLayoutPosition = function (control, pos) {
        var subDocument = control.selection.activeSubDocument;
        var selection = control.selection;
        return (subDocument.isMain()
            ? new layout_position_creator_1.LayoutPositionMainSubDocumentCreator(control.layout, subDocument, pos, document_layout_details_level_1.DocumentLayoutDetailsLevel.Character)
            : new layout_position_creator_1.LayoutPositionOtherSubDocumentCreator(control.layout, subDocument, pos, selection.pageIndex, document_layout_details_level_1.DocumentLayoutDetailsLevel.Character))
            .create(new layout_position_creator_1.LayoutPositionCreatorConflictFlags().setDefault(selection.endOfLine), new layout_position_creator_1.LayoutPositionCreatorConflictFlags().setDefault(false));
    };
    TEST_CLASS.recalcPageIntervals = function (control) {
        for (var _i = 0, _a = control.layout.pages; _i < _a.length; _i++) {
            var page = _a[_i];
            page.flags.set(layout_page_1.LayoutPageFlags.IsIntervalsCorrect, false);
            page.calculateContentIntervals(control.layout.anchorObjectsPositionInfo, false);
            page.getContentIntervals();
        }
    };
    TEST_CLASS.clearAllRunMergedProperties = function (control) {
        list_1.ListUtils.forEach(control.selection.activeSubDocument.chunks, function (chunk) { return list_1.ListUtils.forEach(chunk.textRuns, function (run) { return run.resetCharacterMergedProperties(); }); });
        control.layoutFormatterManager.invalidator.onIntervalChanged(control.selection.activeSubDocument.id, new fixed_1.FixedInterval(0, control.selection.activeSubDocument.getDocumentEndPosition()));
        while (!control.layout.isFullyFormatted)
            control.layoutFormatterManager.forceFormatPage(control.layout.validPageCount);
    };
    TEST_CLASS.checkLayoutPage = function (layout, page) {
        var pagePos = page.getPosition();
        var collectedIntervals = [];
        var pageAreas = page.mainSubDocumentPageAreas;
        if (pageAreas[0].pageOffset != 0)
            console.log(page.index, page, "First page area offset != 0");
        for (var pageAreaIndex = 0, pageArea = void 0; pageArea = pageAreas[pageAreaIndex]; pageAreaIndex++) {
            var pageAreaPos = pagePos + pageArea.pageOffset;
            var columns = pageArea.columns;
            if (columns[0].pageAreaOffset != 0)
                console.log(page.index, page, pageAreaIndex, pageArea, "First column offset != 0");
            for (var columnIndex = 0, column = void 0; column = columns[columnIndex]; columnIndex++) {
                var columnPos = pageAreaPos + column.pageAreaOffset;
                var rows = column.rows;
                if (rows[0].columnOffset != 0)
                    console.log(page.index, page, pageAreaIndex, pageArea, columnIndex, column, "First row offset != 0");
                for (var rowIndex = 0, row = void 0; row = rows[rowIndex]; rowIndex++) {
                    var rowPos = columnPos + row.columnOffset;
                    collectedIntervals.push(new fixed_1.FixedInterval(rowPos, row.getLastBoxEndPositionInRow()));
                    var boxes = row.boxes;
                    if (boxes[0].rowOffset != 0)
                        console.log(page.index, page, pageAreaIndex, pageArea, columnIndex, column, row, rowIndex, "First box offset != 0");
                }
            }
        }
        var lastEndPos = 0;
        for (var _i = 0, collectedIntervals_1 = collectedIntervals; _i < collectedIntervals_1.length; _i++) {
            var interval = collectedIntervals_1[_i];
            if (interval.start < lastEndPos)
                console.log("Intervals of row not sorted", page, collectedIntervals);
            lastEndPos = interval.end;
        }
        var mergedIntervals = algorithms_1.IntervalAlgorithms.getMergedIntervals(collectedIntervals, true);
        var pageIntervalIndex = 0;
        page.calculateContentIntervals(layout.anchorObjectsPositionInfo, false);
        var pageIntervals = page.getContentIntervals();
        var currPageInterval = pageIntervals[pageIntervalIndex];
        for (var mergedIntervalIndex = 0, mgInt = void 0; mgInt = mergedIntervals[mergedIntervalIndex]; mergedIntervalIndex++) {
            if (!currPageInterval.containsInterval(mgInt)) {
                pageIntervalIndex++;
                currPageInterval = pageIntervals[pageIntervalIndex];
                if (!currPageInterval || !currPageInterval.containsInterval(mgInt))
                    console.log("current page contentIntervals not consider some row intervals", [mgInt.start, mgInt.end], mergedIntervals, pageIntervals, collectedIntervals, page);
            }
        }
    };
    TEST_CLASS.checkLayout = function (_model, layout) {
        var pages = layout.pages;
        for (var pageIndex = 0, page = void 0; page = pages[pageIndex]; pageIndex++) {
            TEST_CLASS.checkLayoutPage(layout, page);
        }
    };
    TEST_CLASS.checkModel = function (model) {
        number_1.NumberMapUtils.forEach(model.subDocuments, function (subDocument, sid) {
            var prevParagraphEnd = 0;
            for (var pIndex = 0, paragraph = void 0; paragraph = subDocument.paragraphs[pIndex]; pIndex++) {
                if (paragraph.startLogPosition.value !== prevParagraphEnd) {
                    console.log("paragraphs[" + pIndex + "].length !== prevParagraphEnd");
                }
                prevParagraphEnd = paragraph.getEndPosition();
                if (paragraph.length === 0) {
                    console.log("paragraphs[" + pIndex + "].length == 0");
                    continue;
                }
                var endParRun = subDocument.getRunByPosition(paragraph.getEndPosition() - 1);
                if (endParRun.getType() !== run_type_1.RunType.ParagraphRun) {
                    console.log("The last run of paragraph " + pIndex + " is not ParagraphRun");
                    continue;
                }
            }
            if (subDocument.paragraphs[subDocument.paragraphs.length - 1].getEndPosition() !== subDocument.getLastChunk().getEndPosition())
                console.log("paragraphs.length !== chunks.length in sid=" + sid);
            var prevTableStartPosition = -1;
            for (var tIndex = 0, table = void 0; table = subDocument.tables[tIndex]; tIndex++) {
                if (table.getStartPosition() < prevTableStartPosition)
                    console.log("tables are not sorted. tables[" + tIndex + "].getStartPosition() < prevTableStartPosition in sid=" + sid);
                prevTableStartPosition = table.getStartPosition();
                if (table.index !== tIndex)
                    console.log("subDocument.tables[" + tIndex + "] !== subDocument.tables[" + tIndex + "].index");
                if (table.nestedLevel == 0 && table.parentCell)
                    console.log("subDocument.tables[" + tIndex + "].parentCell exists but nestedLevel===0");
                else if (table.nestedLevel > 0 && !table.parentCell)
                    console.log("subDocument.tables[" + tIndex + "].parentCell doesn't exist but nestedLevel>0");
                else if (table.parentCell && table.parentCell.parentRow.parentTable.index >= table.index)
                    console.log("subDocument.tables[" + tIndex + "].parentCell.parentRow.parentTable.index >= table.index");
                var prevRowEndPosition = -1;
                var prevColumnsCount = -1;
                for (var rIndex = 0, row = void 0; row = table.rows[rIndex]; rIndex++) {
                    var currentColumnsCount = row.gridAfter + row.gridBefore;
                    if (row.cells.length === 0)
                        console.log("tables[" + tIndex + "].rows.length === 0");
                    if (prevRowEndPosition >= 0 && prevRowEndPosition !== row.getStartPosition())
                        console.log("tables[" + tIndex + "].rows[" + rIndex + "].getStartPosition() != prevRowEndPosition");
                    if (row.parentTable !== table)
                        console.log("tables[" + tIndex + "].rows[" + rIndex + "].parentTable != table");
                    prevRowEndPosition = row.getEndPosition();
                    for (var cIndex = 0, cell = void 0; cell = row.cells[cIndex]; cIndex++) {
                        currentColumnsCount += cell.columnSpan;
                        if (cell.startParagraphPosition.value >= cell.endParagrapPosition.value)
                            console.log("tables[" + tIndex + "].rows[" + rIndex + "].cells[" + cIndex + "].startParagraphPosition.value >= cell.endParagrapPosition.value");
                        var startParagraph = subDocument.getParagraphByPosition(cell.startParagraphPosition.value);
                        var endParagraph = subDocument.getParagraphByPosition(cell.endParagrapPosition.value - 1);
                        if (cell.startParagraphPosition.value !== startParagraph.startLogPosition.value)
                            console.log("tables[" + tIndex + "].rows[" + rIndex + "].cells[" + cIndex + "] doesn't start with paragraph");
                        if (cell.endParagrapPosition.value !== endParagraph.getEndPosition())
                            console.log("tables[" + tIndex + "].rows[" + rIndex + "].cells[" + cIndex + "] doesn't end with paragraph");
                    }
                    if (rIndex > 0 && currentColumnsCount !== prevColumnsCount)
                        console.log("tables[" + tIndex + "].rows[" + rIndex + "].columnsCount(" + currentColumnsCount + ") != prevColumnsCount(" + prevColumnsCount + ")");
                    prevColumnsCount = currentColumnsCount;
                }
            }
        });
    };
    TEST_CLASS.getPlaceActualTableProperties = function (table, prefix) {
        if (prefix === void 0) { prefix = ""; }
        var prefix_1 = prefix + "\t";
        var prefix_2 = prefix_1 + "\t";
        var prefix_3 = prefix_2 + "\t";
        var prefix_4 = prefix_3 + "\t";
        var prefix_5 = prefix_4 + "\t";
        var cellHandler = function (cell, cellIndex) {
            return prefix_3 + "cell[" + cellIndex + "]\n" + log_obj_to_str_1.LogObjToStr.tableCellMembers(cell, prefix_4) + "\n" + prefix_4 + "cellProperties\n" + log_obj_to_str_1.LogObjToStr.tableCellProperties(cell.properties, prefix_5);
        };
        var rowHandler = function (row, rowIndex) {
            return prefix_1 + "row[" + rowIndex + "]:\n" + log_obj_to_str_1.LogObjToStr.tableRowMembers(row, prefix_2) + "\n" + prefix_2 + "rowProperties:\n" + log_obj_to_str_1.LogObjToStr.tableRowProperties(row.properties, prefix_3) + "\n" + prefix_2 + "cells:\n" + log_1.Log.join("\n", log_1.Log.map(cellHandler, row.cells));
        };
        var result = [];
        result.push(log_1.Log.TRIPLE_SOLID_BLOCK + "\n" + log_obj_to_str_1.LogObjToStr.tableMembers(table, prefix));
        result.push(prefix + "tableProperties\n" + log_obj_to_str_1.LogObjToStr.tableProperties(table.properties, prefix_1));
        result.push(prefix + "rows\n" + log_1.Log.join("\n", log_1.Log.map(rowHandler, table.rows)));
        result.push(prefix + "styles\n" + log_obj_to_str_1.LogObjToStr.tableStyle(table.style, prefix_1));
        console.log(result.join("\n"));
    };
    TEST_CLASS.getTableStructure = function (subDocument, index) {
        var result = "";
        var table = subDocument.tables[index];
        result += "<(" + index + ")";
        for (var rowIndex = 0, row = void 0; row = table.rows[rowIndex]; rowIndex++) {
            if (rowIndex > 0)
                result += "\n";
            result += "\t";
            result += string_1.StringUtils.repeat("→ ", row.gridBefore);
            for (var cellIndex = 0, cell = void 0; cell = row.cells[cellIndex]; cellIndex++) {
                result += " [" + cell.startParagraphPosition.value + " ";
                if (cell.columnSpan > 1)
                    result += Array(cell.columnSpan).join("→");
                if (cell.verticalMerging === table_base_structures_1.TableCellMergingState.Restart)
                    result += "↓";
                if (cell.verticalMerging === table_base_structures_1.TableCellMergingState.Continue)
                    result += "↑";
                for (var ind = index + 1, nextTable = void 0; nextTable = subDocument.tables[ind]; ind++) {
                    if (nextTable.nestedLevel == table.nestedLevel + 1 &&
                        cell.interval.containsInterval(nextTable.interval))
                        result += "\n\t" + this.getTableStructure(subDocument, ind) + "\n";
                }
                result += " " + cell.endParagrapPosition.value + "] ";
            }
            result += string_1.StringUtils.repeat("← ", row.gridAfter);
        }
        result += ">";
        return result;
    };
    TEST_CLASS.getTableIndexesInfoByLayoutCell = function (cellInfo) {
        var tti = new TEST_TABLE_INFO();
        var rowInfo = cellInfo.parentRow;
        var tableInfo = rowInfo.parentTable;
        var logicInfo = tableInfo.logicInfo.grid;
        tti.modelTableIndex = logicInfo.table.index;
        tti.nestedLevel = logicInfo.table.nestedLevel;
        tti.layoutRowIndex = tableInfo.tableRows.indexOf(rowInfo);
        tti.layoutCellIndex = rowInfo.rowCells.indexOf(cellInfo);
        return tti;
    };
    TEST_CLASS.anchorInfoToString = function (ancInfo) {
        var result = [];
        if (ancInfo.isUsedHorizontalAbsolutePosition())
            result.push("Horiz ABS pos " + log_1.Log.mask(enums_2.AnchorObjectHorizontalPositionType, ancInfo.horizontalPositionType) + " " + unit_converter_1.UnitConverter.twipsToPixels(ancInfo.offset.x) + "px");
        if (ancInfo.isUsedHorizontalAlignment() || ancInfo.isUsedHorizontalBookLayout()) {
            result.push(ancInfo.isUsedHorizontalAlignment() ? "Horiz ALIGNMENT " : "Horiz BookLayout ");
            result.push(log_1.Log.mask(enums_2.AnchorObjectHorizontalPositionType, ancInfo.horizontalPositionType));
            result.push(" ");
            result.push(log_1.Log.mask(enums_2.AnchorObjectHorizontalPositionAlignment, ancInfo.horizontalPositionAlignment));
        }
        if (ancInfo.isUsedHorizontalRelativePosition())
            result.push("Horiz RELATIVE pos " + ancInfo.percentOffset.x / anchor_info_1.AnchorInfo.RELATIVE_COEFF + "%");
        if (ancInfo.isUsedVerticalAbsolutePosition())
            result.push("\nVert ABS pos " + log_1.Log.mask(enums_2.AnchorObjectVerticalPositionType, ancInfo.verticalPositionType) + " " + unit_converter_1.UnitConverter.twipsToPixels(ancInfo.offset.y) + "px");
        if (ancInfo.isUsedVerticalAlignment()) {
            result.push("\nVert ALIGNMENT pos");
            result.push(log_1.Log.mask(enums_2.AnchorObjectVerticalPositionType, ancInfo.verticalPositionType));
            result.push(" ");
            result.push(log_1.Log.mask(enums_2.AnchorObjectVerticalPositionAlignment, ancInfo.verticalPositionAlignment));
        }
        if (ancInfo.isUsedVerticalRelativePosition())
            result.push("\nVert RELATIVE pos " + ancInfo.percentOffset.y / anchor_info_1.AnchorInfo.RELATIVE_COEFF + "%");
        result.push("\nDistanceFromText\n");
        result.push("\t Top: " + unit_converter_1.UnitConverter.twipsToPixels(ancInfo.topDistance) + "px \n");
        result.push("\t Bottom: " + unit_converter_1.UnitConverter.twipsToPixels(ancInfo.bottomDistance) + "px \n");
        result.push("\t Left: " + unit_converter_1.UnitConverter.twipsToPixels(ancInfo.leftDistance) + "px \n");
        result.push("\t Right: " + unit_converter_1.UnitConverter.twipsToPixels(ancInfo.rightDistance) + "px \n");
        return result.join("");
    };
    TEST_CLASS.selectionInfo = function (selection) {
        var res = [];
        list_1.ListUtils.forEach(selection.intervals, function (curr) { return res.push(log_obj_to_str_1.LogObjToStr.fixedInterval(curr)); });
        res.push("pageIndex=" + selection.pageIndex);
        res.push("activeSubDoc=" + log_obj_to_str_1.LogObjToStr.subDocumentInfoBase(selection.activeSubDocument.info, "", " "));
        if (selection.specialRunInfo.isSelected()) {
            if (selection.specialRunInfo.isPictureSelected()) {
                res.push(selection.specialRunInfo.isSelectedAnchorObject ? "anchored picture" : "inline picture");
                res.push("pos=" + selection.specialRunInfo.getPicturePosition());
            }
            else {
                res.push(selection.specialRunInfo.isSelectedAnchorObject ? "anchored text box" : "inline text box");
                res.push("pos=" + selection.specialRunInfo.getTextBoxPosition());
                res.push("internalSubDocId=" + selection.specialRunInfo.textBoxInnerSubDocumentId);
            }
            res.push("parentSubDoc=" + log_obj_to_str_1.LogObjToStr.subDocumentInfoBase(selection.specialRunInfo.getParentSubDocument().info, "", " "));
        }
        return res.join("\n");
    };
    return TEST_CLASS;
}());
exports.TEST_CLASS = TEST_CLASS;
var TEST_CLASS_PROPS_ANALYZE = (function () {
    function TEST_CLASS_PROPS_ANALYZE() {
    }
    TEST_CLASS_PROPS_ANALYZE.analyzeContainer = function (container, getPropFromContainer, enumObject, enumProperty) {
        return container.getUseValue(enumProperty) ?
            "Consider property " + enumObject[enumProperty] + " with value " + getPropFromContainer(container) :
            "";
    };
    TEST_CLASS_PROPS_ANALYZE.analyzeTableConditionalStyles = function (tableStyle, getContainerFromCondStyle, getValue, enumObject, enumProperty) {
        var result = [];
        enum_1.EnumUtils.forEach(table_base_structures_1.ConditionalTableStyleFormatting, function (enumKey) {
            var condStyle = tableStyle.conditionalStyles[enumKey];
            if (condStyle)
                result.push("ConditionalStyle " + table_base_structures_1.ConditionalTableStyleFormatting[enumKey] + ": " + TEST_CLASS_PROPS_ANALYZE.analyzeContainer(getContainerFromCondStyle(condStyle), getValue, enumObject, enumProperty));
        });
        if (tableStyle.baseConditionalStyle)
            result.push("ConditionalStyle BASE: " + TEST_CLASS_PROPS_ANALYZE.analyzeContainer(getContainerFromCondStyle(tableStyle.baseConditionalStyle), getValue, enumObject, enumProperty));
        return result.length ? result.join("\n") : "Dont consider that property";
    };
    TEST_CLASS_PROPS_ANALYZE.analyzeTableConditionalStyleByCharacterPropertyFontSize = function (tableStyle) {
        return TEST_CLASS_PROPS_ANALYZE.analyzeTableConditionalStyles(tableStyle, function (tblCondStyle) { return tblCondStyle.maskedCharacterProperties; }, function (c) { return c.fontSize; }, enums_1.CharacterPropertiesMask, enums_1.CharacterPropertiesMask.UseDoubleFontSize);
    };
    TEST_CLASS_PROPS_ANALYZE.analyzeTableConditionalStyleByCharacterPropertyColor = function (tableStyle) {
        return TEST_CLASS_PROPS_ANALYZE.analyzeTableConditionalStyles(tableStyle, function (tblCondStyle) { return tblCondStyle.maskedCharacterProperties; }, function (c) { return c.textColor; }, enums_1.CharacterPropertiesMask, enums_1.CharacterPropertiesMask.UseForeColorIndex);
    };
    return TEST_CLASS_PROPS_ANALYZE;
}());
exports.TEST_CLASS_PROPS_ANALYZE = TEST_CLASS_PROPS_ANALYZE;
var BOX_ITERATOR_VISUALIZER = (function () {
    function BOX_ITERATOR_VISUALIZER(control) {
        this.canRunNext = true;
        this.canRunPrev = true;
        this.control = control;
        this.reset();
    }
    BOX_ITERATOR_VISUALIZER.prototype.reset = function () {
        this.it = new layout_box_iterator_main_sub_document_1.LayoutBoxIteratorMainSubDocument(this.control.selection.activeSubDocument, this.control.layout, this.control.selection.lastSelectedInterval.start, this.control.selection.lastSelectedInterval.end);
    };
    BOX_ITERATOR_VISUALIZER.prototype.next = function () {
        if (this.canRunNext) {
            if (this.it.moveNext(new layout_position_creator_1.LayoutPositionCreatorConflictFlags().setDefault(false), new layout_position_creator_1.LayoutPositionCreatorConflictFlags().setDefault(false))) {
                var posStart = this.it.position.getLogPosition(document_layout_details_level_1.DocumentLayoutDetailsLevel.Character);
                var posEnd = this.it.position.getLogPosition(document_layout_details_level_1.DocumentLayoutDetailsLevel.Box) + this.it.position.box.getLength();
                this.control.selection.deprecatedSetSelection(posStart, posEnd, false, -1, true, true, true, model_scroll_manager_1.ModelScrollManager.StandartScrollPosition);
                this.canRunPrev = true;
                return true;
            }
            else {
                this.canRunNext = false;
                return false;
            }
        }
        return false;
    };
    BOX_ITERATOR_VISUALIZER.prototype.prev = function () {
        if (this.canRunPrev) {
            if (this.it.movePrev(new layout_position_creator_1.LayoutPositionCreatorConflictFlags().setDefault(false), new layout_position_creator_1.LayoutPositionCreatorConflictFlags().setDefault(false))) {
                var posStart = this.it.position.getLogPosition(document_layout_details_level_1.DocumentLayoutDetailsLevel.Character);
                var posEnd = this.it.position.getLogPosition(document_layout_details_level_1.DocumentLayoutDetailsLevel.Box) + this.it.position.box.getLength();
                var docEndPos = this.control.selection.activeSubDocument.getDocumentEndPosition();
                if (posStart == posEnd && posStart == docEndPos)
                    this.control.selection.deprecatedSetSelection(docEndPos - 1, docEndPos, false, -1, true, true, true, model_scroll_manager_1.ModelScrollManager.StandartScrollPosition);
                else
                    this.control.selection.deprecatedSetSelection(posStart, posEnd, false, -1, true, true, true, model_scroll_manager_1.ModelScrollManager.StandartScrollPosition);
                this.canRunNext = true;
                return true;
            }
            else {
                this.canRunPrev = false;
                return false;
            }
        }
        return false;
    };
    return BOX_ITERATOR_VISUALIZER;
}());
exports.BOX_ITERATOR_VISUALIZER = BOX_ITERATOR_VISUALIZER;
var TEST_TABLE_INFO = (function () {
    function TEST_TABLE_INFO() {
    }
    TEST_TABLE_INFO.prototype.toString = function () {
        return "modelTableIndex: " + this.modelTableIndex + ", nestedLevel: " + this.nestedLevel + ", layoutRowIndex: " + this.layoutRowIndex + ", layoutCellIndex: " + this.layoutCellIndex;
    };
    return TEST_TABLE_INFO;
}());
exports.TEST_TABLE_INFO = TEST_TABLE_INFO;
