"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var control_font_1 = require("../core/model/fonts/control-font");
var font_info_1 = require("../core/model/fonts/font-info");
var grabber_1 = require("../core/model/fonts/grabber");
var loader_1 = require("../core/model/fonts/loader");
var file_1 = require("@devexpress/utils/lib/utils/file");
var fonts_1 = require("@devexpress/utils/lib/utils/fonts");
var list_1 = require("@devexpress/utils/lib/utils/list");
var page_exporter_1 = require("./page-exporter");
var PdfExporter = (function () {
    function PdfExporter(docProcessor) {
        this.docProcessor = docProcessor;
    }
    Object.defineProperty(PdfExporter.prototype, "layoutFormatterManager", {
        get: function () {
            return this.docProcessor.layoutFormatterManager;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfExporter.prototype, "measurer", {
        get: function () {
            return this.docProcessor.layoutFormatterManager.measurer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfExporter.prototype, "pdfFontCache", {
        get: function () {
            return this.docProcessor.modelManager.model.cache.controlFontsCache;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfExporter.prototype, "pdfSettings", {
        get: function () {
            return this.docProcessor.modelManager.richOptions.pdf;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfExporter.prototype, "fontsSettings", {
        get: function () {
            return this.docProcessor.modelManager.richOptions.fonts;
        },
        enumerable: true,
        configurable: true
    });
    PdfExporter.prototype.export = function (callback, options) {
        var _this = this;
        var modifyPdfDocument = typeof options == 'function' ? options :
            (!options || !options.modifyPdfDocument ? function () { } : options.modifyPdfDocument);
        var modifyPdfPage = typeof options == 'function' || !options || !options.modifyPdfPage ? function () { } : options.modifyPdfPage;
        if (!this.layoutFormatterManager.isDocumentOpened) {
            setTimeout(function () { return modifyPdfDocument(null); }, 0);
            return;
        }
        var afterLibLoaded = function () {
            if (!_this.pdfSettings.pdfDocument) {
                console.warn('Pdf kit library is not loaded.');
                setTimeout(function () { return modifyPdfDocument(null); }, 0);
                return;
            }
            if (!_this.pdfSettings.blobStream) {
                console.warn('Blob stream library is not loaded.');
                setTimeout(function () { return modifyPdfDocument(null); }, 0);
                return;
            }
            var layout = _this.layoutFormatterManager.layout;
            while (!layout.isFullyFormatted)
                _this.layoutFormatterManager.runFormatting(layout.validPageCount);
            var fontsCollector = new grabber_1.LayoutFontsCollector(_this.docProcessor.modelManager.model.cache, layout, _this.fontsSettings.mappings.defaultFontName);
            var fonts = fontsCollector.collect();
            var loader = new loader_1.ControlFontsLoader(_this.pdfFontCache, _this.fontsSettings, true);
            loader.loadFonts(fonts, [control_font_1.FontLoadStatus.Unloaded], function () {
                var anyFont = list_1.ListUtils.unsafeAnyOf(fonts, function (font) { return _this.pdfFontCache.getFont(font); });
                if (!anyFont) {
                    modifyPdfDocument(null);
                    return;
                }
                if (fonts_1.fontWebApiAvailable()) {
                    fonts_1.afterFontsLoaded(function () {
                        if (loader.needInvalidateLayout)
                            _this.docProcessor.invalidateLayoutAfterFontsLoaded();
                        while (!layout.isFullyFormatted)
                            _this.layoutFormatterManager.runFormatting(layout.validPageCount);
                        _this.exportDocument(layout, fonts, fontsCollector, callback, modifyPdfDocument, modifyPdfPage);
                    });
                }
                else
                    _this.exportDocument(layout, fonts, fontsCollector, callback, modifyPdfDocument, modifyPdfPage);
            });
        };
        var scriptUrl = this.docProcessor.modelManager.richOptions.pdf.pdfKitScriptUrl;
        if (scriptUrl && (!this.pdfSettings.pdfDocument || !this.pdfSettings.blobStream))
            file_1.FileUtils.loadJavascriptFile(scriptUrl, afterLibLoaded);
        else {
            afterLibLoaded();
        }
    };
    PdfExporter.prototype.exportDocument = function (layout, fonts, fontsCollector, callback, modifyPdfDocument, modifyPdfPage) {
        var doc = new this.pdfSettings.pdfDocument({ autoFirstPage: false, font: 'Symbol' });
        var stream = new this.pdfSettings.blobStream();
        stream.on('finish', function () {
            var blob = stream.toBlob('application/pdf');
            callback(blob, stream);
        });
        doc.pipe(stream);
        for (var _i = 0, fonts_2 = fonts; _i < fonts_2.length; _i++) {
            var font = fonts_2[_i];
            var cacheElem = this.pdfFontCache.getFont(font);
            if (cacheElem)
                doc.registerFont(font.cacheKey, cacheElem.data, cacheElem.isFontCollection ? cacheElem.fontFamily : undefined);
        }
        var layoutFontsCollCache = this.replaceUnloadedFonts(fontsCollector);
        var pageExporter = new page_exporter_1.PdfLayoutPageExporter(doc, layoutFontsCollCache, this.measurer);
        layout.pages.forEach(function (page) {
            pageExporter.export(page, layout.anchorObjectsPositionInfo, layout.pageColor);
            modifyPdfPage(doc);
        });
        modifyPdfDocument(doc);
        doc.end();
    };
    PdfExporter.prototype.replaceUnloadedFonts = function (fontsCollector) {
        var defaultFontMap = {};
        var defaultFontName = this.docProcessor.modelManager.richOptions.fonts.mappings.defaultFontName;
        var defaultFontInfo = defaultFontName ? this.docProcessor.modelManager.model.cache.fontInfoCache.getItemByName(defaultFontName) : null;
        if (defaultFontInfo)
            for (var _i = 0, _a = [font_info_1.ControlFontType.Regular, font_info_1.ControlFontType.Bold, font_info_1.ControlFontType.Italic, font_info_1.ControlFontType.BoldItalic]; _i < _a.length; _i++) {
                var fontType = _a[_i];
                defaultFontMap[fontType] = this.getControlFontByType(defaultFontInfo, fontType);
            }
        return fontsCollector.cache.replaceUnloadedFonts(defaultFontMap);
    };
    PdfExporter.prototype.getControlFontByType = function (fontInfo, controlFontType) {
        var key = fontInfo.controlFontMap[controlFontType];
        var controlFont = this.docProcessor.modelManager.model.cache.controlFontsCache.getFontByKey(key);
        return controlFont && controlFont.loaded ? controlFont : undefined;
    };
    return PdfExporter;
}());
exports.PdfExporter = PdfExporter;
