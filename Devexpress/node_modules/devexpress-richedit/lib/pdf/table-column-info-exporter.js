"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var enums_1 = require("../core/model/borders/enums");
var color_1 = require("../core/model/color/color");
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var point_1 = require("@devexpress/utils/lib/geometry/point");
var PdfLayoutTableColumnInfoExporter = (function () {
    function PdfLayoutTableColumnInfoExporter(doc) {
        this.doc = doc;
    }
    PdfLayoutTableColumnInfoExporter.prototype.export = function (tableColumnInfo, columnOffset) {
        this.doc.save();
        var pos = point_1.Point.plus(columnOffset, tableColumnInfo);
        for (var _i = 0, _a = tableColumnInfo.tableRows; _i < _a.length; _i++) {
            var row = _a[_i];
            for (var _b = 0, _c = row.backgroundInfos; _b < _c.length; _b++) {
                var cell = _c[_b];
                if (cell.color != color_1.ColorHelper.AUTOMATIC_COLOR && color_1.ColorHelper.getCssStringInternal(cell.color) != 'transparent') {
                    var backgroundPos = new point_1.Point(pos.x + cell.x, pos.y + cell.y).applyConverter(unit_converter_1.UnitConverter.pixelsToPointsF);
                    this.doc.rect(backgroundPos.x, backgroundPos.y, unit_converter_1.UnitConverter.pixelsToPointsF(cell.width), unit_converter_1.UnitConverter.pixelsToPointsF(cell.height))
                        .fill(color_1.ColorHelper.getCssStringInternal(cell.color));
                }
            }
        }
        for (var _d = 0, _e = tableColumnInfo.horizontalBorders; _d < _e.length; _d++) {
            var border = _e[_d];
            this.exportHorizontalBorder(border, pos);
        }
        for (var _f = 0, _g = tableColumnInfo.verticalBorders; _f < _g.length; _f++) {
            var border = _g[_f];
            this.exportVerticalBorder(border, pos);
        }
        this.doc.restore();
    };
    PdfLayoutTableColumnInfoExporter.prototype.isRenderTableBorder = function (borderInfo) {
        return borderInfo && borderInfo.style != enums_1.BorderLineStyle.None && borderInfo.style != enums_1.BorderLineStyle.Nil;
    };
    PdfLayoutTableColumnInfoExporter.prototype.exportHorizontalBorder = function (border, tblPos) {
        var borderInfo = border.borderInfo;
        if (this.isRenderTableBorder(borderInfo)) {
            var brdPos = point_1.Point.plus(tblPos, new point_1.Point(border.xPos, border.yPos)).applyConverter(unit_converter_1.UnitConverter.pixelsToPointsF);
            this.drawHorizontalLine(brdPos, unit_converter_1.UnitConverter.pixelsToPointsF(border.length), unit_converter_1.UnitConverter.pixelsToPointsF(borderInfo.width), borderInfo.color);
        }
    };
    PdfLayoutTableColumnInfoExporter.prototype.exportVerticalBorder = function (border, tblPos) {
        var borderInfo = border.borderInfo;
        if (this.isRenderTableBorder(borderInfo)) {
            var brdPos = point_1.Point.plus(tblPos, new point_1.Point(border.xPos, border.yPos)).applyConverter(unit_converter_1.UnitConverter.pixelsToPointsF);
            this.drawVerticalLine(brdPos, unit_converter_1.UnitConverter.pixelsToPointsF(borderInfo.width), unit_converter_1.UnitConverter.pixelsToPointsF(border.length), borderInfo.color);
        }
    };
    PdfLayoutTableColumnInfoExporter.prototype.drawHorizontalLine = function (pos, length, width, color) {
        this.doc.rect(pos.x, pos.y - width / 2, length, width).fill(color_1.ColorHelper.getCssStringInternal(color));
    };
    PdfLayoutTableColumnInfoExporter.prototype.drawVerticalLine = function (pos, width, height, color) {
        this.doc.rect(pos.x, pos.y, width, height).fill(color_1.ColorHelper.getCssStringInternal(color));
    };
    return PdfLayoutTableColumnInfoExporter;
}());
exports.PdfLayoutTableColumnInfoExporter = PdfLayoutTableColumnInfoExporter;
