"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var insert_paragraph_manipulator_params_1 = require("../../core/model/manipulators/paragraph-manipulator/insert-paragraph-manipulator-params");
var insert_text_manipulator_params_1 = require("../../core/model/manipulators/text-manipulator/insert-text-manipulator-params");
var run_type_1 = require("../../core/model/runs/run-type");
var sub_document_1 = require("../../core/model/sub-document");
var input_position_base_1 = require("../../core/selection/input-position-base");
var selection_intervals_info_1 = require("../../core/selection/selection-intervals-info");
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var boundary_1 = require("@devexpress/utils/lib/intervals/boundary");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var list_1 = require("@devexpress/utils/lib/utils/list");
function insertTextThroughApi(position, text, subDocument, processor, options) {
    var _a, _b;
    if (!text.length)
        return new fixed_1.FixedInterval(position, 0);
    var inputPos = (_a = options === null || options === void 0 ? void 0 : options.inputPosition) !== null && _a !== void 0 ? _a : new input_position_base_1.InputPositionBase().setIntervals(selection_intervals_info_1.SelectionIntervalsInfo.fromPosition(subDocument, position));
    var wrapIntoBeginUpdate = (_b = options === null || options === void 0 ? void 0 : options.wrapIntoBeginUpdate) !== null && _b !== void 0 ? _b : true;
    if (wrapIntoBeginUpdate)
        processor.beginUpdate();
    processor.modelManager.history.beginTransaction();
    var parMarkRegexp = new RegExp(/\r\n|\n|\r/g);
    var stringLength = text.length;
    var getNextParMarkPos = function (offset) {
        parMarkRegexp.lastIndex = offset;
        var result = parMarkRegexp.exec(text);
        return result ? result.index : -1;
    };
    var paragraphSymbolPostion = getNextParMarkPos(0);
    var fromPos = 0;
    var toPos = position;
    var resultIntervals = [];
    while (fromPos < stringLength) {
        var insertedTextLength = void 0;
        if (paragraphSymbolPostion == fromPos) {
            resultIntervals.push(processor.modelManager.modelManipulator.paragraph.insertParagraphViaHistory(insert_paragraph_manipulator_params_1.InsertParagraphManipulatorParams.makeParamsByPosition(new sub_document_1.SubDocumentPosition(subDocument, toPos), inputPos)));
            insertedTextLength = text.substr(paragraphSymbolPostion, 2) == '\r\n' ? 2 : 1;
            paragraphSymbolPostion = getNextParMarkPos(fromPos + insertedTextLength);
        }
        else {
            var paragraphEndPos = paragraphSymbolPostion == -1 ? stringLength : paragraphSymbolPostion;
            var paragraphText = text.substring(fromPos, paragraphEndPos);
            resultIntervals.push(processor.modelManager.modelManipulator.text.insertTextViaHistory(new insert_text_manipulator_params_1.InsertTextManipulatorParams(new sub_document_1.SubDocumentPosition(subDocument, toPos), inputPos.charPropsBundle, run_type_1.RunType.TextRun, paragraphText)).insertedInterval);
            insertedTextLength = paragraphText.length;
        }
        toPos += insertedTextLength;
        fromPos += insertedTextLength;
    }
    processor.modelManager.history.endTransaction();
    if (wrapIntoBeginUpdate)
        processor.endUpdate();
    var mergedIntervals = algorithms_1.IntervalAlgorithms.getMergedIntervals(resultIntervals, true);
    return new boundary_1.BoundaryInterval(mergedIntervals[0].start, list_1.ListUtils.last(mergedIntervals).end);
}
exports.insertTextThroughApi = insertTextThroughApi;
