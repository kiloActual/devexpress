"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var control_font_1 = require("../../core/model/fonts/control-font");
var loader_1 = require("../../core/model/fonts/loader");
var ControlFontApi = (function () {
    function ControlFontApi(processor, font) {
        this._font = font;
        this._processor = processor;
    }
    Object.defineProperty(ControlFontApi.prototype, "fontFamily", {
        get: function () { return this._font.fontFamily; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControlFontApi.prototype, "status", {
        get: function () {
            switch (this._font.status) {
                case control_font_1.FontLoadStatus.Error: return 'error';
                case control_font_1.FontLoadStatus.Loaded: return 'loaded';
                case control_font_1.FontLoadStatus.Loading: return 'loading';
                case control_font_1.FontLoadStatus.Unloaded: return 'unloaded';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControlFontApi.prototype, "descriptors", {
        get: function () { return this._font.descriptors.clone(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControlFontApi.prototype, "data", {
        get: function () { return this._font.data; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControlFontApi.prototype, "sourceUrls", {
        get: function () { return this._font.allSourceUrls(this._processor.modelManager.richOptions.fonts.defaultFolder); },
        set: function (val) { this._font.sourceUrls = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControlFontApi.prototype, "sourceUrl", {
        set: function (val) { this._font.sourceUrls = [val]; },
        enumerable: true,
        configurable: true
    });
    ControlFontApi.prototype.load = function (reloadFailed, callback) {
        var _this = this;
        if (reloadFailed === void 0) { reloadFailed = false; }
        if (!callback)
            callback = function () { };
        var modelManager = this._processor.modelManager;
        var loader = new loader_1.ControlFontsLoader(modelManager.model.cache.controlFontsCache, modelManager.richOptions.fonts, false);
        var status = [control_font_1.FontLoadStatus.Unloaded];
        if (reloadFailed)
            status.push(control_font_1.FontLoadStatus.Error);
        loader.loadFonts([this._font], status, function () {
            if (loader.needInvalidateLayout)
                _this._processor.invalidateLayoutAfterFontsLoaded();
            callback();
        });
    };
    ControlFontApi.prototype.delete = function () {
        this._processor.modelManager.model.cache.controlFontsCache.deleteFont(this._font);
    };
    return ControlFontApi;
}());
exports.ControlFontApi = ControlFontApi;
