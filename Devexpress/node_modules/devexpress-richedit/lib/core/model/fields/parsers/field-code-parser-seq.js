"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var insert_text_manipulator_params_1 = require("../../manipulators/text-manipulator/insert-text-manipulator-params");
var run_type_1 = require("../../runs/run-type");
var sub_document_1 = require("../../sub-document");
var field_1 = require("../field");
var names_1 = require("../names");
var field_code_parser_1 = require("./field-code-parser");
var field_code_parser_client_updating_base_1 = require("./field-code-parser-client-updating-base");
var FieldCodeParserSeq = (function (_super) {
    tslib_1.__extends(FieldCodeParserSeq, _super);
    function FieldCodeParserSeq() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(FieldCodeParserSeq.prototype, "name", {
        get: function () { return names_1.FieldName.Seq; },
        enumerable: true,
        configurable: true
    });
    FieldCodeParserSeq.prototype.fillResult = function () {
        var field = this.getTopField();
        var sequenceInfo = this.updateSequenceInfo(field);
        if (!sequenceInfo || sequenceInfo.hidesResult) {
            this.removeInterval(this.getTopField().getResultInterval());
            return true;
        }
        var currentValue = 0;
        for (var i = 0; i <= field.index; i++) {
            var currentField = this.subDocument.fields[i];
            var currentInfo = currentField.getSequenceInfo();
            if (currentInfo && currentInfo.identifier == sequenceInfo.identifier) {
                if (!currentInfo.repeats)
                    currentValue++;
                if (currentInfo.resets)
                    currentValue = currentInfo.resetsWith;
            }
        }
        var resultText = this.getFormattedResult(currentValue);
        this.removeInterval(this.getTopField().getResultInterval());
        this.setInputPositionState();
        this.modelManager.modelManipulator.text.insertTextViaHistory(new insert_text_manipulator_params_1.InsertTextManipulatorParams(new sub_document_1.SubDocumentPosition(this.subDocument, this.getTopField().getResultInterval().start), this.inputPos.charPropsBundle, run_type_1.RunType.TextRun, resultText));
        return true;
    };
    FieldCodeParserSeq.prototype.updateSequenceInfo = function (field) {
        var repeatsSwitch;
        var hidesResultSwitch;
        var resetsSwitch;
        for (var i = 0, switchInfo = void 0; switchInfo = this.switchInfoList[i]; i++)
            if (switchInfo.type == field_code_parser_1.FieldSwitchType.FieldSpecific) {
                switch (switchInfo.name.toLocaleUpperCase()) {
                    case "C":
                        repeatsSwitch = switchInfo;
                        break;
                    case "H":
                        hidesResultSwitch = switchInfo;
                        break;
                    case "R":
                        resetsSwitch = switchInfo;
                        break;
                }
            }
        var identifier = !!this.parameterInfoList[0] ? this.parameterInfoList[0].text : "";
        var sequenceInfo = new field_1.SequenceInfo(identifier, !!repeatsSwitch, !!hidesResultSwitch, !!resetsSwitch, resetsSwitch ? Number(resetsSwitch.arg) : 0);
        field.setNewSequenceInfo(sequenceInfo);
        return sequenceInfo;
    };
    FieldCodeParserSeq.prototype.needUpdateInfo = function () {
        return true;
    };
    FieldCodeParserSeq.prototype.updateInfoCore = function () {
        this.updateSequenceInfo(this.getTopField());
    };
    return FieldCodeParserSeq;
}(field_code_parser_client_updating_base_1.FieldCodeParserClientUpdatingBase));
exports.FieldCodeParserSeq = FieldCodeParserSeq;
