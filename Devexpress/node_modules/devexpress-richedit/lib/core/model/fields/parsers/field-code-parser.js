"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("@devexpress/utils/lib/errors");
var date_time_field_1 = require("@devexpress/utils/lib/formatters/date-time-field");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var common_1 = require("@devexpress/utils/lib/utils/common");
var string_1 = require("@devexpress/utils/lib/utils/string");
var input_position_base_1 = require("../../../selection/input-position-base");
var selection_intervals_info_1 = require("../../../selection/selection-intervals-info");
var insert_text_manipulator_params_1 = require("../../manipulators/text-manipulator/insert-text-manipulator-params");
var number_converter_creator_1 = require("../../number-converters/number-converter-creator");
var rich_utils_1 = require("../../rich-utils");
var run_type_1 = require("../../runs/run-type");
var sub_document_1 = require("../../sub-document");
var field_1 = require("../field");
var tree_creator_1 = require("../tree-creator");
var FieldCodeParserState;
(function (FieldCodeParserState) {
    FieldCodeParserState[FieldCodeParserState["start"] = 0] = "start";
    FieldCodeParserState[FieldCodeParserState["addedParsersCodePart"] = 1] = "addedParsersCodePart";
    FieldCodeParserState[FieldCodeParserState["updatedParsersCodePart"] = 2] = "updatedParsersCodePart";
    FieldCodeParserState[FieldCodeParserState["resultPartCreated"] = 3] = "resultPartCreated";
    FieldCodeParserState[FieldCodeParserState["addedParsersResultPart"] = 4] = "addedParsersResultPart";
    FieldCodeParserState[FieldCodeParserState["end"] = 5] = "end";
})(FieldCodeParserState = exports.FieldCodeParserState || (exports.FieldCodeParserState = {}));
var FieldSwitchType;
(function (FieldSwitchType) {
    FieldSwitchType[FieldSwitchType["Error"] = 0] = "Error";
    FieldSwitchType[FieldSwitchType["DateAndTime"] = 1] = "DateAndTime";
    FieldSwitchType[FieldSwitchType["Numeric"] = 2] = "Numeric";
    FieldSwitchType[FieldSwitchType["General"] = 3] = "General";
    FieldSwitchType[FieldSwitchType["FieldSpecific"] = 4] = "FieldSpecific";
})(FieldSwitchType = exports.FieldSwitchType || (exports.FieldSwitchType = {}));
var FieldMailMergeType;
(function (FieldMailMergeType) {
    FieldMailMergeType[FieldMailMergeType["NonMailMerge"] = 1] = "NonMailMerge";
    FieldMailMergeType[FieldMailMergeType["MailMerge"] = 2] = "MailMerge";
    FieldMailMergeType[FieldMailMergeType["Mixed"] = 3] = "Mixed";
})(FieldMailMergeType = exports.FieldMailMergeType || (exports.FieldMailMergeType = {}));
var FieldSwitch = (function () {
    function FieldSwitch(type, name, arg) {
        this.name = name;
        this.type = type;
        this.arg = arg;
    }
    return FieldSwitch;
}());
exports.FieldSwitch = FieldSwitch;
var FieldParameter = (function () {
    function FieldParameter(interval, textRepresentation) {
        this.text = textRepresentation;
        this.interval = interval;
    }
    FieldParameter.prototype.clone = function () {
        return new FieldParameter(this.interval.clone(), this.text);
    };
    return FieldParameter;
}());
exports.FieldParameter = FieldParameter;
var FieldCodeParserHelper = (function () {
    function FieldCodeParserHelper() {
    }
    FieldCodeParserHelper.isWhitespaceAndTextRunType = function (char, type) {
        return rich_utils_1.RichUtils.isWhitespace.test(char) && type == run_type_1.RunType.TextRun;
    };
    FieldCodeParserHelper.isBackslesh = function (char) {
        return char == "\\";
    };
    FieldCodeParserHelper.isQuote = function (char) {
        return char == "\"";
    };
    return FieldCodeParserHelper;
}());
exports.FieldCodeParserHelper = FieldCodeParserHelper;
var FieldCodeParser = (function () {
    function FieldCodeParser(args) {
        this.switchInfoList = [];
        this.parameterInfoList = [];
        this.modelManager = args.modelManager;
        this.layoutFormatterManager = args.layoutFormatterManager;
        this.requestManager = args.requestManager;
        this.subDocument = args.subDocument;
        this.inputPos = new input_position_base_1.InputPositionBase().setIntervals(selection_intervals_info_1.SelectionIntervalsInfo.fromPosition(args.subDocument, args.field.getResultInterval().start));
        this.fieldsStack = [args.field];
        this.modelIterator = args.modelIterator;
        this.lowLevelParsers = [];
        this.parserState = FieldCodeParserState.start;
        this.fieldNameFirstLetterPosition = args.subDocument.positionManager.registerPosition(args.fieldNameFirstLetterPosition);
    }
    FieldCodeParser.prototype.removeInterval = function (interval) {
        this.modelManager.modelManipulator.range.removeInterval(new sub_document_1.SubDocumentInterval(this.subDocument, interval), true, false);
    };
    FieldCodeParser.prototype.replaceTextByInterval = function (interval, text) {
        this.removeInterval(interval);
        this.modelManager.modelManipulator.text.insertTextViaHistory(new insert_text_manipulator_params_1.InsertTextManipulatorParams(new sub_document_1.SubDocumentPosition(this.subDocument, interval.start), this.inputPos.charPropsBundle, run_type_1.RunType.TextRun, text));
    };
    FieldCodeParser.prototype.replaceTextByLayoutDependentRun = function (interval) {
        this.removeInterval(interval);
        this.modelManager.modelManipulator.text.insertTextViaHistory(new insert_text_manipulator_params_1.InsertLayoutDependentTextManipulatorParams(new sub_document_1.SubDocumentPosition(this.subDocument, interval.start), this.inputPos.charPropsBundle));
    };
    FieldCodeParser.finalAction = function (layoutFormatterManager, field, subDocument) {
        field.showCode = false;
        if (layoutFormatterManager)
            layoutFormatterManager.invalidator.onIntervalChanged(subDocument.id, field.getAllFieldInterval());
    };
    FieldCodeParser.prototype.destructor = function () {
        this.subDocument.positionManager.unregisterPosition(this.fieldNameFirstLetterPosition);
        this.fieldNameFirstLetterPosition = null;
        FieldCodeParser.finalAction(this.layoutFormatterManager, this.getTopField(), this.subDocument);
    };
    FieldCodeParser.prototype.getMailMergeType = function () {
        throw new Error(errors_1.Errors.NotImplemented);
    };
    FieldCodeParser.prototype.handleSwitch = function (newSwitch) {
        this.switchInfoList.push(newSwitch);
        return true;
    };
    FieldCodeParser.prototype.handleParameter = function (newParameter) {
        this.parameterInfoList.push(newParameter);
        return true;
    };
    FieldCodeParser.prototype.getFormattedResult = function (value) {
        if (!common_1.isDefined(value))
            return null;
        var manager = this.modelManager;
        var type = FieldSwitchType.Error;
        var arg = "";
        for (var i = 0, switchInfo = void 0; switchInfo = this.switchInfoList[i]; i++) {
            if (switchInfo.type != FieldSwitchType.FieldSpecific) {
                arg = switchInfo.arg;
                type = switchInfo.type;
                break;
            }
        }
        var numericalValue = typeof value == 'string' ? parseInt(value) : value;
        if (type == FieldSwitchType.General && !isNaN(numericalValue) && !string_1.StringUtils.isNullOrEmpty(arg))
            return number_converter_creator_1.NumberConverterCreator.createConverterByTypeName(arg, manager.model.simpleFormattersManager).convertNumber(numericalValue);
        else if (type == FieldSwitchType.DateAndTime) {
            var date = isNaN(numericalValue) ? new Date(value.toString()) : new Date(numericalValue);
            if (!isNaN(date.getDate())) {
                var dateFormatter = new date_time_field_1.DateTimeFieldFormatter(manager.richOptions.cultureOpts);
                return !string_1.StringUtils.isNullOrEmpty(arg) ? dateFormatter.format(date, arg) :
                    dateFormatter.format(date, manager.richOptions.fields.defaultDateFormat);
            }
        }
        else if (type == FieldSwitchType.Numeric && !isNaN(numericalValue) && !string_1.StringUtils.isNullOrEmpty(arg))
            return manager.model.simpleFormattersManager.formatNumber(arg, numericalValue);
        return value.toString();
    };
    FieldCodeParser.prototype.setInputPositionState = function () {
        this.inputPos.setIntervals(selection_intervals_info_1.SelectionIntervalsInfo.fromPosition(this.subDocument, this.fieldNameFirstLetterPosition.value));
    };
    FieldCodeParser.prototype.getTopField = function () {
        return this.fieldsStack[0];
    };
    FieldCodeParser.prototype.update = function (responce) {
        if (this.parserState == FieldCodeParserState.end)
            throw new Error("Excess call updated field");
        switch (this.parserState) {
            case FieldCodeParserState.start:
                var field = this.getTopField();
                if (this.collectAndUpdateLowLevelFields(field.index + 1, field.getCodeStartPosition(), field.getSeparatorPosition())) {
                    this.parserState = FieldCodeParserState.updatedParsersCodePart;
                    return this.parseCodeCurrentField(null);
                }
                this.parserState = FieldCodeParserState.addedParsersCodePart;
                return false;
            case FieldCodeParserState.addedParsersCodePart:
                if (this.updateLowLevelFields(responce)) {
                    this.parserState = FieldCodeParserState.updatedParsersCodePart;
                    return this.parseCodeCurrentField(responce);
                }
                return false;
            case FieldCodeParserState.updatedParsersCodePart:
                return this.parseCodeCurrentField(responce);
            case FieldCodeParserState.addedParsersResultPart:
                return this.updateFieldsInResult(responce);
        }
    };
    FieldCodeParser.prototype.collectAndUpdateLowLevelFields = function (fieldIndex, startPosition, endPosition) {
        var fields = this.subDocument.fields;
        for (var field; field = fields[fieldIndex]; fieldIndex++) {
            if (field.getFieldStartPosition() > endPosition)
                break;
            if (field.parent != this.getTopField() || field.getFieldEndPosition() <= startPosition) {
                fieldIndex++;
                continue;
            }
            var fieldParser = tree_creator_1.FieldsWaitingForUpdate.getParser(this.modelManager, this.layoutFormatterManager, this.requestManager, this.subDocument, field);
            if (fieldParser) {
                if (!fieldParser.update(null))
                    this.lowLevelParsers.push(fieldParser);
                else
                    fieldParser.destructor();
            }
            else
                this.removeInterval(field.getResultInterval());
        }
        return this.lowLevelParsers.length == 0;
    };
    FieldCodeParser.prototype.updateLowLevelFields = function (responce) {
        for (var parserIndex = 0, parser; parser = this.lowLevelParsers[parserIndex]; parserIndex++) {
            if (parser.update(responce)) {
                parser.destructor();
                this.lowLevelParsers.splice(parserIndex, 1);
                parserIndex--;
            }
        }
        return this.lowLevelParsers.length == 0;
    };
    FieldCodeParser.prototype.parseCodeCurrentField = function (responce) {
        if (this.parseCodeCurrentFieldInternal(responce)) {
            switch (this.parserState) {
                case FieldCodeParserState.resultPartCreated:
                    return this.updateFieldsInResult(responce);
                case FieldCodeParserState.end:
                    return true;
                default:
                    throw new Error("wrong way");
            }
        }
        else {
            if (this.parserState == FieldCodeParserState.updatedParsersCodePart)
                return false;
            else
                throw new Error("wrong way");
        }
    };
    FieldCodeParser.prototype.updateFieldsInResult = function (responce) {
        switch (this.parserState) {
            case FieldCodeParserState.resultPartCreated:
                var fieldIndex = field_1.Field.normedBinaryIndexOf(this.subDocument.fields, this.getTopField().getResultStartPosition() + 1);
                var field = this.getTopField();
                if (this.collectAndUpdateLowLevelFields(fieldIndex, field.getResultStartPosition(), field.getResultEndPosition())) {
                    this.parserState = FieldCodeParserState.end;
                    return true;
                }
                this.parserState = FieldCodeParserState.addedParsersResultPart;
                return false;
            case FieldCodeParserState.addedParsersResultPart:
                if (this.updateLowLevelFields(responce)) {
                    this.parserState = FieldCodeParserState.end;
                    return true;
                }
                return false;
        }
    };
    FieldCodeParser.prototype.moveIteratorToNextChar = function () {
        if (this.modelIterator.run.getType() == run_type_1.RunType.FieldCodeEndRun)
            return false;
        if (!this.modelIterator.moveToNextChar())
            throw new Error("wrong way");
        while (true) {
            switch (this.modelIterator.run.getType()) {
                case run_type_1.RunType.FieldCodeStartRun:
                    var fieldIndex = field_1.Field.normedBinaryIndexOf(this.subDocument.fields, this.modelIterator.getAbsolutePosition() + 1);
                    var lowLevelField = this.subDocument.fields[fieldIndex];
                    this.fieldsStack.push(lowLevelField);
                    this.modelIterator.setPosition(lowLevelField.getResultStartPosition());
                    break;
                case run_type_1.RunType.FieldResultEndRun:
                case run_type_1.RunType.FieldCodeEndRun:
                    var lowLevelField = this.fieldsStack.pop();
                    if (this.fieldsStack.length == 0) {
                        this.fieldsStack.push(lowLevelField);
                        return false;
                    }
                    this.modelIterator.setPosition(lowLevelField.getFieldEndPosition());
                    break;
                default:
                    return true;
            }
        }
    };
    FieldCodeParser.prototype.updateInfo = function () {
        if (!this.needUpdateInfo())
            return false;
        this.parseSwitchesAndArgs(true);
        this.updateInfoCore();
        return true;
    };
    FieldCodeParser.prototype.needUpdateInfo = function () {
        return false;
    };
    FieldCodeParser.prototype.updateInfoCore = function () { };
    FieldCodeParser.prototype.parseSwitchesAndArgs = function (needAtLestOneSpaceAfterFieldName) {
        if (needAtLestOneSpaceAfterFieldName) {
            var prevPos = this.modelIterator.getAbsolutePosition();
            if (this.skipWhitespaces())
                this.modelIterator.setPosition(prevPos);
            else
                return this.modelIterator.run.getType() == run_type_1.RunType.FieldCodeEndRun;
        }
        while (this.skipWhitespaces() && this.modelIterator.run.getType() != run_type_1.RunType.FieldCodeEndRun) {
            var currChar = this.modelIterator.getCurrentChar();
            if (FieldCodeParserHelper.isBackslesh(currChar)) {
                var switchInfo = this.getSwitchInfo();
                if (switchInfo.type == FieldSwitchType.Error || !this.handleSwitch(switchInfo))
                    return false;
            }
            else {
                var paramInfo = this.getFieldParameterInfo();
                if (!paramInfo || !this.handleParameter(paramInfo))
                    return false;
            }
        }
        return this.modelIterator.run.getType() == run_type_1.RunType.FieldCodeEndRun;
    };
    FieldCodeParser.prototype.skipWhitespaces = function () {
        var isFindWhitespace = false;
        do {
            if (FieldCodeParserHelper.isWhitespaceAndTextRunType(this.modelIterator.getCurrentChar(), this.modelIterator.run.getType()) ||
                this.modelIterator.run.getType() == run_type_1.RunType.ParagraphRun ||
                this.modelIterator.run.getType() == run_type_1.RunType.SectionRun)
                isFindWhitespace = true;
            else
                break;
        } while (this.moveIteratorToNextChar());
        return isFindWhitespace;
    };
    FieldCodeParser.prototype.getFieldParameterInfo = function () {
        var startPosition = this.modelIterator.getAbsolutePosition();
        var parseResult = this.parseSwitchOrFieldArgument();
        if (!parseResult)
            return null;
        var argInterval = parseResult.quoted ?
            fixed_1.FixedInterval.fromPositions(startPosition + 1, this.modelIterator.getAbsolutePosition() - 1) :
            fixed_1.FixedInterval.fromPositions(startPosition, this.modelIterator.getAbsolutePosition());
        return new FieldParameter(argInterval, parseResult.argListChars.join(""));
    };
    FieldCodeParser.prototype.getSwitchInfo = function () {
        if (!this.moveIteratorToNextChar() || this.modelIterator.run.getType() != run_type_1.RunType.TextRun)
            return new FieldSwitch(FieldSwitchType.Error, "", "");
        var currChar = this.modelIterator.getCurrentChar();
        switch (currChar) {
            case "*": return this.makeSwitchInfo(FieldSwitchType.General, currChar, true);
            case "@": return this.makeSwitchInfo(FieldSwitchType.DateAndTime, currChar, true);
            case "#": return this.makeSwitchInfo(FieldSwitchType.Numeric, currChar, true);
            default:
                if (currChar == "!")
                    return this.makeSwitchInfo(FieldSwitchType.FieldSpecific, currChar, true);
                if (!rich_utils_1.RichUtils.isLatinLetter.test(currChar))
                    return new FieldSwitch(FieldSwitchType.Error, "", "");
                var switchName = currChar;
                var lastPos = this.modelIterator.getAbsolutePosition();
                if (this.moveIteratorToNextChar()) {
                    currChar = this.modelIterator.getCurrentChar();
                    if (rich_utils_1.RichUtils.isLatinLetter.test(currChar))
                        switchName += currChar;
                    else
                        this.modelIterator.setPosition(lastPos);
                }
                else
                    this.modelIterator.setPosition(lastPos);
                return this.makeSwitchInfo(FieldSwitchType.FieldSpecific, switchName, false);
        }
    };
    FieldCodeParser.prototype.makeSwitchInfo = function (switchType, switchName, needArgument) {
        var switchArg = this.getSwitchArgument(needArgument);
        if (switchArg === null || needArgument && switchArg.length == 0)
            return new FieldSwitch(FieldSwitchType.Error, "", "");
        return new FieldSwitch(switchType, switchName, switchArg);
    };
    FieldCodeParser.prototype.getSwitchArgument = function (needArgument) {
        if (!this.moveIteratorToNextChar())
            return needArgument ? null : "";
        if (!this.skipWhitespaces())
            return null;
        var parseResult = this.parseSwitchOrFieldArgument();
        if (!parseResult)
            return needArgument ? null : "";
        var resArg = parseResult.argListChars.join("");
        if (resArg.length == 0)
            return null;
        return resArg;
    };
    FieldCodeParser.prototype.parseSwitchOrFieldArgument = function () {
        if (this.modelIterator.run.getType() == run_type_1.RunType.FieldCodeEndRun)
            return null;
        var currChar = this.modelIterator.getCurrentChar();
        if (FieldCodeParserHelper.isBackslesh(currChar)) {
            this.modelIterator.moveToPrevChar();
            return null;
        }
        var resList = [];
        var startFieldStackSize = this.fieldsStack.length;
        var lastFieldStackLength = startFieldStackSize;
        var needSearchNextQuote = FieldCodeParserHelper.isQuote(currChar);
        if (needSearchNextQuote)
            if (!this.moveIteratorToNextChar())
                return null;
        var lastSymbolIsQuote = !needSearchNextQuote;
        do {
            currChar = this.modelIterator.getCurrentChar();
            if (needSearchNextQuote) {
                if (FieldCodeParserHelper.isQuote(currChar)) {
                    var prevChar = resList[resList.length - 1];
                    if (!(prevChar && FieldCodeParserHelper.isBackslesh(prevChar))) {
                        lastSymbolIsQuote = true;
                        lastFieldStackLength = this.fieldsStack.length;
                        this.moveIteratorToNextChar();
                        break;
                    }
                }
            }
            else if (FieldCodeParserHelper.isWhitespaceAndTextRunType(currChar, this.modelIterator.run.getType()))
                break;
            resList.push(currChar);
            lastFieldStackLength = this.fieldsStack.length;
        } while (this.moveIteratorToNextChar());
        if (startFieldStackSize != lastFieldStackLength || !lastSymbolIsQuote)
            return null;
        return { argListChars: resList, quoted: needSearchNextQuote };
    };
    return FieldCodeParser;
}());
exports.FieldCodeParser = FieldCodeParser;
