"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var list_1 = require("@devexpress/utils/lib/utils/list");
var model_iterator_1 = require("../model-iterator");
var linked_interval_1 = require("../position/linked-interval");
var rich_utils_1 = require("../rich-utils");
var run_type_1 = require("../runs/run-type");
var sub_document_1 = require("../sub-document");
var field_1 = require("./field");
var field_code_parser_1 = require("./parsers/field-code-parser");
var field_code_parser_date_1 = require("./parsers/field-code-parser-date");
var field_code_parser_doc_variable_1 = require("./parsers/field-code-parser-doc-variable");
var field_code_parser_hyperlink_1 = require("./parsers/field-code-parser-hyperlink");
var field_code_parser_merge_field_1 = require("./parsers/field-code-parser-merge-field");
var field_code_parser_num_pages_1 = require("./parsers/field-code-parser-num-pages");
var field_code_parser_page_1 = require("./parsers/field-code-parser-page");
var field_code_parser_page_ref_1 = require("./parsers/field-code-parser-page-ref");
var field_code_parser_seq_1 = require("./parsers/field-code-parser-seq");
var field_code_parser_tc_1 = require("./parsers/field-code-parser-tc");
var field_code_parser_time_1 = require("./parsers/field-code-parser-time");
var field_code_parser_toc_1 = require("./parsers/field-code-parser-toc");
var fill_in_1 = require("./parsers/fill-in");
var FieldParsersAndIntervals = (function () {
    function FieldParsersAndIntervals(interval) {
        this.interval = interval;
        this.parsers = [];
        this.updated = false;
    }
    FieldParsersAndIntervals.prototype.destructor = function (manager) {
        this.interval.destructor(manager);
    };
    return FieldParsersAndIntervals;
}());
var FieldUpdateResult = (function () {
    function FieldUpdateResult(subDocIntervals) {
        this.subDocIntervals = subDocIntervals;
    }
    return FieldUpdateResult;
}());
exports.FieldUpdateResult = FieldUpdateResult;
var UpdateFieldsOptions = (function () {
    function UpdateFieldsOptions(updateToc, updateFillIn) {
        if (updateToc === void 0) { updateToc = true; }
        if (updateFillIn === void 0) { updateFillIn = true; }
        this.updateToc = updateToc;
        this.updateFillIn = updateFillIn;
    }
    return UpdateFieldsOptions;
}());
exports.UpdateFieldsOptions = UpdateFieldsOptions;
var FieldsWaitingForUpdate = (function () {
    function FieldsWaitingForUpdate(modelManager, layoutFormatterManager, requestManager, subDocumentIntervals, options, callback) {
        var _this = this;
        this.infoForFutureUpdate = [];
        this.savedSelectionIntervals = [];
        this.modelManager = modelManager;
        this.layoutFormatterManager = layoutFormatterManager;
        this.requestManager = requestManager;
        this.callback = callback;
        this.subDocument = subDocumentIntervals.subDocument;
        this.options = options;
        this.infoForFutureUpdate = list_1.ListUtils.map(subDocumentIntervals.intervals, function (interval) {
            return new FieldParsersAndIntervals(new linked_interval_1.LinkedInterval(_this.subDocument.positionManager, interval));
        });
        this.savedSelectionIntervals = list_1.ListUtils.map(subDocumentIntervals.intervals, function (interval) {
            return new linked_interval_1.LinkedInterval(_this.subDocument.positionManager, interval);
        });
    }
    Object.defineProperty(FieldsWaitingForUpdate.prototype, "fields", {
        get: function () { return this.subDocument.fields; },
        enumerable: true,
        configurable: true
    });
    FieldsWaitingForUpdate.prototype.update = function (response, immediateSendRequest) {
        if (immediateSendRequest === void 0) { immediateSendRequest = true; }
        if (this.fields.length == 0) {
            this.endAction();
            return;
        }
        this.requestManager.checkResponse(this.subDocument, response);
        this.requestManager.clear(this.subDocument);
        var countUpdatedInfos = 0;
        for (var infoIndex = 0, info; info = this.infoForFutureUpdate[infoIndex]; infoIndex++) {
            if (info.updated) {
                countUpdatedInfos++;
                continue;
            }
            if (info.parsers.length > 0) {
                if (this.continueUpdateCurrentInterval(info.parsers, response)) {
                    info.updated = true;
                    countUpdatedInfos++;
                }
                continue;
            }
            var fieldIndex = Math.max(0, field_1.Field.normedBinaryIndexOf(this.fields, info.interval.start + 1));
            var field = this.fields[fieldIndex];
            while (!field.getAllFieldInterval().containsWithIntervalEnd(info.interval.start) && field.parent)
                field = field.parent;
            var startParent = field.parent;
            var someFieldInCurrentInfoNotUpdated = false;
            for (fieldIndex = field.index; field = this.fields[fieldIndex]; fieldIndex++) {
                var startPos = field.getFieldStartPosition();
                if (startPos > info.interval.end || startPos == info.interval.end && info.interval.length > 0)
                    break;
                if (field.getFieldEndPosition() <= info.interval.start ||
                    (field.parent != null && field.parent != startParent) ||
                    !this.subDocument.isEditable([field.getAllFieldInterval()]))
                    continue;
                var fieldParser = FieldsWaitingForUpdate.getParser(this.modelManager, this.layoutFormatterManager, this.requestManager, this.subDocument, field);
                if (fieldParser) {
                    if (!this.options.updateToc && fieldParser instanceof field_code_parser_toc_1.FieldCodeParserToc ||
                        !this.options.updateFillIn && fieldParser instanceof fill_in_1.FieldCodeParserFillIn) {
                        var skipAllBefore = field.getFieldEndPosition();
                        fieldParser.destructor();
                        for (var ind = fieldIndex + 1; field = this.fields[ind]; ind++) {
                            if (field.getFieldStartPosition() >= skipAllBefore) {
                                fieldIndex = ind - 1;
                                break;
                            }
                        }
                        continue;
                    }
                    if (!fieldParser.update(response)) {
                        someFieldInCurrentInfoNotUpdated = true;
                        info.parsers.push(fieldParser);
                    }
                    else
                        fieldParser.destructor();
                }
                else {
                    this.modelManager.modelManipulator.range.removeInterval(new sub_document_1.SubDocumentInterval(this.subDocument, field.getResultInterval()), true, false);
                    field_code_parser_1.FieldCodeParser.finalAction(this.layoutFormatterManager, field, this.subDocument);
                }
            }
            if (!someFieldInCurrentInfoNotUpdated) {
                info.updated = true;
                countUpdatedInfos++;
            }
        }
        if (this.infoForFutureUpdate.length != countUpdatedInfos)
            this.requestManager.sendRequest(this.subDocument, this.modelManager.richOptions.mailMerge.activeRecordIndex, immediateSendRequest);
        else {
            this.requestManager.forceSendDelayedRequests();
            this.endAction();
        }
    };
    FieldsWaitingForUpdate.prototype.endAction = function () {
        var _this = this;
        var selectionIntervals = list_1.ListUtils.map(this.savedSelectionIntervals, function (interval) {
            var fixed = interval.getFixedInterval();
            interval.destructor(_this.subDocument.positionManager);
            return fixed;
        });
        for (var _i = 0, _a = this.infoForFutureUpdate; _i < _a.length; _i++) {
            var info = _a[_i];
            info.destructor(this.subDocument.positionManager);
        }
        this.infoForFutureUpdate = [];
        this.callback(new FieldUpdateResult(new sub_document_1.SubDocumentIntervals(this.subDocument, selectionIntervals)));
    };
    FieldsWaitingForUpdate.prototype.continueUpdateCurrentInterval = function (fieldParsers, response) {
        var allFieldUpdated = true;
        for (var parserIndex = 0, parser; parser = fieldParsers[parserIndex]; parserIndex++) {
            if (parser.update(response)) {
                parser.destructor();
                fieldParsers.splice(parserIndex, 1);
                parserIndex--;
            }
            else
                allFieldUpdated = false;
        }
        return allFieldUpdated;
    };
    FieldsWaitingForUpdate.getParser = function (modelManager, layoutFormatterManager, requestManager, subDocument, field) {
        var modelIterator = new model_iterator_1.ModelIterator(subDocument, false);
        modelIterator.setPosition(field.getCodeStartPosition());
        var result = FieldsWaitingForUpdate.findName(modelIterator);
        var parserConstructor = FieldsWaitingForUpdate.parsersMap[result.fieldName];
        return parserConstructor ?
            parserConstructor({
                modelManager: modelManager,
                layoutFormatterManager: layoutFormatterManager,
                requestManager: requestManager,
                subDocument: subDocument,
                field: field,
                modelIterator: modelIterator,
                fieldNameFirstLetterPosition: result.fieldNameFirstLetterPosition
            }) : null;
    };
    FieldsWaitingForUpdate.findName = function (modelIterator) {
        while (modelIterator.run.getType() == run_type_1.RunType.TextRun && rich_utils_1.RichUtils.isWhitespace.test(modelIterator.getCurrentChar()) ||
            modelIterator.run.getType() == run_type_1.RunType.ParagraphRun ||
            modelIterator.run.getType() == run_type_1.RunType.SectionRun)
            modelIterator.moveToNextChar();
        var fieldNameFirstLetterPosition = modelIterator.getAbsolutePosition();
        var fieldName = "";
        do {
            fieldName += modelIterator.getCurrentChar();
            modelIterator.moveToNextChar();
        } while (modelIterator.run.getType() == run_type_1.RunType.TextRun && !rich_utils_1.RichUtils.isWhitespace.test(modelIterator.getCurrentChar()) &&
            modelIterator.run.getType() != run_type_1.RunType.ParagraphRun && modelIterator.run.getType() != run_type_1.RunType.SectionRun);
        return new FindFieldNameResult(fieldName.toUpperCase(), fieldNameFirstLetterPosition);
    };
    FieldsWaitingForUpdate.TOC_NAME = "TOC";
    FieldsWaitingForUpdate.parsersMap = (_a = {},
        _a["DATE"] = function (args) { return new field_code_parser_date_1.FieldCodeParserDate(args); },
        _a["TIME"] = function (args) { return new field_code_parser_time_1.FieldCodeParserTime(args); },
        _a["DOCVARIABLE"] = function (args) { return new field_code_parser_doc_variable_1.FieldCodeParserDocVariable(args); },
        _a["HYPERLINK"] = function (args) { return new field_code_parser_hyperlink_1.FieldCodeParserHyperlink(args); },
        _a["MERGEFIELD"] = function (args) { return new field_code_parser_merge_field_1.FieldCodeParserMailMerge(args); },
        _a["NUMPAGES"] = function (args) { return new field_code_parser_num_pages_1.FieldCodeParserNumPages(args); },
        _a["PAGE"] = function (args) { return new field_code_parser_page_1.FieldCodeParserPage(args); },
        _a["SEQ"] = function (args) { return new field_code_parser_seq_1.FieldCodeParserSeq(args); },
        _a["TC"] = function (args) { return new field_code_parser_tc_1.FieldCodeParserTc(args); },
        _a[FieldsWaitingForUpdate.TOC_NAME] = function (args) { return new field_code_parser_toc_1.FieldCodeParserToc(args); },
        _a["PAGEREF"] = function (args) { return new field_code_parser_page_ref_1.FieldCodeParserPageRef(args); },
        _a["FILLIN"] = function (args) { return new fill_in_1.FieldCodeParserFillIn(args); },
        _a);
    return FieldsWaitingForUpdate;
}());
exports.FieldsWaitingForUpdate = FieldsWaitingForUpdate;
var FindFieldNameResult = (function () {
    function FindFieldNameResult(fieldName, fieldNameFirstLetterPosition) {
        this.fieldName = fieldName;
        this.fieldNameFirstLetterPosition = fieldNameFirstLetterPosition;
    }
    return FindFieldNameResult;
}());
exports.FindFieldNameResult = FindFieldNameResult;
