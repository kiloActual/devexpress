"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var list_1 = require("@devexpress/utils/lib/utils/list");
var search_1 = require("@devexpress/utils/lib/utils/search");
var intervals_manager_1 = require("../spelling/intervals-manager");
var run_iterator_1 = require("./character/run-iterator");
var document_model_1 = require("./document-model");
var field_1 = require("./fields/field");
var full_chunk_and_run_info_1 = require("./full-chunk-and-run-info");
var bookmarks_manipulator_1 = require("./manipulators/bookmarks-manipulator");
var model_iterator_1 = require("./model-iterator");
var position_manager_1 = require("./position/position-manager");
var rich_utils_1 = require("./rich-utils");
var run_type_1 = require("./runs/run-type");
var SubDocument = (function () {
    function SubDocument(documentModel, subDocumentInfo) {
        this.chunks = [];
        this.paragraphs = [];
        this.fields = [];
        this.tables = [];
        this.tablesByLevels = [];
        this.positionManager = new position_manager_1.PositionManager();
        this.fieldsWaitingForUpdate = null;
        this.bookmarks = [];
        this.rangePermissions = [];
        this.availableRangePermissions = [];
        this.documentModel = documentModel;
        this.id = subDocumentInfo.subDocumentId;
        this.info = subDocumentInfo;
        documentModel.subDocuments[this.id] = this;
        this.spellCheckerIntervalsManager = new intervals_manager_1.SpellCheckerIntervalsManager(this);
    }
    Object.defineProperty(SubDocument.prototype, "interval", {
        get: function () { return new fixed_1.FixedInterval(0, this.getDocumentEndPosition()); },
        enumerable: true,
        configurable: true
    });
    SubDocument.prototype.getLastChunk = function () {
        return this.chunks[this.chunks.length - 1];
    };
    SubDocument.prototype.getFirstChunk = function () {
        return this.chunks[0];
    };
    SubDocument.prototype.getText = function (interval) {
        if (interval === void 0) { interval = new fixed_1.FixedInterval(0, this.getDocumentEndPosition()); }
        var buffer = "";
        var chunkIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.chunks, function (c) { return c.startLogPosition.value; }, interval.start);
        var chunk = this.chunks[chunkIndex];
        var remainLength = interval.length;
        var offset = interval.start - chunk.startLogPosition.value;
        while (chunk) {
            var length = Math.min(chunk.textBuffer.length - offset, remainLength);
            buffer += chunk.textBuffer.substr(offset, length);
            remainLength -= length;
            if (remainLength === 0)
                break;
            chunk = this.chunks[++chunkIndex];
            offset = 0;
        }
        return buffer;
    };
    SubDocument.prototype.getSimpleText = function (interval) {
        var result = "";
        var pos = interval.start;
        var nested = 0;
        var fieldIndex = field_1.Field.normedBinaryIndexOf(this.fields, pos);
        if (fieldIndex > -1) {
            var field = this.fields[fieldIndex];
            while (field.parent)
                field = field.parent;
            pos = field.getFieldStartPosition();
        }
        var iterator = new model_iterator_1.ModelIterator(this, true);
        iterator.setPosition(pos);
        while (pos < interval.end) {
            switch (iterator.run.getType()) {
                case run_type_1.RunType.FieldCodeStartRun:
                    nested++;
                    break;
                case run_type_1.RunType.FieldCodeEndRun:
                    nested--;
                    break;
                case run_type_1.RunType.TextRun:
                    if (pos >= interval.start && nested == 0)
                        result += iterator.getCurrentChar();
                    break;
            }
            if (!iterator.moveToNextChar())
                break;
            pos = iterator.getAbsolutePosition();
        }
        return result.replace(rich_utils_1.RichUtils.specialCharacters.LineBreak, " ");
    };
    SubDocument.prototype.splitRun = function (position) {
        var info = this.getRunAndIndexesByPosition(position);
        var offset = position - (info.chunk.startLogPosition.value + info.run.startOffset);
        if (offset > 0)
            info.chunk.splitRun(info.runIndex, offset);
    };
    SubDocument.prototype.getLastRun = function () {
        var lastChunk = this.getLastChunk();
        return lastChunk.textRuns[lastChunk.textRuns.length - 1];
    };
    SubDocument.prototype.getFirstRun = function () {
        return this.chunks[0].textRuns[0];
    };
    SubDocument.prototype.getRunIterator = function (interval) {
        return this.getRunIteratorInternal(interval, false);
    };
    SubDocument.prototype.getConstRunIterator = function (interval) {
        return this.getRunIteratorInternal(interval, true);
    };
    SubDocument.prototype.getRunIteratorInternal = function (interval, isConstRunIterator) {
        if (interval.length == 0)
            return new run_iterator_1.RunIterator([], [], [], [1], [1]);
        var runs = [], chunks = [], sections = [], indexForChunks = [], indexForSections = [];
        var currentChunkIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.chunks, function (c) { return c.startLogPosition.value; }, interval.start), currentChunk = this.chunks[currentChunkIndex];
        chunks.push(currentChunk);
        var currentRunIndex = search_1.SearchUtils.normedInterpolationIndexOf(currentChunk.textRuns, function (r) { return currentChunk.startLogPosition.value + r.startOffset; }, interval.start), currentRun = currentChunk.textRuns[currentRunIndex], remainIntervalLength = interval.length;
        if (currentChunk.startLogPosition.value + currentRun.startOffset < interval.start) {
            if (isConstRunIterator)
                remainIntervalLength += interval.start - (currentChunk.startLogPosition.value + currentRun.startOffset);
            else {
                currentChunk.splitRun(currentRunIndex, interval.start - (currentChunk.startLogPosition.value + currentRun.startOffset));
                currentRunIndex++;
            }
        }
        var currentSectionIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.documentModel.sections, function (s) { return s.startLogPosition.value; }, interval.start);
        var currentSection = this.documentModel.sections[currentSectionIndex];
        sections.push(currentSection);
        var runIndex = 0;
        var sectionIndex = 0;
        var remainSectionLength = currentSection.startLogPosition.value + currentSection.getLength() - interval.start;
        while (currentRun = currentChunk.textRuns[currentRunIndex]) {
            if (remainSectionLength === 0 && this.isMain()) {
                currentSectionIndex++;
                currentSection = this.documentModel.sections[currentSectionIndex];
                sections.push(currentSection);
                indexForSections.push(sectionIndex - 1);
                remainSectionLength = currentSection.getLength();
            }
            if (currentRun.getLength() > remainIntervalLength) {
                if (isConstRunIterator) {
                    runs.push(currentRun.createSimularity(Math.max(currentRun.startOffset, interval.start - currentChunk.startLogPosition.value), Math.min(remainIntervalLength, interval.length), currentRun.paragraph, currentRun.characterStyle, currentRun.maskedCharacterProperties));
                }
                else {
                    currentChunk.splitRun(currentRunIndex, remainIntervalLength);
                    runs.push(currentRun);
                }
                break;
            }
            if (runIndex == 0 && isConstRunIterator && currentRun.startOffset + currentChunk.startLogPosition.value < interval.start) {
                var runEndPosition = currentChunk.startLogPosition.value + currentRun.startOffset + currentRun.getLength(), newRunLength = runEndPosition - interval.start;
                runs.push(currentRun.createSimularity(interval.start - currentChunk.startLogPosition.value, newRunLength, currentRun.paragraph, currentRun.characterStyle, currentRun.maskedCharacterProperties));
                remainSectionLength -= newRunLength;
            }
            else {
                runs.push(currentRun);
                remainSectionLength -= currentRun.getLength();
            }
            remainIntervalLength -= currentRun.getLength();
            currentRunIndex++;
            if (!remainIntervalLength)
                break;
            if (currentRunIndex == currentChunk.textRuns.length) {
                currentChunkIndex++;
                indexForChunks.push(runIndex);
                currentChunk = this.chunks[currentChunkIndex];
                chunks.push(currentChunk);
                currentRunIndex = 0;
            }
            sectionIndex++;
            runIndex++;
        }
        indexForChunks.push(runIndex + 1);
        indexForSections.push(sectionIndex + 1);
        return new run_iterator_1.RunIterator(runs, chunks, sections, indexForChunks, indexForSections);
    };
    SubDocument.prototype.getRunsByInterval = function (interval) {
        var runs = [];
        var chunkIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.chunks, function (c) { return c.startLogPosition.value; }, interval.start);
        var chunk = this.chunks[chunkIndex];
        var runIndex = search_1.SearchUtils.normedInterpolationIndexOf(chunk.textRuns, function (r) { return chunk.startLogPosition.value + r.startOffset; }, interval.start);
        var run;
        var length = interval.length;
        var runOffset = interval.start - chunk.textRuns[runIndex].startOffset - chunk.startLogPosition.value;
        while (chunk && (run = chunk.textRuns[runIndex])) {
            runs.push(run);
            length -= (run.getLength() - runOffset);
            if (length <= 0)
                break;
            runIndex++;
            if (runIndex >= chunk.textRuns.length) {
                runIndex = 0;
                chunkIndex++;
                chunk = this.chunks[chunkIndex];
            }
            runOffset = 0;
        }
        return runs;
    };
    SubDocument.prototype.getRunByPosition = function (position) {
        var chunkIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.chunks, function (c) { return c.startLogPosition.value; }, position);
        var chunk = this.chunks[chunkIndex];
        var runIndex = search_1.SearchUtils.normedInterpolationIndexOf(chunk.textRuns, function (r) { return chunk.startLogPosition.value + r.startOffset; }, position);
        return chunk.textRuns[runIndex];
    };
    SubDocument.prototype.getRunAndIndexesByPosition = function (position) {
        var chunkIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.chunks, function (c) { return c.startLogPosition.value; }, position);
        var chunk = this.chunks[chunkIndex];
        var runOffset = position - chunk.startLogPosition.value;
        var runIndex = search_1.SearchUtils.normedInterpolationIndexOf(chunk.textRuns, function (r) { return r.startOffset; }, runOffset);
        var run = chunk.textRuns[runIndex];
        return new full_chunk_and_run_info_1.FullChunkAndRunInfo(chunkIndex, chunk, runIndex, run, runOffset - run.startOffset);
    };
    SubDocument.prototype.getSectionByPosition = function (position) {
        return this.documentModel.sections[search_1.SearchUtils.normedInterpolationIndexOf(this.documentModel.sections, function (s) { return s.startLogPosition.value; }, position)];
    };
    SubDocument.prototype.getParagraphByPosition = function (position) {
        return this.paragraphs[search_1.SearchUtils.normedInterpolationIndexOf(this.paragraphs, function (p) { return p.startLogPosition.value; }, position)];
    };
    SubDocument.prototype.getParagraphIndexByPosition = function (position) {
        return search_1.SearchUtils.normedInterpolationIndexOf(this.paragraphs, function (p) { return p.startLogPosition.value; }, position);
    };
    SubDocument.prototype.getParagraphsIndices = function (interval) {
        var endPosition = interval.end;
        var result = fixed_1.FixedInterval.fromPositions(search_1.SearchUtils.normedInterpolationIndexOf(this.paragraphs, function (paragraph) { return paragraph.startLogPosition.value; }, interval.start), search_1.SearchUtils.normedInterpolationIndexOf(this.paragraphs, function (paragraph) { return paragraph.startLogPosition.value; }, endPosition));
        if (endPosition > this.paragraphs[result.end].startLogPosition.value)
            result.length++;
        return result;
    };
    SubDocument.prototype.getParagraphsByInterval = function (interval) {
        var paragraphs = [], intervalEnd = interval.end, paragraphIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.paragraphs, function (p) { return p.startLogPosition.value; }, interval.start);
        paragraphs.push(this.paragraphs[paragraphIndex++]);
        for (var paragraph; paragraph = this.paragraphs[paragraphIndex]; paragraphIndex++) {
            if (paragraph.startLogPosition.value < intervalEnd)
                paragraphs.push(paragraph);
            else
                break;
        }
        return paragraphs;
    };
    SubDocument.prototype.getParagraphIndicesByIntervals = function (intervals) {
        var result = [];
        for (var i = 0, interval; interval = intervals[i]; i++) {
            var paragraphIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.paragraphs, function (p) { return p.startLogPosition.value; }, interval.start);
            var intervalEnd = interval.end;
            result.push(paragraphIndex++);
            for (var paragraph = void 0; paragraph = this.paragraphs[paragraphIndex]; paragraphIndex++) {
                if (paragraph.startLogPosition.value < intervalEnd)
                    result.push(paragraphIndex);
                else
                    break;
            }
        }
        return list_1.ListUtils.uniqueNumber(result);
    };
    SubDocument.prototype.getDocumentEndPosition = function () {
        return this.info.getEndPosition(this.documentModel);
    };
    SubDocument.prototype.getWholeWordInterval = function (position, checkRunProperties, includeBounds) {
        if (checkRunProperties === void 0) { checkRunProperties = false; }
        if (includeBounds === void 0) { includeBounds = false; }
        var interval = new fixed_1.FixedInterval(position, 0);
        if (!includeBounds && (position == this.getDocumentEndPosition() || position == 0))
            return interval;
        var chunkIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.chunks, function (c) { return c.startLogPosition.value; }, position);
        var runOffset = position - this.chunks[chunkIndex].startLogPosition.value;
        var runIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.chunks[chunkIndex].textRuns, function (r) { return r.startOffset; }, runOffset);
        var end = this.getWordEnd(position, checkRunProperties, chunkIndex, runIndex);
        if (end == position && !includeBounds)
            return interval;
        var start = this.getWordStart(position, checkRunProperties, this.chunks[chunkIndex].textRuns[runIndex]);
        if (start == position && !includeBounds)
            return interval;
        interval.start = start;
        interval.length = end - start;
        return interval;
    };
    SubDocument.prototype.getWordStart = function (position, checkRunProperties, prevRun) {
        if (position <= 0)
            return position;
        var start = position;
        position--;
        var chunkIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.chunks, function (c) { return c.startLogPosition.value; }, position);
        var chunk = this.chunks[chunkIndex];
        var runIndex = search_1.SearchUtils.normedInterpolationIndexOf(chunk.textRuns, function (r) { return r.startOffset; }, (position - chunk.startLogPosition.value));
        var run = chunk.textRuns[runIndex];
        while (chunk && run && run.getType() === run_type_1.RunType.TextRun && chunk.textBuffer[position - chunk.startLogPosition.value].match(rich_utils_1.RichUtils.isAlphanumeric) &&
            (!checkRunProperties || prevRun === run || prevRun.maskedCharacterProperties.equals(run.maskedCharacterProperties))) {
            start = position;
            position--;
            if (position - chunk.startLogPosition.value - run.startOffset < 0) {
                prevRun = run;
                runIndex--;
                if (runIndex >= 0)
                    run = chunk.textRuns[runIndex];
                else {
                    chunk = this.chunks[--chunkIndex];
                    if (!chunk)
                        break;
                    runIndex = chunk.textRuns.length - 1;
                    run = chunk.textRuns[runIndex];
                }
            }
        }
        return start;
    };
    SubDocument.prototype.getWordEnd = function (position, checkRunProperties, chunkIndex, runIndex) {
        if (position == this.getDocumentEndPosition())
            return position;
        var chunk = this.chunks[chunkIndex];
        var run = chunk.textRuns[runIndex];
        var end = position;
        var prevRun = run;
        while (chunk && run && run.getType() === run_type_1.RunType.TextRun && chunk.textBuffer[position - chunk.startLogPosition.value].match(rich_utils_1.RichUtils.isAlphanumeric) &&
            (!checkRunProperties || prevRun === run || prevRun.maskedCharacterProperties.equals(run.maskedCharacterProperties))) {
            position++;
            end = position;
            if (position === chunk.startLogPosition.value + run.startOffset + run.getLength()) {
                prevRun = run;
                run = chunk.textRuns[++runIndex];
                if (!run) {
                    chunk = this.chunks[++chunkIndex];
                    if (chunk) {
                        runIndex = 0;
                        run = chunk.textRuns[runIndex];
                    }
                    else
                        break;
                }
            }
        }
        return end;
    };
    SubDocument.prototype.resetMergedFormattingCache = function (type, interval) {
        if (interval === void 0) { interval = new fixed_1.FixedInterval(0, this.getDocumentEndPosition()); }
        var parInd = this.getParagraphsIndices(interval);
        if (type & document_model_1.ResetFormattingCacheType.Paragraph)
            list_1.ListUtils.forEach(this.paragraphs, function (paragraph) { return paragraph.resetParagraphMergedProperties(); }, parInd.start, parInd.end);
        var startInfo = this.getRunAndIndexesByPosition(interval.start);
        var endInfo = this.getRunAndIndexesByPosition(interval.end);
        if (type & document_model_1.ResetFormattingCacheType.Character) {
            var runIndex_1 = startInfo.runIndex;
            list_1.ListUtils.forEach(this.chunks, function (chunk) {
                list_1.ListUtils.allOf(chunk.textRuns, function (run) {
                    run.resetCharacterMergedProperties();
                    return endInfo.run != run;
                }, runIndex_1);
                runIndex_1 = 0;
            }, startInfo.chunkIndex, endInfo.chunkIndex + 1);
        }
        return fixed_1.FixedInterval.fromPositions(this.paragraphs[parInd.start].startLogPosition.value, this.paragraphs[Math.max(parInd.start, parInd.end - 1)].getEndPosition());
    };
    SubDocument.prototype.isEditable = function (intervals) {
        var _this = this;
        return !this.documentModel.isDocumentProtectionEnabled || list_1.ListUtils.allOf(intervals, function (interval) {
            if (interval.end == _this.getDocumentEndPosition())
                interval = interval.makeByStartLength(interval.start, interval.length - 1);
            return list_1.ListUtils.unsafeAnyOf(_this.availableRangePermissions, function (rangePermission) {
                return rangePermission.interval.containsInterval(interval);
            });
        });
    };
    SubDocument.prototype.filterRangePermissions = function (protectionSettings) {
        this.availableRangePermissions = this.documentModel.isDocumentProtectionEnabled ?
            list_1.ListUtils.reducedMap(this.rangePermissions, function (permission) { return permission.isGranted(protectionSettings) ? permission : null; }) :
            list_1.ListUtils.shallowCopy(this.rangePermissions);
    };
    SubDocument.prototype.clone = function (model) {
        var result = new SubDocument(model, this.info.clone());
        result.paragraphs = list_1.ListUtils.map(this.paragraphs, function (p) { return p.clone(result); });
        result.chunks = list_1.ListUtils.map(this.chunks, function (c) { return c.clone(result); });
        result.fields = list_1.ListUtils.map(this.fields, function (f) { return f.clone(result); });
        result.fields.forEach(function (f) { return f.initParent(result.fields); });
        for (var _i = 0, _a = this.tables; _i < _a.length; _i++) {
            var t = _a[_i];
            result.tables.push(t.clone(result));
        }
        result.bookmarks = list_1.ListUtils.map(this.bookmarks, function (b) { return b.clone(result); });
        result.availableRangePermissions = list_1.ListUtils.map(this.availableRangePermissions, function (rp) { return rp.clone(result.positionManager); });
        result.rangePermissions = list_1.ListUtils.map(this.rangePermissions, function (rp) { return rp.clone(result.positionManager); });
        return result;
    };
    SubDocument.prototype.isMain = function () { return this.info.isMain; };
    SubDocument.prototype.isHeaderFooter = function () { return this.info.isHeaderFooter; };
    SubDocument.prototype.isFooter = function () { return this.info.isFooter; };
    SubDocument.prototype.isHeader = function () { return this.info.isHeader; };
    SubDocument.prototype.isNote = function () { return this.info.isNote; };
    SubDocument.prototype.isFootNote = function () { return this.info.isFootNote; };
    SubDocument.prototype.isEndNote = function () { return this.info.isEndNote; };
    SubDocument.prototype.isTextBox = function () { return this.info.isTextBox; };
    SubDocument.prototype.isComment = function () { return this.info.isComment; };
    SubDocument.prototype.isReferenced = function () { return this.info.isReferenced; };
    SubDocument.prototype.getParagraphProperties = function (paragraph) {
        return paragraph.getParagraphMergedProperties();
    };
    SubDocument.prototype.findBookmarkByInterval = function (intervals, searchHidden) {
        if (searchHidden === void 0) { searchHidden = true; }
        var bkms = [];
        algorithms_1.IntervalAlgorithms.handleAffectedObjects(this.bookmarks, algorithms_1.IntervalAlgorithms.getMergedIntervals(intervals, true), function (bkm, _index, interval, intersection) {
            if ((searchHidden || !bkm.isHidden()) && (intersection.length || bkm.length == 0 || intersection.start == bkm.start ||
                (interval.length == 0 && interval.start < bkm.end)))
                bkms.push(bkm);
        }, bookmarks_manipulator_1.BookmarksManipulator.findBookmarkStartIndex);
        return bkms;
    };
    SubDocument.AUTOGENERATE_ID = -1;
    SubDocument.MAIN_SUBDOCUMENT_ID = 0;
    return SubDocument;
}());
exports.SubDocument = SubDocument;
var SubDocumentPosition = (function () {
    function SubDocumentPosition(subDocument, position) {
        this.subDocument = subDocument;
        this.position = position;
    }
    SubDocumentPosition.prototype.validateInterval = function () {
        var docEnd = this.subDocument.getDocumentEndPosition();
        this.position = Math.min(docEnd - 1, this.position);
    };
    SubDocumentPosition.prototype.clone = function () {
        return new SubDocumentPosition(this.subDocument, this.position);
    };
    SubDocumentPosition.prototype.equals = function (obj) {
        return obj &&
            this.subDocument.id == obj.subDocument.id &&
            this.position == obj.position;
    };
    return SubDocumentPosition;
}());
exports.SubDocumentPosition = SubDocumentPosition;
var SubDocumentInterval = (function () {
    function SubDocumentInterval(subDocument, interval) {
        this.subDocument = subDocument;
        this.interval = interval;
    }
    SubDocumentInterval.fromPosition = function (subDocument, position) {
        return new SubDocumentInterval(subDocument, new fixed_1.FixedInterval(position, 0));
    };
    SubDocumentInterval.prototype.clone = function () {
        return new SubDocumentInterval(this.subDocument, this.interval.clone());
    };
    SubDocumentInterval.prototype.validateInterval = function () {
        var docEnd = this.subDocument.getDocumentEndPosition();
        if (this.interval.start == 0 && this.interval.end == docEnd)
            return;
        this.interval.start = Math.min(docEnd, this.interval.start);
        this.interval.end = Math.min(docEnd, this.interval.end);
    };
    SubDocumentInterval.prototype.equals = function (obj) {
        return obj &&
            this.subDocument.id == obj.subDocument.id &&
            this.interval.equals(obj.interval);
    };
    return SubDocumentInterval;
}());
exports.SubDocumentInterval = SubDocumentInterval;
var SubDocumentIntervals = (function () {
    function SubDocumentIntervals(subDocument, intervals) {
        this.subDocument = subDocument;
        this.intervals = intervals;
    }
    Object.defineProperty(SubDocumentIntervals.prototype, "multiselection", {
        get: function () { return this.intervals.length > 1; },
        enumerable: true,
        configurable: true
    });
    SubDocumentIntervals.prototype.validateInterval = function () {
        var docEnd = this.subDocument.getDocumentEndPosition();
        for (var _i = 0, _a = this.intervals; _i < _a.length; _i++) {
            var curr = _a[_i];
            if (curr.start == 0 && curr.end == docEnd)
                continue;
            var start = Math.min(docEnd - 1, curr.start);
            var end = Math.min(docEnd - 1, curr.end);
            curr.start = start;
            curr.end = end;
        }
    };
    SubDocumentIntervals.prototype.clone = function () {
        return new SubDocumentIntervals(this.subDocument, list_1.ListUtils.deepCopy(this.intervals));
    };
    SubDocumentIntervals.prototype.equals = function (obj) {
        return obj &&
            this.subDocument.id == obj.subDocument.id &&
            obj.intervals && list_1.ListUtils.equals(this.intervals, obj.intervals);
    };
    SubDocumentIntervals.fromPosition = function (subDocument, pos) {
        return new SubDocumentIntervals(subDocument, [new fixed_1.FixedInterval(pos, 0)]);
    };
    return SubDocumentIntervals;
}());
exports.SubDocumentIntervals = SubDocumentIntervals;
