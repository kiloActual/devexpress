import { Size } from '@devexpress/utils/lib/geometry/size';
import { PictureManipulator } from '../manipulators/picture-manipulator/picture-manipulator';
export declare class CacheImageInfo {
    private static emptyPicDimension;
    private _referenceInfo?;
    private _base64?;
    private _size?;
    private _isLoaded;
    tmpId?: number;
    actualId?: number;
    imageUrl?: string;
    file?: File;
    constructor(base64?: string, actualId?: number, tmpId?: number, imageUrl?: string, file?: File, referenceInfo?: CacheImageInfo, size?: Size, isLoaded?: boolean);
    equals(obj: CacheImageInfo): boolean;
    clone(): CacheImageInfo;
    readonly emptyPictureSize: Size;
    isLoaded: boolean;
    size: Size;
    readonly currId: number;
    base64: string | undefined;
    referenceInfo: CacheImageInfo | undefined;
}
export declare class ImageCache {
    private static transparentWhiteImage1_1;
    private cache;
    readonly emptyImageId: number;
    private lastTmpId;
    private lastActualId;
    constructor();
    getPictureData(id: number): CacheImageInfo;
    createUnloadedInfoByUrl(imageUrl: string, size?: Size): CacheImageInfo;
    createUnloadedInfoByFile(file: File): CacheImageInfo;
    registerFromAnotherModel(imageInfo: CacheImageInfo): void;
    createUnloadedInfoByBase64(base64: string, size?: Size): CacheImageInfo;
    createLoadedInfo(base64: string, size: Size, id?: number): CacheImageInfo;
    createUnloadedByBase64OrUrl(data: string, size?: Size): CacheImageInfo;
    finalizeLoading(existingInfo: CacheImageInfo, loadedInfo: CacheImageInfo): void;
    getNextActualId(): number;
    isDataRegistered(data: CacheImageInfo): boolean;
    registerPictureData(data: CacheImageInfo): CacheImageInfo;
    loadAllPictures(picture: PictureManipulator): void;
    private findInfoByBase64;
    private findInfoByUrl;
    private origSizeCorrect;
    clone(): ImageCache;
    readonly emptyImage: CacheImageInfo;
}
//# sourceMappingURL=images.d.ts.map
