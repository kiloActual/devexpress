"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var list_1 = require("@devexpress/utils/lib/utils/list");
var Chunk = (function () {
    function Chunk(startLogPosition, textBuffer, isLast) {
        this.textBuffer = "";
        this.textRuns = [];
        this.startLogPosition = startLogPosition;
        this.textBuffer = textBuffer;
        this.isLast = isLast;
    }
    Chunk.prototype.getEndPosition = function () {
        return this.startLogPosition.value + this.textBuffer.length;
    };
    Chunk.prototype.getRunText = function (run) {
        return this.textBuffer.substr(run.startOffset, run.getLength());
    };
    Chunk.prototype.getTextInChunk = function (offsetAtStartChunk, length) {
        return this.textBuffer.substr(offsetAtStartChunk, length);
    };
    Chunk.prototype.splitRun = function (runIndex, offset) {
        var run = this.textRuns[runIndex];
        if (!run)
            throw new Error("Undefined run");
        if (offset >= run.getLength())
            throw new Error("Offset >= run.length");
        var newRun = run.createSimularity(run.startOffset + offset, run.getLength() - offset, run.paragraph, run.characterStyle, run.maskedCharacterProperties);
        run.setLength(offset);
        this.textRuns.splice(runIndex + 1, 0, newRun);
    };
    Chunk.prototype.clone = function (subDocument) {
        var result = new Chunk(subDocument.positionManager.registerPosition(this.startLogPosition.value), this.textBuffer.slice(0), this.isLast);
        result.textRuns = list_1.ListUtils.map(this.textRuns, function (r) { return r.cloneToNewSubDocument(subDocument); });
        return result;
    };
    return Chunk;
}());
exports.Chunk = Chunk;
