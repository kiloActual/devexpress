"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var flag_1 = require("@devexpress/utils/lib/class/flag");
var font_info_cache_1 = require("../caches/hashed-caches/font-info-cache");
var control_font_1 = require("../fonts/control-font");
var font_face_descriptors_1 = require("../fonts/font-face-descriptors");
var font_info_1 = require("../fonts/font-info");
var google_fonts_1 = require("../fonts/google-fonts");
var cache_1 = require("./cache");
var FontCorrector = (function () {
    function FontCorrector(modelManipulator, model, fonts) {
        this.modelManipulator = modelManipulator;
        this.model = model;
        this.fonts = fonts;
    }
    Object.defineProperty(FontCorrector.prototype, "fontInfoCache", {
        get: function () {
            return this.model.cache.fontInfoCache;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FontCorrector.prototype, "controlFontsCache", {
        get: function () {
            return this.model.cache.controlFontsCache;
        },
        enumerable: true,
        configurable: true
    });
    FontCorrector.prototype.correct = function () {
        this.addAndLoad();
        new cache_1.ModelCacheFiller(this.model, this.fonts).fillCache();
        this.removeRedundant();
        this.modelManipulator.raiseFontListChanged(this.fontInfoCache);
    };
    FontCorrector.prototype.addAndLoad = function () {
        var _this = this;
        this.fonts.fonts.forEach(function (font) {
            var newFont = _this.fontInfoCache.getItemByName(font.name);
            if (!newFont)
                newFont = _this.fontInfoCache.addFont(font.name, font.fontFamily);
            else
                newFont.cssString = font_info_cache_1.FontInfoCache.correctCssString(font.fontFamily);
            var addControlFont = function (uri, desc) {
                var controlFont = _this.controlFontsCache.addFont(new control_font_1.ControlFont(font.fontFamily, desc));
                controlFont.sourceUrls.unshift(uri);
                var controlFontType = new flag_1.Flag();
                controlFontType.set(font_info_1.ControlFontType.Bold, controlFont.descriptors.msWordBold());
                controlFontType.set(font_info_1.ControlFontType.Italic, controlFont.descriptors.msWordItalic());
                newFont.controlFontMap[controlFontType.getValue()] = controlFont.cacheKey;
            };
            if (font.regularFontUri)
                addControlFont(font.regularFontUri, font_face_descriptors_1.FontFaceDescriptors.create({}));
            if (font.boldFontUri)
                addControlFont(font.boldFontUri, font_face_descriptors_1.FontFaceDescriptors.create({ weight: 'bold' }));
            if (font.italicFontUri)
                addControlFont(font.italicFontUri, font_face_descriptors_1.FontFaceDescriptors.create({ style: 'italic' }));
            if (font.boldItalicFontUri)
                addControlFont(font.boldItalicFontUri, font_face_descriptors_1.FontFaceDescriptors.create({ weight: 'bold', style: 'italic' }));
            if (font.googleFontsResponse)
                new google_fonts_1.GoogleFontsApi(_this.controlFontsCache, [newFont]).parseResponce(font.googleFontsResponse);
            else if (font.useGoogleFonts)
                new google_fonts_1.GoogleFontsApi(_this.controlFontsCache, [newFont]).loadControlFonts(function (_createdFonts) { });
        });
    };
    FontCorrector.prototype.removeRedundant = function () {
        if (this.fonts.limitedFonts) {
            var map_1 = {};
            this.fonts.fonts.forEach(function (f) { return map_1[f.name] = f; });
            this.fontInfoCache.removeItems(function (font) { return !map_1[font.name]; });
        }
    };
    return FontCorrector;
}());
exports.FontCorrector = FontCorrector;
