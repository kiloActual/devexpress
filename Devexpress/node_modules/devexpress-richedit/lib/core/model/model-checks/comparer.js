"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var list_1 = require("@devexpress/utils/lib/utils/list");
var run_type_1 = require("../runs/run-type");
var check_all_1 = require("./check-all");
var enums_1 = require("../section/enums");
var hexadecimal_converter_1 = require("../../../base-utils/hexadecimal-converter");
var extension_helper_1 = require("../../formats/utils/extension-helper");
var color_1 = require("@devexpress/utils/lib/utils/color");
var document_format_1 = require("../../document-format");
var dx_color_1 = require("../color/dx-color");
var ModelComparer = (function () {
    function ModelComparer(model, target, format) {
        if (format === void 0) { format = null; }
        this.results = [];
        this.pictureSizeAccuracy = 5;
        this.nextRowMark = "\n    ";
        this.source = model;
        this.target = target;
        this.format = format;
    }
    ModelComparer.prototype.compareAll = function () {
        this.compare([
            this.compareSubDocuments
        ]);
        return !this.results.length;
    };
    ModelComparer.prototype.compare = function (comparers) {
        for (var _i = 0, comparers_1 = comparers; _i < comparers_1.length; _i++) {
            var comparer = comparers_1[_i];
            var result = comparer.call(this);
            if (result != check_all_1.ModelCheckerResult.None && result !== null) {
                this.results.push(result);
                console.log(this.consoleErrorMessage);
                break;
            }
        }
    };
    ModelComparer.prototype.compareSubDocuments = function () {
        var _this = this;
        this.consoleErrorMessage = 'fail comparing into' + this.nextRowMark;
        var result = this.compareSubDocumentsCore(this.source.mainSubDocument, this.target.mainSubDocument);
        if (result)
            return result;
        result = list_1.ListUtils.unsafeAnyOf(this.source.sections, function (section, index) {
            return _this.compareSection(section, _this.target.sections[index]);
        });
        if (result)
            return result;
        return check_all_1.ModelCheckerResult.None;
    };
    ModelComparer.prototype.compareSection = function (source, target) {
        var result = this.compareHeadersFooters(source.headers, target.headers);
        if (!result)
            result = this.compareHeadersFooters(source.footers, target.footers);
        return result;
    };
    ModelComparer.prototype.compareHeadersFooters = function (source, target) {
        var result = this.compareHeaderFooter(source, target, enums_1.HeaderFooterType.Even);
        if (!result)
            result = this.compareHeaderFooter(source, target, enums_1.HeaderFooterType.Odd);
        if (!result)
            result = this.compareHeaderFooter(source, target, enums_1.HeaderFooterType.First);
        return result;
    };
    ModelComparer.prototype.compareHeaderFooter = function (source, target, type) {
        var sourceObj = source.getObject(type);
        var targetObj = target.getObject(type);
        if (!sourceObj && !targetObj)
            return check_all_1.ModelCheckerResult.None;
        if (!sourceObj || !targetObj)
            return check_all_1.ModelCheckerResult.Section;
        return this.compareSubDocumentsCore(sourceObj.getSubDocument(this.source), targetObj.getSubDocument(this.target));
    };
    ModelComparer.prototype.compareSubDocumentsCore = function (source, target) {
        var _this = this;
        this.consoleErrorMessage += 'SubDoc id = ' + source.id + ' is header: ' + source.isHeader() + ' is footer: ' + source.isFooter() + this.nextRowMark;
        if (!source || !target)
            return check_all_1.ModelCheckerResult.SubDocument;
        if (source.chunks.length != target.chunks.length)
            return check_all_1.ModelCheckerResult.SubDocument;
        return list_1.ListUtils.unsafeAnyOf(source.chunks, function (sourceChunk, index) {
            _this.consoleErrorMessage += 'chunk index = ' + index + _this.nextRowMark;
            return _this.compareChunks(sourceChunk, target.chunks[index]);
        });
    };
    ModelComparer.prototype.countNotLoadedPicture = function (sourceRuns) {
        var _this = this;
        var result = list_1.ListUtils.reducedMap(sourceRuns, function (run) {
            return _this.runShouldBeLostOnExport(run) ? run : null;
        });
        return result.length;
    };
    ModelComparer.prototype.runShouldBeLostOnExport = function (run) {
        var runType = run.getType();
        if (runType == run_type_1.RunType.InlinePictureRun)
            return !run.info.cacheInfo.isLoaded;
        else if (runType == run_type_1.RunType.AnchoredPictureRun)
            return !run.info.cacheInfo.isLoaded;
        return false;
    };
    ModelComparer.prototype.isASCII = function (code) {
        return code >= 0 && code <= 127;
    };
    ModelComparer.prototype.compareChunks = function (sourceChunk, targetChunk) {
        var _this = this;
        this.consoleErrorMessage += 'chunk length = ' + sourceChunk.textRuns.length + this.nextRowMark;
        var hasLostedRuns = sourceChunk.textRuns.length != targetChunk.textRuns.length;
        if (hasLostedRuns && sourceChunk.textRuns.length - this.countNotLoadedPicture(sourceChunk.textRuns) != targetChunk.textRuns.length) {
            if (this.format != document_format_1.DocumentFormat.Rtf || sourceChunk.textBuffer != targetChunk.textBuffer)
                return check_all_1.ModelCheckerResult.Chunk;
        }
        var skippedRunCount = 0;
        var skippedOffset = 0;
        var splitedRunCount = 0;
        return list_1.ListUtils.unsafeAnyOf(sourceChunk.textRuns, function (sourceRun, index) {
            var targetIndex = index - skippedRunCount + splitedRunCount;
            var targetRun = targetChunk.textRuns[targetIndex];
            var problemRun = sourceRun.getType() != targetRun.getType() || sourceRun.startOffset - skippedOffset != targetRun.startOffset ||
                sourceRun.getLength() != targetRun.getLength();
            _this.consoleErrorMessage += 'source run index = ' + index + ' target run index = ' + targetIndex + _this.nextRowMark;
            if (problemRun && hasLostedRuns) {
                if (_this.runShouldBeLostOnExport(sourceRun)) {
                    skippedRunCount++;
                    skippedOffset += sourceRun.getLength();
                    return check_all_1.ModelCheckerResult.None;
                }
                var separatorsCount = 0;
                var runType = sourceRun.getType();
                if (runType == run_type_1.RunType.TextRun) {
                    var text = sourceChunk.getRunText(sourceRun);
                    var length_1 = sourceRun.getLength();
                    var hasNonASCIICharacters = false;
                    for (var i = 0; i < length_1; i++) {
                        if (!_this.isASCII(text.charCodeAt(i))) {
                            hasNonASCIICharacters = true;
                            separatorsCount++;
                        }
                    }
                    if (hasNonASCIICharacters) {
                        if (text.length == separatorsCount)
                            separatorsCount--;
                        if (_this.isASCII(text.charCodeAt(0)) && _this.isASCII(text.charCodeAt(text.length - 1)))
                            separatorsCount++;
                        splitedRunCount += separatorsCount;
                        return check_all_1.ModelCheckerResult.None;
                    }
                }
                return check_all_1.ModelCheckerResult.Run;
            }
            return _this.compareRuns(sourceRun, targetRun, sourceChunk, targetChunk, skippedOffset);
        });
    };
    ModelComparer.prototype.compareRuns = function (sourceRun, targetRun, sourceChunk, targetChunk, skippedOffset) {
        if (sourceRun.getType() != targetRun.getType() || sourceRun.startOffset - skippedOffset != targetRun.startOffset ||
            sourceRun.getLength() != targetRun.getLength() || sourceChunk.getRunText(sourceRun) != targetChunk.getRunText(targetRun) ||
            !this.compareCharacterPropertiesBundle(sourceRun.getCharPropsBundle(this.source), targetRun.getCharPropsBundle(this.target))) {
            this.consoleErrorMessage += 'main run properties comparing failed ' + this.nextRowMark;
            return check_all_1.ModelCheckerResult.Run;
        }
        switch (sourceRun.getType()) {
            case run_type_1.RunType.TextRun:
            case run_type_1.RunType.ParagraphRun:
                return check_all_1.ModelCheckerResult.None;
            case run_type_1.RunType.InlinePictureRun:
                return this.compareInlinePictureRuns(sourceRun, targetRun);
            case run_type_1.RunType.AnchoredPictureRun:
                return this.compareAnchoredPictureRuns(sourceRun, targetRun);
            case run_type_1.RunType.AnchoredTextBoxRun:
                return this.compareAnchoredTextBoxRuns(sourceRun, targetRun);
            default: return check_all_1.ModelCheckerResult.None;
        }
    };
    ModelComparer.prototype.compareCharacterPropertiesBundle = function (sourceProps, targetProps) {
        return this.compareStyles(sourceProps.style, targetProps.style);
    };
    ModelComparer.prototype.compareStyles = function (sourceSize, targetSize) {
        if (!sourceSize || !targetSize)
            return !sourceSize && !targetSize;
        return sourceSize.styleName == targetSize.styleName && sourceSize.deleted == targetSize.deleted &&
            this.compareStyles(sourceSize.parent, targetSize.parent);
    };
    ModelComparer.prototype.compareInlinePictureRuns = function (sourceRun, targetRun) {
        var result = this.comparePictureSize(sourceRun.size, targetRun.size) && this.compareShape(sourceRun.info.shape, targetRun.info.shape) &&
            this.compareNonVisualDrawingObjectInfo(sourceRun.info.containerProperties, targetRun.info.containerProperties);
        this.consoleErrorMessage += 'InlinePicture run properties comparing failed ' + this.nextRowMark;
        return result ? check_all_1.ModelCheckerResult.None : check_all_1.ModelCheckerResult.Run;
    };
    ModelComparer.prototype.compareAnchoredPictureRuns = function (sourceRun, targetRun) {
        var result = this.comparePictureSize(sourceRun.size, targetRun.size) && this.compareShape(sourceRun.info.shape, targetRun.info.shape) &&
            this.compareNonVisualDrawingObjectInfo(sourceRun.info.containerProperties, targetRun.info.containerProperties) &&
            this.compareAnchorInfo(sourceRun.info.anchorInfo, targetRun.info.anchorInfo);
        this.consoleErrorMessage += 'AnchoredPictureRun run properties comparing failed ' + this.nextRowMark;
        return result ? check_all_1.ModelCheckerResult.None : check_all_1.ModelCheckerResult.Run;
    };
    ModelComparer.prototype.compareAnchoredTextBoxRuns = function (sourceRun, targetRun) {
        var result = this.compareTextBoxSize(sourceRun.size, targetRun.size) && this.compareShape(sourceRun.shape, targetRun.shape) &&
            this.compareAnchorInfo(sourceRun.anchorInfo, targetRun.anchorInfo) &&
            this.compareTextBoxProperties(sourceRun.textBoxProperties, targetRun.textBoxProperties);
        this.consoleErrorMessage += 'AnchoredTextBoxRun run properties comparing failed ' + this.nextRowMark;
        return result ? check_all_1.ModelCheckerResult.None : check_all_1.ModelCheckerResult.Run;
    };
    ModelComparer.prototype.compareTextBoxProperties = function (source, target) {
        return source.resizeShapeToFitText == target.resizeShapeToFitText &&
            source.upright == target.upright &&
            source.verticalAlignment == target.verticalAlignment &&
            source.wrapText == target.wrapText &&
            source.leftMargin == target.leftMargin &&
            source.rightMargin == target.rightMargin &&
            source.topMargin == target.topMargin &&
            source.bottomMargin == target.bottomMargin;
    };
    ModelComparer.prototype.compareAnchorInfo = function (source, target) {
        return source.equals(target);
    };
    ModelComparer.prototype.compareTextBoxSize = function (source, target) {
        return source.useAbsoluteHeight() ? true : source.relativeHeightType == target.relativeHeightType &&
            source.useAbsoluteWidth() ? true : source.relativeWidthType == target.relativeWidthType && source.lockAspectRatio == target.lockAspectRatio && source.rotation == target.rotation &&
            this.compareSize(source.relativeSize, target.relativeSize) && this.compareSize(source.absoluteSize, target.absoluteSize);
    };
    ModelComparer.prototype.comparePictureSize = function (source, target) {
        return this.compareSize(source.actualSize, target.actualSize) && source.lockAspectRatio == target.lockAspectRatio &&
            this.compareSize(source.originalSize, target.originalSize) && this.compareSize(source.scale, target.scale) &&
            source.rotation == target.rotation && this.compareCacheInfo(source.cacheInfo, target.cacheInfo);
    };
    ModelComparer.prototype.compareSize = function (sourceSize, targetSize) {
        return Math.abs(sourceSize.width - targetSize.width) < this.pictureSizeAccuracy
            && Math.abs(sourceSize.height - targetSize.height) < this.pictureSizeAccuracy;
    };
    ModelComparer.prototype.compareCacheInfo = function (source, target) {
        return hexadecimal_converter_1.base64ToHex(extension_helper_1.ExtensionHelper.getBase64DataWithoutPrefix(source.base64)) ===
            hexadecimal_converter_1.base64ToHex(extension_helper_1.ExtensionHelper.getBase64DataWithoutPrefix(target.base64)) && this.compareSize(source.size, target.size);
    };
    ModelComparer.prototype.compareShape = function (source, target) {
        var fillColorEquals = color_1.ColorUtils.colorToHash(source.fillColor) == color_1.ColorUtils.colorToHash(target.fillColor) ||
            dx_color_1.DXColor.isTransparentOrEmptyorNoColor(source.fillColor) == dx_color_1.DXColor.isTransparentOrEmptyorNoColor(target.fillColor);
        var hasOutlineColor = !dx_color_1.DXColor.isTransparentOrEmptyorNoColor(source.outlineColor);
        var outlineEquals = source.outlineWidth > 0 && hasOutlineColor ?
            (color_1.ColorUtils.colorToHash(source.outlineColor) == color_1.ColorUtils.colorToHash(target.outlineColor) ||
                dx_color_1.DXColor.isTransparentOrEmptyorNoColor(source.outlineColor) == dx_color_1.DXColor.isTransparentOrEmptyorNoColor(target.outlineColor)) &&
                source.outlineWidth == target.outlineWidth : true;
        return fillColorEquals && outlineEquals;
    };
    ModelComparer.prototype.compareNonVisualDrawingObjectInfo = function (source, target) {
        if (this.format && this.format == document_format_1.DocumentFormat.Rtf)
            return source.description == target.description;
        var isAutogeneratedProperties = !source.name && target.name == 'Picture ' + target.id;
        if (isAutogeneratedProperties)
            return true;
        return source.name == target.name && source.title == target.title && source.description == target.description;
    };
    return ModelComparer;
}());
exports.ModelComparer = ModelComparer;
