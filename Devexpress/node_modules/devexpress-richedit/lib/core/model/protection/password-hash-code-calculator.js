"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var number_converter_1 = require("../../../base-utils/number-converter");
var math_1 = require("@devexpress/utils/lib/utils/math");
var string_1 = require("@devexpress/utils/lib/utils/string");
var document_protection_1 = require("../options/document-protection");
var md5_1 = require("./md5");
var ripemd160_1 = require("./ripemd160");
var sha1_1 = require("./sha1");
var sha256_1 = require("./sha256");
var sha384_1 = require("./sha384");
var sha512_1 = require("./sha512");
var PasswordHashCodeCalculator = (function () {
    function PasswordHashCodeCalculator() {
    }
    PasswordHashCodeCalculator.prototype.getBytes = function (val) {
        return new Uint8Array(new Uint32Array([val]).buffer);
    };
    PasswordHashCodeCalculator.prototype.calculateLegacyPasswordHash = function (password) {
        if (string_1.StringUtils.isNullOrEmpty(password))
            return null;
        return this.getBytes(this.calculateLegacyPasswordHashInt(password));
    };
    PasswordHashCodeCalculator.prototype.calculateLegacyPasswordHashInt = function (password) {
        if (string_1.StringUtils.isNullOrEmpty(password))
            return 0;
        var bytes = this.calculatePasswordBytes(password);
        var high = this.calculateKeyHighWord(bytes);
        var low = this.calculateKeyLowWord(bytes);
        return (((low << 24) & 0xFF000000) | ((low << 8) & 0x00FF0000) | ((high << 8) & 0x0000FF00) | ((high >> 8) & 0x000000FF));
    };
    PasswordHashCodeCalculator.prototype.calculatePasswordHash = function (password, prefix, hashCount, hashAlgorithmType) {
        var hashAlgorithm = this.createHashAlgorithm(hashAlgorithmType);
        if (hashAlgorithm)
            return this.calculatePasswordHashAfterDetectedAlgoritm(password, prefix, hashCount, hashAlgorithm);
        else {
            var legacyPasswordHash = this.calculateLegacyPasswordHashInt(password);
            return this.concatenate(new Uint8Array(0), legacyPasswordHash);
        }
    };
    PasswordHashCodeCalculator.prototype.generatePasswordPrefix = function (length) {
        var result = [];
        for (var i = 0; i < length; i++) {
            result[i] = math_1.MathUtils.getRandomInt(0, 1000);
        }
        return new Uint8Array(result);
    };
    PasswordHashCodeCalculator.prototype.createHashAlgorithm = function (hashAlgorithmType) {
        switch (hashAlgorithmType) {
            case document_protection_1.HashAlgorithmType.Sha1:
                return new sha1_1.SHA1();
            case document_protection_1.HashAlgorithmType.Sha256:
                return new sha256_1.SHA256();
            case document_protection_1.HashAlgorithmType.Sha384:
                return new sha384_1.SHA384();
            case document_protection_1.HashAlgorithmType.Sha512:
                return new sha512_1.SHA512();
            case document_protection_1.HashAlgorithmType.Md5:
                return new md5_1.MD5();
            case document_protection_1.HashAlgorithmType.Ripemd160:
                return new ripemd160_1.RIPEMD160();
            case document_protection_1.HashAlgorithmType.None:
            case document_protection_1.HashAlgorithmType.Mac:
            case document_protection_1.HashAlgorithmType.HMac:
            case document_protection_1.HashAlgorithmType.Ripemd:
            case document_protection_1.HashAlgorithmType.Md2:
            case document_protection_1.HashAlgorithmType.Md4:
            default:
                return null;
        }
    };
    PasswordHashCodeCalculator.prototype.calculatePasswordHashAfterDetectedAlgoritm = function (password, prefix, hashCount, hashAlgorithm) {
        var legacyPasswordHash = this.calculateLegacyPasswordHashInt(password);
        return this.calculatePasswordHashCore(this.getUnicodeArray(number_converter_1.RichNumberConverter.convertToHexBinary(legacyPasswordHash).toUpperCase()), prefix, hashCount, hashAlgorithm);
    };
    PasswordHashCodeCalculator.prototype.getUnicodeArray = function (base64) {
        var n = base64.length;
        var arr = new Uint8Array(n * 2);
        while (n--) {
            var index = n * 2;
            arr[index] = base64.charCodeAt(n);
            arr[index + 1] = 0;
        }
        return arr;
    };
    PasswordHashCodeCalculator.prototype.calculatePasswordHashCore = function (legacyPasswordHash, prefix, hashCount, hashAlgorithm) {
        var bytes = this.concatenateArrays(prefix, legacyPasswordHash);
        var wordArray = this.byteArrayToWordArray(bytes);
        for (var i = 0;;) {
            wordArray = hashAlgorithm.computeHash(wordArray);
            if (i < hashCount) {
                wordArray = this.concatenateArray(wordArray, i);
                i++;
            }
            else
                break;
        }
        return new Uint8Array(this.wordArrayToByteArray(wordArray, wordArray.length));
    };
    PasswordHashCodeCalculator.prototype.byteArrayToWordArray = function (bytes) {
        var result = [];
        for (var i = 0; i < bytes.length; i++)
            result[(i / 4) | 0] |= bytes[i] << (24 - 8 * i);
        return result;
    };
    PasswordHashCodeCalculator.prototype.wordToByteArray = function (word, length) {
        var bytes = [], xFF = 0xFF;
        if (length > 0)
            bytes.push(word >>> 24);
        if (length > 1)
            bytes.push((word >>> 16) & xFF);
        if (length > 2)
            bytes.push((word >>> 8) & xFF);
        if (length > 3)
            bytes.push(word & xFF);
        return bytes;
    };
    PasswordHashCodeCalculator.prototype.wordArrayToByteArray = function (wordArray, length) {
        length = wordArray.length * 4;
        var result = [];
        var bytes;
        var i = 0;
        while (length > 0) {
            bytes = this.wordToByteArray(wordArray[i], Math.min(4, length));
            length -= bytes.length;
            result.push(bytes);
            i++;
        }
        return [].concat.apply([], result);
    };
    PasswordHashCodeCalculator.prototype.concatenateArrays = function (b1, b2) {
        if (b1 == null)
            return b2;
        if (b2 == null)
            return b1;
        var result = new Uint8Array(b1.length + b2.length);
        result.set(b1);
        result.set(b2, b1.length);
        return result;
    };
    PasswordHashCodeCalculator.prototype.concatenate = function (bytes, num) {
        var countBytes = new Array(4);
        countBytes[3] = ((num & 0xFF000000) >> 24);
        countBytes[2] = ((num & 0x00FF0000) >> 16);
        countBytes[1] = ((num & 0x0000FF00) >> 8);
        countBytes[0] = ((num & 0x000000FF));
        var result = new Uint8Array(bytes.length + countBytes.length);
        result.set(bytes);
        result.set(countBytes, bytes.length);
        return result;
    };
    PasswordHashCodeCalculator.prototype.concatenateArray = function (wordArray, num) {
        var countBytes = new Array(4);
        countBytes[3] = (num & 0xFF000000) >> 24;
        countBytes[2] = (num & 0x00FF0000) >> 16;
        countBytes[1] = (num & 0x0000FF00) >> 8;
        countBytes[0] = (num & 0x000000FF);
        var newWordArray = this.byteArrayToWordArray(countBytes);
        return wordArray.concat(newWordArray);
    };
    PasswordHashCodeCalculator.compareByteArrays = function (b1, b2) {
        if (b1 === b2)
            return true;
        if (b1 == null || b2 == null)
            return false;
        if (b1.length != b2.length)
            return false;
        var count = b1.length;
        for (var i = 0; i < count; i++)
            if (b1[i] != b2[i])
                return false;
        return true;
    };
    PasswordHashCodeCalculator.prototype.calculatePasswordBytes = function (password) {
        if (password.length > 15)
            password = password.substr(0, 15);
        var count = password.length;
        var bytes = new Array(count);
        for (var i = 0; i < count; i++) {
            var ch = password.charCodeAt(i);
            if ((ch & 0x00FF) == 0)
                bytes[i] = ch >> 8;
            else
                bytes[i] = ch & 0x00FF;
        }
        return bytes;
    };
    PasswordHashCodeCalculator.prototype.calculateKeyLowWord = function (bytes) {
        var result = 0;
        var count = bytes.length;
        for (var i = count - 1; i >= 0; i--)
            result = this.processLowWordByte(result, bytes[i]);
        result = this.processLowWordByte(result, count) ^ 0xCE4B;
        return result;
    };
    PasswordHashCodeCalculator.prototype.processLowWordByte = function (key, b) {
        return ((((key >> 14) & 0x0001) | ((key << 1) & 0x7FFF)) ^ b);
    };
    PasswordHashCodeCalculator.prototype.calculateKeyHighWord = function (bytes) {
        var count = bytes.length;
        var result = PasswordHashCodeCalculator.initialValues[count - 1];
        for (var i = 0; i < count; i++)
            result = this.processHighWordByte(result, bytes[i], 15 - (count - i));
        return result;
    };
    PasswordHashCodeCalculator.prototype.processHighWordByte = function (key, b, rowIndex) {
        var mask = 1;
        for (var i = 0; i <= 6; i++, mask <<= 1)
            if ((b & mask) != 0)
                key ^= PasswordHashCodeCalculator.encryptionMatrix[rowIndex][i];
        return key;
    };
    PasswordHashCodeCalculator.initialValues = [0xE1F0, 0x1D0F, 0xCC9C, 0x84C0, 0x110C, 0x0E10, 0xF1CE, 0x313E,
        0x1872, 0xE139, 0xD40F, 0x84F9, 0x280C, 0xA96A, 0x4EC3];
    PasswordHashCodeCalculator.encryptionMatrix = [
        [0xAEFC, 0x4DD9, 0x9BB2, 0x2745, 0x4E8A, 0x9D14, 0x2A09],
        [0x7B61, 0xF6C2, 0xFDA5, 0xEB6B, 0xC6F7, 0x9DCF, 0x2BBF],
        [0x4563, 0x8AC6, 0x05AD, 0x0B5A, 0x16B4, 0x2D68, 0x5AD0],
        [0x0375, 0x06EA, 0x0DD4, 0x1BA8, 0x3750, 0x6EA0, 0xDD40],
        [0xD849, 0xA0B3, 0x5147, 0xA28E, 0x553D, 0xAA7A, 0x44D5],
        [0x6F45, 0xDE8A, 0xAD35, 0x4A4B, 0x9496, 0x390D, 0x721A],
        [0xEB23, 0xC667, 0x9CEF, 0x29FF, 0x53FE, 0xA7FC, 0x5FD9],
        [0x47D3, 0x8FA6, 0x0F6D, 0x1EDA, 0x3DB4, 0x7B68, 0xF6D0],
        [0xB861, 0x60E3, 0xC1C6, 0x93AD, 0x377B, 0x6EF6, 0xDDEC],
        [0x45A0, 0x8B40, 0x06A1, 0x0D42, 0x1A84, 0x3508, 0x6A10],
        [0xAA51, 0x4483, 0x8906, 0x022D, 0x045A, 0x08B4, 0x1168],
        [0x76B4, 0xED68, 0xCAF1, 0x85C3, 0x1BA7, 0x374E, 0x6E9C],
        [0x3730, 0x6E60, 0xDCC0, 0xA9A1, 0x4363, 0x86C6, 0x1DAD],
        [0x3331, 0x6662, 0xCCC4, 0x89A9, 0x0373, 0x06E6, 0x0DCC],
        [0x1021, 0x2042, 0x4084, 0x8108, 0x1231, 0x2462, 0x48C4]
    ];
    return PasswordHashCodeCalculator;
}());
exports.PasswordHashCodeCalculator = PasswordHashCodeCalculator;
