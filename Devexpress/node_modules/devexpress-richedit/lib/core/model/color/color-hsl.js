"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("@devexpress/utils/lib/errors");
var color_1 = require("@devexpress/utils/lib/utils/color");
var list_1 = require("@devexpress/utils/lib/utils/list");
var math_1 = require("@devexpress/utils/lib/utils/math");
var log_1 = require("../../rich-utils/debug/logger/base-logger/log");
var drawing_value_constants_1 = require("../drawing/drawing-value-constants");
var dx_color_1 = require("./dx-color");
var ColorHSL = (function () {
    function ColorHSL(hue, saturation, luminance) {
        if (log_1.Log.isEnabled && !(hue <= 1 && hue >= 0 && saturation <= 1 && saturation >= 0 && luminance <= 1 && luminance >= 0))
            throw new Error(errors_1.Errors.InternalException);
        this._hue = hue;
        this._saturation = saturation;
        this._luminance = luminance;
    }
    ColorHSL.prototype.calculateHash = function () {
        return math_1.MathUtils.somePrimes[0] * this._hue ^
            math_1.MathUtils.somePrimes[0] * this._luminance ^
            math_1.MathUtils.somePrimes[0] * this._saturation;
    };
    ColorHSL.makeFromHSL = function (hue, saturation, luminance) {
        return new ColorHSL(hue / ColorHSL.MaxAngle, saturation / ColorHSL.MaxThousandthOfPercentage, luminance / ColorHSL.MaxThousandthOfPercentage);
    };
    ColorHSL.rgbToHsl = function (r, g, b) {
        r /= 255, g /= 255, b /= 255;
        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2;
        if (max == min) {
            h = s = 0;
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return [h, s, l];
    };
    ColorHSL.fromColorRGB = function (color) {
        var r = color_1.ColorUtils.getRed(color) / 255;
        var g = color_1.ColorUtils.getGreen(color) / 255;
        var b = color_1.ColorUtils.getBlue(color) / 255;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h;
        var s;
        var l = (max + min) / 2;
        if (max == min) {
            s = 0;
            h = 4.0 / 6.0;
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return new ColorHSL(h, s, l);
    };
    ColorHSL.calculateColorRGB = function (color, tint) {
        if (color == dx_color_1.DXColor.empty || tint == 0)
            return color;
        return ColorHSL.fromColorRGB(color).applyTint(tint).toRgb();
    };
    ColorHSL.prototype.toRgb = function () {
        var _this = this;
        var value1 = (this._luminance < 0.5) ?
            this._luminance * (1 + this._saturation) :
            this._luminance + this._saturation - this._luminance * this._saturation;
        var value2 = 2 * this._luminance - value1;
        var rgb = list_1.ListUtils.map([this._hue + 1.0 / 3.0, this._hue, this._hue - 1.0 / 3.0], function (value) {
            if (value < 0)
                value += 1;
            if (value > 1)
                value -= 1;
            if (6 * value < 1)
                value = value2 + ((value1 - value2) * 6 * value);
            else if (6 * value >= 1 && 6 * value < 3)
                value = value1;
            else if (6 * value >= 3 && 6 * value < 4)
                value = value2 + ((value1 - value2) * (4 - 6 * value));
            else
                value = value2;
            return _this.toIntValue(value);
        });
        return dx_color_1.DXColor.fromRgb(rgb[0], rgb[1], rgb[2]);
    };
    Object.defineProperty(ColorHSL.prototype, "hue", {
        get: function () { return this.getIntValue(this._hue, ColorHSL.MaxAngle); },
        set: function (value) { this._hue = this.getFloatValue(this.getValidValue(value), ColorHSL.MaxAngle); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ColorHSL.prototype, "saturation", {
        get: function () { return this.getIntValue(this._saturation, ColorHSL.MaxThousandthOfPercentage); },
        set: function (value) { this._saturation = this.getFloatValue(this.getValidValue(value), ColorHSL.MaxThousandthOfPercentage); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ColorHSL.prototype, "luminance", {
        get: function () { return this.getIntValue(this._luminance, ColorHSL.MaxThousandthOfPercentage); },
        set: function (value) { this._luminance = this.getFloatValue(this.getValidValue(value), ColorHSL.MaxThousandthOfPercentage); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ColorHSL.prototype, "floatHue", {
        get: function () { return this._hue; },
        set: function (value) { this._hue = this.getValidValue(value); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ColorHSL.prototype, "floatSaturation", {
        get: function () { return this._saturation; },
        set: function (value) { this._saturation = this.getValidValue(value); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ColorHSL.prototype, "floatLuminance", {
        get: function () { return this._luminance; },
        set: function (value) { this._luminance = this.getValidValue(value); },
        enumerable: true,
        configurable: true
    });
    ;
    ColorHSL.prototype.getComplementColor = function () {
        this._hue += this._hue > 0.5 ? -0.5 : 0.5;
        return this;
    };
    ColorHSL.prototype.applyHue = function (value) {
        this.floatHue = value / ColorHSL.MaxAngle;
        return this;
    };
    ColorHSL.prototype.applyHueMod = function (value) {
        this._hue = this._hue * value / ColorHSL.MaxThousandthOfPercentage;
        this.fixHue();
        return this;
    };
    ColorHSL.prototype.applyHueOffset = function (value) {
        this._hue += value / ColorHSL.MaxAngle;
        this.fixHue();
        return this;
    };
    ColorHSL.prototype.applySaturation = function (value) {
        this.floatSaturation = value / ColorHSL.MaxThousandthOfPercentage;
        return this;
    };
    ColorHSL.prototype.applySaturationMod = function (value) {
        this._saturation = this._saturation * value / ColorHSL.MaxThousandthOfPercentage;
        return this;
    };
    ColorHSL.prototype.applySaturationOffset = function (value) {
        this._saturation += value / ColorHSL.MaxThousandthOfPercentage;
        return this;
    };
    ColorHSL.prototype.applyLuminance = function (value) {
        this.floatLuminance = value / ColorHSL.MaxThousandthOfPercentage;
        return this;
    };
    ColorHSL.prototype.applyLuminanceMod = function (value) {
        this._luminance = this._luminance * value / ColorHSL.MaxThousandthOfPercentage;
        return this;
    };
    ColorHSL.prototype.applyLuminanceOffset = function (value) {
        this._luminance += value / ColorHSL.MaxThousandthOfPercentage;
        return this;
    };
    ColorHSL.prototype.fixHue = function () {
        if (this._hue > 1)
            this._hue -= Math.floor(this._hue);
    };
    ColorHSL.prototype.toIntValue = function (value) {
        return this.fixIntValue(Math.round(255 * value));
    };
    ColorHSL.prototype.fixIntValue = function (value) {
        return math_1.MathUtils.restrictValue(value, 0, 255);
    };
    ColorHSL.prototype.getIntValue = function (value, maxValue) {
        return Math.round(value * maxValue);
    };
    ColorHSL.prototype.getFloatValue = function (value, maxValue) {
        return value / maxValue;
    };
    ColorHSL.prototype.getValidValue = function (value) {
        return math_1.MathUtils.restrictValue(value, 0, 1);
    };
    ColorHSL.prototype.applyTint = function (tint) {
        if (tint < 0)
            this._luminance *= (1 + tint);
        else if (tint > 0)
            this._luminance = this._luminance * (1 - tint) + tint;
        return this;
    };
    ColorHSL.prototype.equals = function (obj) {
        return obj &&
            this._hue == obj._hue &&
            this._saturation == obj._saturation &&
            this._luminance == obj._luminance;
    };
    ColorHSL.MaxAngle = drawing_value_constants_1.DrawingValueConstants.MaxPositiveFixedAngle;
    ColorHSL.MaxThousandthOfPercentage = drawing_value_constants_1.DrawingValueConstants.ThousandthOfPercentage;
    ColorHSL.defaultValue = new ColorHSL(0, 0, 0);
    return ColorHSL;
}());
exports.ColorHSL = ColorHSL;
