"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var flag_1 = require("@devexpress/utils/lib/class/flag");
var list_1 = require("@devexpress/utils/lib/utils/list");
var control_font_1 = require("./control-font");
var font_face_descriptors_1 = require("./font-face-descriptors");
var font_info_1 = require("./font-info");
var GoogleFontsApi = (function () {
    function GoogleFontsApi(controlFontsCache, fonts) {
        var _this = this;
        this.fontFamilyToFontInfo = {};
        this.fonts = fonts;
        this.controlFontsCache = controlFontsCache;
        var params = this.fonts.map(function (font) {
            var fontFamily = font.getFontFamilies()[0];
            _this.fontFamilyToFontInfo[fontFamily] = font;
            return fontFamily.replace(' ', '+') + ":regular,bold,italic,bolditalic";
        }).join('|');
        this.uri = "https://fonts.googleapis.com/css?family=" + params;
    }
    GoogleFontsApi.prototype.loadControlFonts = function (callback) {
        var _this = this;
        var notLoaded = function () { return callback([]); };
        var xhr = new XMLHttpRequest();
        xhr.onload = function (_e) {
            var responce = xhr.response;
            if (xhr.status >= 400 || !responce)
                notLoaded();
            else
                callback(_this.parseResponce(responce));
        };
        xhr.onerror = function () { return notLoaded(); };
        xhr.open("GET", this.uri, true);
        xhr.responseType = "text";
        xhr.send();
    };
    GoogleFontsApi.prototype.parseResponce = function (responce) {
        var result = [];
        var regexpResult;
        var regexp = /@font-face\s*\{([\s\S]*?)\}/gm;
        var _loop_1 = function () {
            var fontInfo = regexpResult[1];
            var fontFamily = fontInfo.match(/font-family:\s*'(\w+\s*\w*)';/);
            if (fontFamily && fontFamily[1]) {
                var url_1 = GoogleFontsApi.parseSrc(fontInfo.match(/src:\s*(.+);/));
                var fontStyle = fontInfo.match(/font-style:\s*(\w+);/);
                var fontWeight = fontInfo.match(/font-weight:\s*(.+);/);
                var unicodeRange = fontInfo.match(/unicode-range:\s*(.+);/);
                var desc = new font_face_descriptors_1.FontFaceDescriptors();
                if (fontStyle && fontStyle[1])
                    desc.style = fontStyle[1];
                if (fontWeight && fontWeight[1])
                    desc.weight = fontWeight[1];
                if (unicodeRange && unicodeRange[1])
                    desc.unicodeRange = unicodeRange[1];
                var controlFont = this_1.controlFontsCache.addFont(new control_font_1.ControlFont(fontFamily[1], desc));
                if (url_1 && list_1.ListUtils.allOf(controlFont.sourceUrls, function (s) { return s != url_1; })) {
                    controlFont.sourceUrls.unshift(url_1);
                    var fontInfo_1 = this_1.fontFamilyToFontInfo[controlFont.fontFamily];
                    var controlFontType = new flag_1.Flag();
                    controlFontType.set(font_info_1.ControlFontType.Bold, controlFont.descriptors.msWordBold());
                    controlFontType.set(font_info_1.ControlFontType.Italic, controlFont.descriptors.msWordItalic());
                    fontInfo_1.controlFontMap[controlFontType.getValue()] = controlFont.cacheKey;
                    result.push(controlFont);
                }
            }
        };
        var this_1 = this;
        while (regexpResult = regexp.exec(responce)) {
            _loop_1();
        }
        return result;
    };
    GoogleFontsApi.parseSrc = function (matchSrc) {
        if (matchSrc && matchSrc[1])
            for (var _i = 0, _a = matchSrc[1].split(','); _i < _a.length; _i++) {
                var src = _a[_i];
                var matchUrl = src.match(/url\((.+)\)\s*format\('(\w+)'\)/);
                if (matchUrl)
                    return matchUrl[1];
            }
        return null;
    };
    return GoogleFontsApi;
}());
exports.GoogleFontsApi = GoogleFontsApi;
