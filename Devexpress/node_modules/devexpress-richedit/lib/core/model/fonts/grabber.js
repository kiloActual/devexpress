"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var flag_1 = require("@devexpress/utils/lib/class/flag");
var enum_1 = require("@devexpress/utils/lib/utils/enum");
var list_1 = require("@devexpress/utils/lib/utils/list");
var number_1 = require("@devexpress/utils/lib/utils/map/number");
var layout_box_1 = require("../../layout/main-structures/layout-boxes/layout-box");
var hash_based_cache_1 = require("../caches/hash-based-cache");
var control_font_1 = require("./control-font");
var font_info_1 = require("./font-info");
var LayoutFontsCollectorElement = (function () {
    function LayoutFontsCollectorElement(charProps) {
        this.textCache = Object.create(null);
        this.charProps = charProps;
    }
    LayoutFontsCollectorElement.prototype.getHashCode = function () {
        return this.charProps.getHashCode();
    };
    LayoutFontsCollectorElement.prototype.equals = function (obj) {
        return this.charProps == obj.charProps;
    };
    LayoutFontsCollectorElement.prototype.addFont = function (symbol, font) {
        this.textCache[symbol] = font;
    };
    LayoutFontsCollectorElement.prototype.getFont = function (symbol) {
        return this.textCache[symbol];
    };
    LayoutFontsCollectorElement.prototype.replaceUnloadedFonts = function (defaultFontMap) {
        var newTextCache = Object.create(null);
        for (var key in this.textCache) {
            var controlFont = this.textCache[key];
            newTextCache[key] = controlFont.loaded ? controlFont : defaultFontMap[controlFont.controlFontType];
        }
        var newElement = new LayoutFontsCollectorElement(this.charProps);
        newElement.textCache = newTextCache;
        return newElement;
    };
    return LayoutFontsCollectorElement;
}());
exports.LayoutFontsCollectorElement = LayoutFontsCollectorElement;
var LayoutFontsCollectorCache = (function (_super) {
    tslib_1.__extends(LayoutFontsCollectorCache, _super);
    function LayoutFontsCollectorCache() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LayoutFontsCollectorCache.prototype.replaceUnloadedFonts = function (defaultFontMap) {
        var result = new LayoutFontsCollectorCache();
        number_1.NumberMapUtils.forEach(this.hashtable, function (list) {
            return list.forEach(function (elem) { return result.getItem(elem.replaceUnloadedFonts(defaultFontMap)); });
        });
        return result;
    };
    return LayoutFontsCollectorCache;
}(hash_based_cache_1.HashBasedCacheCore));
exports.LayoutFontsCollectorCache = LayoutFontsCollectorCache;
var LayoutFontsCollector = (function () {
    function LayoutFontsCollector(cache, layout, defaultFontName) {
        this.fonts = {};
        this.cache = new LayoutFontsCollectorCache();
        this.controlFontsCache = cache.controlFontsCache;
        this.layout = layout;
        this.defaultFont = defaultFontName ? cache.fontInfoCache.getItemByName(defaultFontName) : null;
    }
    LayoutFontsCollector.prototype.addDefaultFont = function () {
        var _this = this;
        if (!this.defaultFont)
            return;
        var addFontToLoad = function (type) {
            var fontKey = _this.defaultFont.controlFontMap[type];
            var controlFont = _this.controlFontsCache.getFontByKey(fontKey);
            if (controlFont && !controlFont.loaded)
                _this.fonts[fontKey] = controlFont;
        };
        this.defaultFont.ensureAllControlFontsAssigned(this.controlFontsCache);
        addFontToLoad(font_info_1.ControlFontType.Regular);
        addFontToLoad(font_info_1.ControlFontType.Bold);
        addFontToLoad(font_info_1.ControlFontType.Italic);
        addFontToLoad(font_info_1.ControlFontType.BoldItalic);
    };
    LayoutFontsCollector.prototype.collect = function () {
        var _this = this;
        this.addDefaultFont();
        for (var _i = 0, _a = this.layout.pages; _i < _a.length; _i++) {
            var page = _a[_i];
            for (var _b = 0, _c = page.mainSubDocumentPageAreas; _b < _c.length; _b++) {
                var pageArea = _c[_b];
                this.grabFromPageArea(pageArea);
            }
            number_1.NumberMapUtils.forEach(page.otherPageAreas, function (pageArea) {
                return _this.grabFromPageArea(pageArea);
            });
        }
        return number_1.NumberMapUtils.toList(this.fonts);
    };
    LayoutFontsCollector.prototype.grabFromPageArea = function (pageArea) {
        for (var _i = 0, _a = pageArea.columns; _i < _a.length; _i++) {
            var column = _a[_i];
            for (var _b = 0, _c = column.rows; _b < _c.length; _b++) {
                var row = _c[_b];
                if (row.numberingListBox) {
                    this.addFont(row.numberingListBox.textBox);
                    if (row.numberingListBox.separatorBox)
                        this.addFont(row.numberingListBox.separatorBox);
                }
                for (var _d = 0, _e = row.boxes; _d < _e.length; _d++) {
                    var rowBox = _e[_d];
                    this.addFont(rowBox);
                }
            }
        }
    };
    LayoutFontsCollector.prototype.addFont = function (box) {
        if (enum_1.EnumUtils.isAnyOf(box.getType(), layout_box_1.LayoutBoxType.Picture, layout_box_1.LayoutBoxType.AnchorPicture))
            return;
        var content = LayoutFontsCollector.boxContent(box);
        if (content.length)
            this.mustHaveFontsForRenderText(box.characterProperties, content);
    };
    LayoutFontsCollector.prototype.mustHaveFontsForRenderText = function (charProps, text) {
        var cacheElem = this.cache.getItem(new LayoutFontsCollectorElement(charProps));
        var controlFontType = new flag_1.Flag();
        controlFontType.set(font_info_1.ControlFontType.Bold, charProps.fontBold);
        controlFontType.set(font_info_1.ControlFontType.Italic, charProps.fontItalic);
        var key = charProps.fontInfo.controlFontMap[controlFontType.getValue()];
        var textLen = text.length;
        var defaultControlFont = null;
        var _loop_1 = function (textIndex) {
            var symbol = text[textIndex];
            if (cacheElem.getFont(symbol))
                return "continue";
            var charCodePoint = symbol.charCodeAt(0);
            var candidate = this_1.controlFontsCache.getFontByKey(key);
            var font = candidate && list_1.ListUtils.unsafeAnyOf(candidate.unicodeRanges, function (range) { return range.contains(charCodePoint); }) ?
                candidate : null;
            if (!font) {
                if (candidate)
                    font = candidate;
                else {
                    if (!defaultControlFont)
                        defaultControlFont = this_1.controlFontsCache.addFont(control_font_1.ControlFont.createDefault(charProps.fontInfo.getFontFamilies()[0], controlFontType));
                    font = defaultControlFont;
                }
            }
            if (!this_1.fonts[font.cacheKey])
                this_1.fonts[font.cacheKey] = font;
            cacheElem.addFont(symbol, font);
        };
        var this_1 = this;
        for (var textIndex = 0; textIndex < textLen; textIndex++) {
            _loop_1(textIndex);
        }
    };
    LayoutFontsCollector.boxContent = function (box) {
        switch (box.getType()) {
            case layout_box_1.LayoutBoxType.Text:
            case layout_box_1.LayoutBoxType.LayoutDependent:
            case layout_box_1.LayoutBoxType.Dash:
                return box.text;
            case layout_box_1.LayoutBoxType.ColumnBreak:
            case layout_box_1.LayoutBoxType.LineBreak:
            case layout_box_1.LayoutBoxType.PageBreak:
            case layout_box_1.LayoutBoxType.ParagraphMark:
            case layout_box_1.LayoutBoxType.SectionMark:
            case layout_box_1.LayoutBoxType.TabSpace:
            case layout_box_1.LayoutBoxType.Space:
                return " ";
            default:
                return "";
        }
    };
    return LayoutFontsCollector;
}());
exports.LayoutFontsCollector = LayoutFontsCollector;
