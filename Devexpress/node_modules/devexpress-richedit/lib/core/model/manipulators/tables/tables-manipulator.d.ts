import { FixedInterval } from '@devexpress/utils/lib/intervals/fixed';
import { InputPositionBase } from '../../../selection/input-position-base';
import { SubDocument, SubDocumentInterval } from '../../sub-document';
import { Table, TablePosition } from '../../tables/main-structures/table';
import { TableCell } from '../../tables/main-structures/table-cell';
import { TableRow } from '../../tables/main-structures/table-row';
import { TableStyle } from '../../tables/styles/table-style';
import { BaseManipulator } from '../base-manipulator';
import { ModelManipulator } from '../model-manipulator';
import { TableCellPropertiesManipulator } from './table-cell-properties-manipulator';
import { TablePropertiesManipulator } from './table-properties-manipulator';
import { TableRowPropertiesManipulator } from './table-row-properties-manipulator';
export declare class TablesManipulator extends BaseManipulator {
    cellProperties: TableCellPropertiesManipulator;
    tableProperties: TablePropertiesManipulator;
    rowProperties: TableRowPropertiesManipulator;
    constructor(manipulator: ModelManipulator);
    static removeTableCore(table: Table, tables: Table[], tablesByLevels: Table[][]): void;
    createTable(subDocument: SubDocument, firstParagraphIndex: number, rowCount: number, cellCount: number): Table;
    removeTable(subDocument: SubDocument, table: Table): void;
    restoreRemovedTable(subDocument: SubDocument, table: Table, cellsRanges: FixedInterval[][]): void;
    pasteTable(subDocument: SubDocument, patternTable: Table, position: number): Table;
    insertRow(subDocument: SubDocument, tableIndex: number, patternRow: TableRow, targetRowIndex: number, cellIntervals: FixedInterval[]): void;
    removeRow(subDocument: SubDocument, tableIndex: number, rowIndex: number): void;
    static removeRowCore(subDocument: SubDocument, table: Table, rowIndex: number): void;
    removeCell(subDocument: SubDocument, table: Table, rowIndex: number, cellIndex: number): void;
    insertCell(subDocument: SubDocument, table: Table, rowIndex: number, cellIndex: number, patternCell: TableCell, length: number): void;
    insertParagraphToTheCellStartAndShiftContent(subDocument: SubDocument, cell: TableCell, inpPos: InputPositionBase): void;
    changeTableStartPosition(subDocument: SubDocument, table: Table, newPosition: number): void;
    shiftTableStartPositionToTheRight(subDocument: SubDocument, table: Table): void;
    restoreShiftedTableStartPositionToTheRight(subDocument: SubDocument, table: Table): void;
    splitTableCellHorizontally(subDocument: SubDocument, table: Table, rowIndex: number, cellIndex: number, rightDirection: boolean, copyProperties: boolean): void;
    restoreSplittedCellHorizontally(subDocument: SubDocument, table: Table, rowIndex: number, cellIndex: number, rightDirection: boolean): void;
    private splitTableCellToTheLeftCore;
    private splitTableCellToTheRightCore;
    setTableStyle(subDocument: SubDocument, tableIndex: number, style: TableStyle): void;
    removeTableWithContent(subDocument: SubDocument, table: Table): void;
    removeTableCellWithContent(subDocument: SubDocument, table: Table, rowIndex: number, cellIndex: number): void;
    removeTableRowWithContent(subDocument: SubDocument, table: Table, rowIndex: number): void;
    private updateVerticalMergingState;
    private removeNestedTables;
    private isNestedTableInRow;
    removeNestedTablesByParentTable(subDocument: SubDocument, parentTable: Table): void;
    removeNestedTablesByParentCell(subDocument: SubDocument, parentCell: TableCell): void;
    private isNestedTableInCell;
    private isNestedTableInTable;
    normalizeVerticalSpans(subDocument: SubDocument, table: Table): void;
    normalizeTableGrid(subDocument: SubDocument, table: Table): void;
    normalizeCellColumnSpans(subDocument: SubDocument, table: Table, canNormalizeWidthBeforeAndWidthAfter: boolean): void;
    static normalizeCellColumnSpansWithoutHistory(table: Table, canNormalizeWidthBeforeAndWidthAfter: boolean): void;
    private static normalizeTableRow;
    private static calculateNewSpan;
    private static normalizeRowsGridBefore;
    normalizeTableCellWidth(subDocument: SubDocument, table: Table): void;
    private createTableStructure;
    fullCellWidth(widths: number[], startSpan: number, cellSpan: number): number;
    initializeColumnWidthsWhenInsertTable(subDocument: SubDocument, table: Table, avaliableSpace: number): void;
    validateTableIndent(subDocument: SubDocument, table: Table): void;
    tryJoinTables(subDocument: SubDocument, table: Table): void;
    joinTablesCore(_subDocument: SubDocument, tables: Table[]): void;
    forEachCell(table: Table, func: (pos: TablePosition, cellSpan: number) => void): void;
    distributeWidthsToAllColumns(table: Table, width: number): number[];
    private insertTableCore;
    normalizeVerticalMerging(subDocument: SubDocument, table: Table, rowIndex: number, cellIndex: number): void;
    normalizeRows(subDocument: SubDocument, table: Table): void;
    private areAllCellsHasVerticalMerge;
    mergeTwoTableCellsHorizontally(subDocument: SubDocument, cellPosition: TablePosition, inpPos: InputPositionBase): void;
    mergeTwoTableCellsVertically(subDocument: SubDocument, cellPosition: TablePosition, inpPos: InputPositionBase): void;
    insertCellToTheRight(subDocument: SubDocument, table: Table, rowIndex: number, cellIndex: number, inpPos: InputPositionBase, canNormalizeTable?: boolean, canNormalizeVerticalMerging?: boolean, canCopyProperties?: boolean): void;
    insertCellToTheLeft(subDocument: SubDocument, table: Table, rowIndex: number, cellIndex: number, inpPos: InputPositionBase, canNormalizeTable?: boolean, canNormalizeVerticalMerging?: boolean, canCopyProperties?: boolean): void;
    insertRowBelow(subDocument: SubDocument, table: Table, rowIndex: number, inpPos: InputPositionBase): void;
    insertRowAbove(subDocument: SubDocument, table: Table, rowIndex: number, inpPos: InputPositionBase): void;
    insertTable(subDocument: SubDocument, rowCount: number, cellCount: number, position: number, availableWidth: number, inpPos: InputPositionBase, applyInitialBorders?: boolean): Table;
    applyInitialBorders(subDocument: SubDocument, table: Table): void;
    removeTablesOnInterval(subDocInterval: SubDocumentInterval, removeTableIfItMatchesWithInterval: boolean): void;
    resetParagraphCharacterMergedProperties(subDocument: SubDocument, tableIndex: number): void;
}
//# sourceMappingURL=tables-manipulator.d.ts.map
