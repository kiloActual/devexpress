"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var split_table_cell_history_item_1 = require("../../history/items/tables/split-table-cell-history-item");
var table_cell_properties_history_items_1 = require("../../history/items/tables/table-cell-properties-history-items");
var table_row_properties_history_items_1 = require("../../history/items/tables/table-row-properties-history-items");
var sub_document_1 = require("../../sub-document");
var table_1 = require("../../tables/main-structures/table");
var table_base_structures_1 = require("../../tables/secondary-structures/table-base-structures");
var table_utils_1 = require("../../tables/table-utils");
var insert_paragraph_manipulator_params_1 = require("../paragraph-manipulator/insert-paragraph-manipulator-params");
var InsertTableCellOperationBase = (function () {
    function InsertTableCellOperationBase(modelManager, subDocument) {
        this.subDocument = subDocument;
        this.modelManager = modelManager;
    }
    Object.defineProperty(InsertTableCellOperationBase.prototype, "modelManipulator", {
        get: function () { return this.modelManager.modelManipulator; },
        enumerable: true,
        configurable: true
    });
    InsertTableCellOperationBase.prototype.execute = function (table, rowIndex, cellIndex, canNormalizeTable, canNormalizeVerticalMerging, canCopyProperties, inpPos) {
        var row = table.rows[rowIndex];
        var cell = row.cells[cellIndex];
        var patternCellStartColumnIndex = table_utils_1.TableCellUtils.getStartColumnIndex(cell);
        var restartCellPosition = table_1.Table.getFirstCellPositionInVerticalMergingGroup(table_1.TablePosition.createAndInit(table, rowIndex, cellIndex));
        var verticalSpanCellsPositions = table_utils_1.TableCellUtils.getVerticalSpanCellPositions(restartCellPosition, patternCellStartColumnIndex);
        for (var i = verticalSpanCellsPositions.length - 1, pos = void 0; pos = verticalSpanCellsPositions[i]; i--) {
            if (canNormalizeVerticalMerging)
                this.modelManipulator.table.normalizeVerticalMerging(this.subDocument, table, pos.rowIndex, pos.cellIndex);
            this.insertTableCellCore(this.subDocument, pos, canCopyProperties, inpPos);
        }
        if (canNormalizeTable) {
            this.normalizeTableGridAfter(table);
            this.modelManipulator.table.normalizeCellColumnSpans(this.subDocument, table, true);
        }
    };
    InsertTableCellOperationBase.prototype.normalizeTableGridAfter = function (table) {
        var maxEndColumnIndex = 0;
        var endColumnIndices = [];
        for (var rowIndex = 0, row = void 0; row = table.rows[rowIndex]; rowIndex++) {
            var lastCell = row.cells[row.cells.length - 1];
            var currentEndColumnIndex = table_utils_1.TableCellUtils.getEndColumnIndex(lastCell) + row.gridAfter;
            endColumnIndices.push(currentEndColumnIndex);
            maxEndColumnIndex = Math.max(maxEndColumnIndex, currentEndColumnIndex);
        }
        for (var rowIndex = 0, row = void 0; row = table.rows[rowIndex]; rowIndex++) {
            var currentEndColumnIndex = endColumnIndices[rowIndex];
            var delta = maxEndColumnIndex - currentEndColumnIndex;
            if (delta > 0)
                this.modelManager.history.addAndRedo(new table_row_properties_history_items_1.TableRowGridAfterHistoryItem(this.modelManager.modelManipulator, this.subDocument, table.index, rowIndex, row.gridAfter + delta));
        }
    };
    return InsertTableCellOperationBase;
}());
exports.InsertTableCellOperationBase = InsertTableCellOperationBase;
var InsertTableCellToTheLeftOperation = (function (_super) {
    tslib_1.__extends(InsertTableCellToTheLeftOperation, _super);
    function InsertTableCellToTheLeftOperation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InsertTableCellToTheLeftOperation.prototype.insertTableCellCore = function (subDocument, pos, copyProperties, inpPos) {
        this.modelManipulator.table.insertParagraphToTheCellStartAndShiftContent(subDocument, pos.cell, inpPos);
        this.modelManager.history.addAndRedo(new split_table_cell_history_item_1.SplitTableCellToTheLeftHistoryItem(this.modelManager.modelManipulator, subDocument, pos.table.index, pos.rowIndex, pos.cellIndex, copyProperties));
        if (pos.cell.verticalMerging !== table_base_structures_1.TableCellMergingState.None)
            this.modelManager.history.addAndRedo(new table_cell_properties_history_items_1.TableCellVerticalMergingHistoryItem(this.modelManager.modelManipulator, subDocument, pos.table.index, pos.rowIndex, pos.cellIndex, pos.cell.verticalMerging));
    };
    return InsertTableCellToTheLeftOperation;
}(InsertTableCellOperationBase));
exports.InsertTableCellToTheLeftOperation = InsertTableCellToTheLeftOperation;
var InsertTableCellToTheRightOperation = (function (_super) {
    tslib_1.__extends(InsertTableCellToTheRightOperation, _super);
    function InsertTableCellToTheRightOperation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InsertTableCellToTheRightOperation.prototype.insertTableCellCore = function (subDocument, pos, copyProperties, inpPos) {
        this.modelManager.modelManipulator.paragraph.insertParagraphViaHistory(insert_paragraph_manipulator_params_1.InsertParagraphManipulatorParams.makeParamsByPosition(new sub_document_1.SubDocumentPosition(subDocument, pos.cell.endParagrapPosition.value - 1), inpPos));
        this.modelManager.history.addAndRedo(new split_table_cell_history_item_1.SplitTableCellToTheRightHistoryItem(this.modelManager.modelManipulator, subDocument, pos.table.index, pos.rowIndex, pos.cellIndex, copyProperties));
        if (pos.cell.verticalMerging !== table_base_structures_1.TableCellMergingState.None)
            this.modelManager.history.addAndRedo(new table_cell_properties_history_items_1.TableCellVerticalMergingHistoryItem(this.modelManager.modelManipulator, subDocument, pos.table.index, pos.rowIndex, pos.cellIndex + 1, pos.cell.verticalMerging));
    };
    return InsertTableCellToTheRightOperation;
}(InsertTableCellOperationBase));
exports.InsertTableCellToTheRightOperation = InsertTableCellToTheRightOperation;
