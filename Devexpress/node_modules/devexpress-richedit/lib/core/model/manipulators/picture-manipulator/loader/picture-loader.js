"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var size_1 = require("@devexpress/utils/lib/geometry/size");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var base64_1 = require("@devexpress/utils/lib/utils/base64");
var number_1 = require("@devexpress/utils/lib/utils/map/number");
var columns_calculator_1 = require("../../../../layout-formatter/formatter/utils/columns-calculator");
var inline_pictures_updated_1 = require("../../../changes/sub-document/picture/inline-pictures-updated");
var updated_image_info_1 = require("./updated-image-info");
var PicSizeUpdaterData = (function () {
    function PicSizeUpdaterData(subDocument, runPosition, run, options, histItemSize) {
        this.subDocument = subDocument;
        this.runPosition = runPosition;
        this.run = run;
        this.options = options;
        this.histItemSize = histItemSize;
    }
    return PicSizeUpdaterData;
}());
var PicSizeUpdater = (function () {
    function PicSizeUpdater(modelManipulator, pictureLoadedListener) {
        this.loadingData = {};
        this.modelManipulator = modelManipulator;
        this.pictureLoadedListener = pictureLoadedListener;
    }
    PicSizeUpdater.prototype.addLoadListener = function (cacheInfo, callback) {
        var existingData = this.loadingData[cacheInfo.tmpId];
        if (!existingData)
            return;
        existingData.push(callback);
    };
    PicSizeUpdater.prototype.allPicturesLoaded = function () {
        return number_1.NumberMapUtils.isEmpty(this.loadingData);
    };
    PicSizeUpdater.prototype.addSizes = function (subDocPos, options, run, histItemSize) {
        var cacheInfo = run.info.cacheInfo;
        var existingData = this.loadingData[cacheInfo.tmpId];
        if (!existingData)
            existingData = this.loadingData[cacheInfo.tmpId] = [];
        var pos = subDocPos.subDocument.positionManager.registerPosition(subDocPos.position);
        existingData.push(new PicSizeUpdaterData(subDocPos.subDocument, pos, run, options, histItemSize));
    };
    PicSizeUpdater.prototype.update = function (cacheInfo, notify) {
        var existingData = this.loadingData[cacheInfo.tmpId];
        if (existingData) {
            delete this.loadingData[cacheInfo.tmpId];
            this.modelManipulator.batchUpdatableObject.beginUpdate();
            for (var _i = 0, existingData_1 = existingData; _i < existingData_1.length; _i++) {
                var extData = existingData_1[_i];
                if (extData instanceof PicSizeUpdaterData)
                    this.updateInner(extData, notify);
                else
                    extData();
            }
            this.modelManipulator.batchUpdatableObject.endUpdate();
            this.pictureLoadedListener.notifyPictureLoaded();
        }
    };
    PicSizeUpdater.prototype.updateInner = function (data, notify) {
        var options = data.options;
        var originalSize = data.run.info.cacheInfo.size;
        var scaleSize = null;
        if (options.actualSize) {
            scaleSize = size_1.Size.initByCommonAction(function (adp) { return 100 * adp(options.actualSize) / adp(originalSize); });
        }
        else if (options.calculateActualSize) {
            var maxPictureSize = columns_calculator_1.ColumnCalculator.findMinimalColumnSize(this.modelManipulator.model.getSectionByPosition(data.runPosition.value).sectionProperties)
                .applyConverter(unit_converter_1.UnitConverter.pixelsToTwips);
            var scale = 100 * Math.min(maxPictureSize.width / Math.max(1, originalSize.width), maxPictureSize.height / Math.max(1, originalSize.height));
            var resultScale = Math.max(1, Math.min(scale, 100));
            scaleSize = new size_1.Size(resultScale, resultScale);
        }
        if (scaleSize) {
            if (data.histItemSize)
                data.histItemSize.scale = scaleSize.clone();
            data.run.size.scale = scaleSize.clone();
            if (notify && data.subDocument.getRunByPosition(data.runPosition.value) === data.run)
                this.modelManipulator.notifyModelChanged(new inline_pictures_updated_1.InlinePicturesUpdatedSubDocumentChange(data.subDocument.id, new updated_image_info_1.UpdatedImageInfo(data.runPosition.value, data.run.info.cacheInfo, data.run.size)));
        }
        data.subDocument.positionManager.unregisterPosition(data.runPosition);
        data.options.imageLoadedEvent.forEach(function (cb) { return cb(new fixed_1.FixedInterval(data.runPosition.value, 1), data.run.info.cacheInfo); });
    };
    return PicSizeUpdater;
}());
var CallbacksInfo = (function () {
    function CallbacksInfo(callback, timeoutId) {
        this.callback = callback;
        this.timeoutId = timeoutId;
    }
    return CallbacksInfo;
}());
var PictureLoader = (function () {
    function PictureLoader(modelManipulator) {
        this.callbacksInfo = [];
        this.modelManipulator = modelManipulator;
        this.sizeUpdater = new PicSizeUpdater(modelManipulator, this);
    }
    Object.defineProperty(PictureLoader.prototype, "imageCache", {
        get: function () { return this.modelManipulator.model.cache.imageCache; },
        enumerable: true,
        configurable: true
    });
    PictureLoader.prototype.notifyPictureLoaded = function () {
        if (this.sizeUpdater.allPicturesLoaded()) {
            var clbs = this.callbacksInfo;
            this.callbacksInfo = [];
            clbs.forEach(function (info) {
                clearTimeout(info.timeoutId);
                info.callback(true);
            });
        }
    };
    PictureLoader.prototype.ensureAllPicturesLoaded = function (timeout, callback) {
        var _this = this;
        if (this.sizeUpdater.allPicturesLoaded()) {
            callback(true);
            return;
        }
        var info = new CallbacksInfo(callback, setTimeout(function () {
            var index = _this.callbacksInfo.indexOf(info);
            if (index >= 0) {
                _this.callbacksInfo.splice(index, 1);
                info.callback(false);
            }
        }, timeout));
        this.callbacksInfo.push(info);
    };
    PictureLoader.prototype.load = function (data) {
        if (data.isLoaded)
            return;
        this.loadInner(data);
    };
    PictureLoader.prototype.finalizeLoading = function (loadedData, existingInfo) {
        if (!existingInfo)
            existingInfo = this.imageCache.getPictureData(loadedData.tmpId !== undefined ? loadedData.tmpId : loadedData.actualId);
        if (!existingInfo.isLoaded)
            this.imageCache.finalizeLoading(existingInfo, loadedData);
        this.sizeUpdater.update(existingInfo, true);
    };
    PictureLoader.prototype.loadPictureByBase64 = function (data, imageLoaded) {
        var img = new Image();
        img.onload = function () {
            data.size = new size_1.Size(img.width, img.height).applyConverter(unit_converter_1.UnitConverter.pixelsToTwips);
            imageLoaded(data);
        };
        img.src = data.base64;
    };
    PictureLoader.prototype.loadPictureByUrl = function (data, imageLoaded) {
        var _this = this;
        var xhr = new XMLHttpRequest();
        xhr.onload = function () {
            base64_1.Base64Utils.fromBlobAsDataUrl(xhr.response, function (base64) {
                data.base64 = base64;
                _this.loadPictureByBase64(data, function (data) { return imageLoaded(data); });
            });
        };
        xhr.onerror = function () { return imageLoaded(_this.imageCache.emptyImage); };
        try {
            xhr.open('GET', data.imageUrl, true);
            xhr.responseType = 'blob';
            xhr.send();
        }
        catch (_a) {
            imageLoaded(this.imageCache.emptyImage);
        }
    };
    PictureLoader.prototype.loadPictureByFile = function (data, imageLoaded) {
        var _this = this;
        base64_1.Base64Utils.fromBlobAsDataUrl(data.file, function (base64) {
            data.base64 = base64;
            data.file = undefined;
            _this.loadPictureByBase64(data, function (data) { return imageLoaded(data); });
        });
    };
    return PictureLoader;
}());
exports.PictureLoader = PictureLoader;
