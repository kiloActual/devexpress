"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var search_1 = require("@devexpress/utils/lib/utils/search");
var properties_bundle_1 = require("../../rich-utils/properties-bundle");
var section_inserted_1 = require("../changes/sub-document/text/section-inserted");
var insert_section_history_item_1 = require("../history/items/insert-section-history-item");
var paragraph_1 = require("../paragraph/paragraph");
var rich_utils_1 = require("../rich-utils");
var run_type_1 = require("../runs/run-type");
var header_footer_1 = require("../section/header-footer");
var section_1 = require("../section/section");
var sub_document_1 = require("../sub-document");
var runs_base_manipulator_1 = require("./runs-base-manipulator");
var SectionManipulator = (function (_super) {
    tslib_1.__extends(SectionManipulator, _super);
    function SectionManipulator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SectionManipulator.prototype.insertSectionAndSetStartType = function (position, startType, charPropsBundle) {
        var subDocument = this.model.mainSubDocument;
        var documentEndPosition = subDocument.getDocumentEndPosition();
        if (position >= documentEndPosition)
            throw "ModelManipulator.insertSectionAndSetStartType position >= documentEndPosition";
        var sectionProperties = subDocument.getSectionByPosition(position).sectionProperties.clone();
        sectionProperties.startType = startType;
        this.history.beginTransaction();
        this.history.addAndRedo(new insert_section_history_item_1.InsertSectionHistoryItem(this.modelManipulator, new sub_document_1.SubDocumentPosition(subDocument, position), charPropsBundle, new properties_bundle_1.MaskedParagraphPropertiesBundleFull(null, null, undefined, undefined), sectionProperties, false, true));
        this.history.endTransaction();
    };
    SectionManipulator.prototype.insertSection = function (subDocPos, charPropsBundle, sectionProperties, isInsertPropertiesToCurrentSection, parPropsBundle, isInsertPropertiesAndStyleIndexToCurrentParagraph) {
        var subDocument = subDocPos.subDocument;
        var insertPositionAtStartDocument = subDocPos.position;
        if (!subDocument.isMain())
            throw new Error("Section cannot be inserted in a non-main subDocument");
        var oldSectionIndex = search_1.SearchUtils.normedInterpolationIndexOf(subDocument.documentModel.sections, function (s) { return s.startLogPosition.value; }, insertPositionAtStartDocument);
        var oldSection = subDocument.documentModel.sections[oldSectionIndex];
        var lengthNewSection = insertPositionAtStartDocument - oldSection.startLogPosition.value + 1;
        var insertedRun = this.insertRunInternal(subDocPos, charPropsBundle, run_type_1.RunType.SectionRun, rich_utils_1.RichUtils.specialCharacters.SectionMark);
        var oldParagraphIndex = search_1.SearchUtils.normedInterpolationIndexOf(subDocument.paragraphs, function (p) { return p.startLogPosition.value; }, insertPositionAtStartDocument);
        var oldParagraph = subDocument.paragraphs[oldParagraphIndex];
        var newLengthOldParagraph = insertPositionAtStartDocument - oldParagraph.startLogPosition.value + 1;
        var newLengthNewParagraph = oldParagraph.length - newLengthOldParagraph + 1;
        var newParagraphStartPosition = subDocument.positionManager.registerPosition(insertPositionAtStartDocument + 1);
        var newParagraph = new paragraph_1.Paragraph(subDocument, newParagraphStartPosition, newLengthNewParagraph, null, null);
        oldParagraph.length = newLengthOldParagraph;
        subDocument.paragraphs.splice(oldParagraphIndex + 1, 0, newParagraph);
        this.modelManipulator.paragraph.applyParagraphProperties(newParagraph, oldParagraph, isInsertPropertiesAndStyleIndexToCurrentParagraph, parPropsBundle);
        var indexRun = insertedRun.runIndex + 1;
        completeExecuteAllCycles: for (var indexChunk = insertedRun.chunkIndex, chunk; chunk = subDocument.chunks[indexChunk]; indexChunk++) {
            for (var run; run = chunk.textRuns[indexRun]; indexRun++) {
                run.paragraph = newParagraph;
                run.onCharacterPropertiesChanged();
                if (run.isParagraphOrSectionRun())
                    break completeExecuteAllCycles;
            }
            indexRun = 0;
        }
        indexRun = insertedRun.runIndex - 1;
        completeExecuteAllCycles: for (var indexChunk = insertedRun.chunkIndex, chunk; chunk = subDocument.chunks[indexChunk]; indexChunk--) {
            for (var run; run = chunk.textRuns[indexRun]; indexRun--) {
                if (run.isParagraphOrSectionRun())
                    break completeExecuteAllCycles;
                run.onCharacterPropertiesChanged();
            }
            if (indexChunk > 0)
                indexRun = subDocument.chunks[indexChunk - 1].textRuns.length - 1;
        }
        subDocument.positionManager.unregisterPosition(oldSection.startLogPosition);
        var newSectionProperties;
        if (sectionProperties) {
            if (isInsertPropertiesToCurrentSection)
                newSectionProperties = sectionProperties;
            else {
                newSectionProperties = oldSection.sectionProperties;
                oldSection.sectionProperties = sectionProperties;
            }
        }
        else
            newSectionProperties = oldSection.sectionProperties;
        var newSection = new section_1.Section(subDocument.documentModel, subDocument.positionManager.registerPosition(oldSection.startLogPosition.value), lengthNewSection, newSectionProperties);
        newSection.headers = oldSection.headers;
        newSection.headers.section = newSection;
        newSection.footers = oldSection.footers;
        newSection.footers.section = newSection;
        oldSection.headers = new header_footer_1.SectionHeaders(oldSection);
        oldSection.footers = new header_footer_1.SectionFooters(oldSection);
        oldSection.startLogPosition = subDocument.positionManager.registerPosition(insertPositionAtStartDocument + 1);
        oldSection.setLength(subDocument, oldSection.getLength() - lengthNewSection - 1 + 1);
        subDocument.documentModel.sections.splice(oldSectionIndex, 0, newSection);
        this.modelManipulator.notifyModelChanged(new section_inserted_1.SectionInsertedSubDocumentChange(subDocument.id, insertPositionAtStartDocument, newSection, oldSectionIndex));
    };
    return SectionManipulator;
}(runs_base_manipulator_1.RunsBaseManipulator));
exports.SectionManipulator = SectionManipulator;
