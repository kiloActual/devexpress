import { FixedInterval } from '@devexpress/utils/lib/intervals/fixed';
import { Chunk } from '../../chunk';
import { DocumentModel } from '../../document-model';
import { Paragraph } from '../../paragraph/paragraph';
import { RunBase } from '../../runs/run-base';
import { Section } from '../../section/section';
import { SubDocument, SubDocumentIntervals, SubDocumentPosition } from '../../sub-document';
import { Table } from '../../tables/main-structures/table';
import { ModelManipulator } from '../model-manipulator';
import { SelectedTableInfo } from '../../../selection/selected-cells-engine';
export declare class CreateRangeCopyOperation {
    private subDocument;
    private documentModel;
    private oldCurrentChunk;
    private oldCurrentParagraph;
    private oldCurrentSection;
    private oldFieldStartIndex;
    private newCurrentChunk;
    private newCurrentSection;
    private newCurrentParagraph;
    private newOffsetAtStartChunk;
    private additionalParagraphRunPositions;
    private mapSourceTableIndexToTarget;
    constructor(subDocument: SubDocument);
    private copyStyles;
    execute(intervals: FixedInterval[]): RangeCopy;
    protected copyMainContent(interval: FixedInterval, newDocumentModel: DocumentModel, currIntervalOffset: number): void;
    protected appendField(newSubDocument: SubDocument, oldCurrentRun: RunBase, globalOffset: number): void;
    protected appendParagraphMarkInTheEnd(newSubDocument: SubDocument, position: number, sectionEnd: boolean): void;
    protected appendNewChunk(newSubDocument: SubDocument): Chunk;
    protected appendNewSection(newSubDocument: SubDocument): Section;
    protected appendNewParagraph(newSubDocument: SubDocument, abstractNumberingListCache: {
        [key: number]: number;
    }, numberingListCache: {
        [key: number]: number;
    }): Paragraph;
    protected tryAppendAdditionalParagraphRunInTheEnd(newSubDocument: SubDocument, sectionEnd: boolean): boolean;
    protected initNewDocumentModel(): DocumentModel;
    private getNestedLevel;
    protected copyTables(newSubDocument: SubDocument, intervals: FixedInterval[]): void;
    protected appendWholeTable(newSubDocument: SubDocument, table: Table, positionDelta: number, newNestedLevel: number): void;
    private appendParticallyTable;
    private canCopyParticallyTable;
    private cloneTableCell;
    private createTable;
    private getSelectedCells;
}
export declare class RangeCopy {
    model: DocumentModel;
    addedUselessParagraphMarkInEnd: boolean;
    constructor(model: DocumentModel, addedUselessParagraphMarkInEnd: boolean);
    insertTo(modelManipulator: ModelManipulator, subDocPosition: SubDocumentPosition): FixedInterval;
    insertToTable(modelManipulator: ModelManipulator, insertPosition: SubDocumentPosition, targetTableInfo: SelectedTableInfo): FixedInterval;
    overlapTableContent(modelManipulator: ModelManipulator, sourceTable: Table, targetTableInfo: SelectedTableInfo): FixedInterval;
    overlapTableCellContent(modelManipulator: ModelManipulator, sourceTable: Table, targetTableInfo: SelectedTableInfo, rowIndex: number, columnIndex: number): void;
    static create(subDocIntervals: SubDocumentIntervals): RangeCopy;
}
//# sourceMappingURL=create-range-copy-operation.d.ts.map
