"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var enum_1 = require("@devexpress/utils/lib/utils/enum");
var search_1 = require("@devexpress/utils/lib/utils/search");
var section_merged_1 = require("../../changes/model/section-merged");
var anchor_object_removed_1 = require("../../changes/sub-document/text/anchor-object-removed");
var interval_removed_1 = require("../../changes/sub-document/text/interval-removed");
var paragraph_merged_1 = require("../../changes/sub-document/text/paragraph-merged");
var history_runs_1 = require("../../character/history-runs");
var field_1 = require("../../fields/field");
var anchored_picture_run_1 = require("../../runs/anchored-picture-run");
var anchored_text_box_run_1 = require("../../runs/anchored-text-box-run");
var inline_picture_run_1 = require("../../runs/inline-picture-run");
var run_type_1 = require("../../runs/run-type");
var runs_base_manipulator_1 = require("../runs-base-manipulator");
var text_box_manipulator_1 = require("../text-box-manipulator");
var RemoveIntervalOperation = (function () {
    function RemoveIntervalOperation(manipulator, subDocument) {
        this.currentCellIndex = 0;
        this.modelManipulator = manipulator;
        this.subDocument = subDocument;
    }
    RemoveIntervalOperation.prototype.execute = function (interval, applyPropertiesToLeft, needHistory) {
        this.cellsIterator = new SelectedCellsIterator(this.subDocument, interval);
        var result = new RemoveIntervalOperationResult(this.cellsIterator);
        result.bookmarkItems = this.modelManipulator.bookmark.deleteBookmarks(this.subDocument, interval);
        if (this.tryPackSelectionInOneRun(interval, result))
            return result;
        var iterator = this.subDocument.getRunIterator(interval);
        if (needHistory)
            this.fillResult(interval, result);
        this.initializeStartPositions(interval.start);
        this.executeCore(applyPropertiesToLeft, interval.start, iterator, result);
        this.correctTablesStart();
        return result;
    };
    RemoveIntervalOperation.prototype.correctTablesStart = function () {
        for (var _i = 0, _a = this.subDocument.tables; _i < _a.length; _i++) {
            var tbl = _a[_i];
            var tblPos = tbl.getStartPosition();
            var parPos = this.subDocument.getParagraphByPosition(tblPos).startLogPosition.value;
            if (tblPos != parPos)
                this.modelManipulator.table.changeTableStartPosition(this.subDocument, tbl, parPos);
        }
    };
    RemoveIntervalOperation.prototype.initializeStartPositions = function (intervalStart) {
        this.position = intervalStart;
        this.currentChunkIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.subDocument.chunks, function (c) { return c.startLogPosition.value; }, intervalStart);
        this.currentSectionIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.subDocument.documentModel.sections, function (s) { return s.startLogPosition.value; }, intervalStart);
        this.currentParagraphIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.subDocument.paragraphs, function (p) { return p.startLogPosition.value; }, intervalStart);
        this.fieldIndexThatNeedDelete = -1;
    };
    RemoveIntervalOperation.prototype.executeCore = function (applyPropertiesToLeft, startPosition, iterator, result) {
        var subDocument = this.subDocument;
        var accumulatedInterval = new fixed_1.FixedInterval(this.position, 0);
        var removedTextList = [];
        while (iterator.moveNext()) {
            if (enum_1.EnumUtils.isAnyOf(iterator.currentRun.getType(), run_type_1.RunType.AnchoredPictureRun, run_type_1.RunType.AnchoredTextBoxRun))
                this.modelManipulator.notifyModelChanged(new anchor_object_removed_1.AnchorObjectRemovedSubDocumentChange(this.subDocument.id, (iterator.currentRun).anchoredObjectID, iterator.currentInterval().start));
            if (iterator.currentChunk !== subDocument.chunks[this.currentChunkIndex]) {
                this.removeAccumulatedInterval(accumulatedInterval, this.position, 0, removedTextList);
                this.currentChunkIndex++;
            }
            if (subDocument.documentModel.sections[this.currentSectionIndex] !== iterator.currentSection)
                this.currentSectionIndex++;
            var runIndex = search_1.SearchUtils.normedInterpolationIndexOf(subDocument.chunks[this.currentChunkIndex].textRuns, function (r) { return r.startOffset; }, iterator.currentRun.startOffset);
            if (iterator.currentRun.getType() == run_type_1.RunType.FieldCodeStartRun)
                this.removeField(startPosition);
            if (iterator.currentRun.getType() == run_type_1.RunType.ParagraphRun) {
                if (subDocument.paragraphs.length === 1) {
                    result.removeLastParagraphRun();
                    continue;
                }
            }
            iterator.currentRun.paragraph.length -= iterator.currentRun.getLength();
            this.modifySectionLength(iterator.currentSection, -iterator.currentRun.getLength());
            var strategy = this.getStrategy(iterator, accumulatedInterval);
            strategy.call(this, accumulatedInterval, removedTextList, runIndex);
        }
        this.removeAccumulatedInterval(accumulatedInterval, -1, 0, removedTextList);
        if (this.shouldMergeParagraphs)
            this.tryMergeStartEndParagraphs(startPosition, applyPropertiesToLeft);
        this.cellsIterator.reset();
    };
    RemoveIntervalOperation.prototype.modifySectionLength = function (section, delta) {
        section.setLength(this.subDocument, section.getLength() + delta);
    };
    RemoveIntervalOperation.prototype.getStrategy = function (iterator, accumulatedInterval) {
        if (!this.canRemoveRun(iterator.currentRun, iterator.currentRun.startOffset + iterator.currentChunk.startLogPosition.value + accumulatedInterval.length, iterator.currentRun.paragraph.length === 0))
            return this.skipRunAndMoveToNextParagraph;
        else if (iterator.currentRun.getType() === run_type_1.RunType.SectionRun && iterator.currentSection.getLength() == 0)
            return this.removeWholeSection;
        else if (iterator.currentRun.getType() === run_type_1.RunType.ParagraphRun && iterator.currentRun.paragraph.length === 0)
            return this.removeWholeParagraph;
        else if (iterator.currentRun.getType() === run_type_1.RunType.SectionRun && this.shouldMergeParagraphs && iterator.currentRun.paragraph.length === 0)
            return this.mergePreviousParagraph;
        else if (!iterator.currentRun.isParagraphOrSectionRun())
            return this.removeTextRun;
        else
            return this.skipParagraphRunAndMergeParagraphsAtTheEnd;
    };
    RemoveIntervalOperation.prototype.removeTextRun = function (accumulatedInterval, removedTextList, runIndex) {
        accumulatedInterval.length += this.subDocument.chunks[this.currentChunkIndex].textRuns[runIndex].getLength();
        removedTextList.push(this.removeRunInternal(this.subDocument, runIndex));
    };
    RemoveIntervalOperation.prototype.skipParagraphRunAndMergeParagraphsAtTheEnd = function (accumulatedInterval, removedTextList, runIndex) {
        this.skipRunAndMoveToNextParagraph(accumulatedInterval, removedTextList, runIndex);
        this.shouldMergeParagraphs = true;
    };
    RemoveIntervalOperation.prototype.skipRunAndMoveToNextParagraph = function (accumulatedInterval, removedTextList, _runIndex) {
        this.subDocument.paragraphs[this.currentParagraphIndex].length++;
        this.modifySectionLength(this.subDocument.documentModel.sections[this.currentSectionIndex], 1);
        this.position++;
        this.removeAccumulatedInterval(accumulatedInterval, this.position, 0, removedTextList);
        this.currentParagraphIndex++;
    };
    RemoveIntervalOperation.prototype.mergePreviousParagraph = function (accumulatedInterval, removedTextList, runIndex) {
        if (runIndex === 0)
            this.currentChunkIndex--;
        var paragraphIndex = this.currentParagraphIndex;
        var par = this.subDocument.paragraphs[paragraphIndex];
        var remodedParagraphMarkPos = par.getEndPosition() - 1;
        par.length++;
        this.removeAccumulatedInterval(accumulatedInterval, this.position, 0, removedTextList);
        this.mergeParagraphsInternal(this.subDocument, paragraphIndex - 1, false);
        this.modelManipulator.notifyModelChanged(new paragraph_merged_1.ParagraphMergedSubDocumentChange(this.subDocument.id, new fixed_1.FixedInterval(remodedParagraphMarkPos, 1), this.subDocument.paragraphs[paragraphIndex - 1].getEndPosition() - 1, false));
    };
    RemoveIntervalOperation.prototype.removeWholeSection = function (accumulatedInterval, removedTextList, runIndex) {
        var subDocument = this.subDocument;
        var currentSection = subDocument.documentModel.sections[this.currentSectionIndex];
        this.removeAccumulatedInterval(accumulatedInterval, this.position, -1, removedTextList);
        if (subDocument.documentModel.sections.length > 1) {
            var deletedSectionMarkPosition = currentSection.getEndPosition();
            subDocument.positionManager.unregisterPosition(currentSection.startLogPosition);
            subDocument.documentModel.sections.splice(this.currentSectionIndex, 1);
            subDocument.positionManager.unregisterPosition(subDocument.paragraphs[this.currentParagraphIndex].startLogPosition);
            subDocument.paragraphs.splice(this.currentParagraphIndex, 1);
            this.removeRunInternal(subDocument, runIndex);
            this.currentSectionIndex--;
            this.modelManipulator.notifyModelChanged(new section_merged_1.SectionMergedSubDocumentChange(this.currentSectionIndex + 1, new fixed_1.FixedInterval(deletedSectionMarkPosition, 1), false));
        }
    };
    RemoveIntervalOperation.prototype.removeWholeParagraph = function (accumulatedInterval, removedTextList, runIndex) {
        var subDocument = this.subDocument;
        this.removeAccumulatedInterval(accumulatedInterval, this.position, -1, removedTextList);
        if (subDocument.paragraphs.length > 1) {
            var pos = subDocument.paragraphs[this.currentParagraphIndex].startLogPosition;
            var removedParagraphMarkPos = pos.value;
            subDocument.positionManager.unregisterPosition(pos);
            subDocument.paragraphs.splice(this.currentParagraphIndex, 1);
            this.removeRunInternal(subDocument, runIndex);
            this.modelManipulator.notifyModelChanged(new paragraph_merged_1.ParagraphMergedSubDocumentChange(subDocument.id, new fixed_1.FixedInterval(removedParagraphMarkPos, 1), this.position, false));
        }
    };
    RemoveIntervalOperation.prototype.tryMergeStartEndParagraphs = function (startPosition, applyPropertiesToLeft) {
        var subDocument = this.subDocument;
        var firstParagraphIndex = subDocument.getParagraphIndexByPosition(startPosition), firstParagraph = subDocument.paragraphs[firstParagraphIndex], lastParagraph = subDocument.paragraphs[firstParagraphIndex + 1];
        var firstSectionIndex = search_1.SearchUtils.normedInterpolationIndexOf(subDocument.documentModel.sections, function (s) { return s.startLogPosition.value; }, firstParagraph.startLogPosition.value), firstSection = subDocument.documentModel.sections[firstSectionIndex];
        if (lastParagraph) {
            this.modifySectionLength(firstSection, -1);
            if (this.subDocument.isMain() && firstSection.getEndPosition() === firstParagraph.getEndPosition() - 1 && firstSectionIndex < subDocument.documentModel.sections.length - 1) {
                var lastSection = subDocument.documentModel.sections[firstSectionIndex + 1];
                var deletedSectionMarkPos = firstSection.getEndPosition();
                subDocument.positionManager.unregisterPosition(lastSection.startLogPosition);
                lastSection.startLogPosition = subDocument.positionManager.registerPosition(firstSection.startLogPosition.value);
                this.modifySectionLength(lastSection, firstSection.getLength());
                subDocument.positionManager.unregisterPosition(firstSection.startLogPosition);
                subDocument.documentModel.sections.splice(firstSectionIndex, 1);
                this.mergeParagraphsInternal(subDocument, firstParagraphIndex, applyPropertiesToLeft);
                this.modelManipulator.notifyModelChanged(new section_merged_1.SectionMergedSubDocumentChange(firstSectionIndex, new fixed_1.FixedInterval(deletedSectionMarkPos, 1), !!applyPropertiesToLeft));
            }
            else {
                var deletedParagraphMarkPos = lastParagraph.startLogPosition.value - 1;
                this.mergeParagraphsInternal(subDocument, firstParagraphIndex, applyPropertiesToLeft);
                this.modelManipulator.notifyModelChanged(new paragraph_merged_1.ParagraphMergedSubDocumentChange(subDocument.id, new fixed_1.FixedInterval(deletedParagraphMarkPos, 1), lastParagraph.startLogPosition.value - 1, !!applyPropertiesToLeft));
            }
        }
    };
    RemoveIntervalOperation.prototype.removeField = function (startPosition) {
        if (this.fieldIndexThatNeedDelete < 0) {
            this.fieldIndexThatNeedDelete = field_1.Field.normedBinaryIndexOf(this.subDocument.fields, startPosition + 1);
            if (this.fieldIndexThatNeedDelete < 0 || startPosition > this.subDocument.fields[this.fieldIndexThatNeedDelete].getFieldStartPosition())
                this.fieldIndexThatNeedDelete++;
        }
        field_1.Field.deleteFieldByIndex(this.subDocument, this.fieldIndexThatNeedDelete, this.modelManipulator);
    };
    RemoveIntervalOperation.prototype.tryPackSelectionInOneRun = function (interval, result) {
        var runInfo = this.subDocument.getRunAndIndexesByPosition(interval.start);
        var runStartPosition = runInfo.chunk.startLogPosition.value + runInfo.run.startOffset;
        var runEndPosition = runStartPosition + runInfo.run.getLength();
        var selectionEndPosition = interval.end;
        var selectionStartPosition = interval.start;
        if ((runStartPosition < selectionStartPosition) && (selectionEndPosition < runEndPosition)) {
            var chunkStartPosition = runInfo.chunk.startLogPosition.value;
            var offsetStartSelectionAtChunk = selectionStartPosition - chunkStartPosition;
            var offsetEndSelectionAtChunk = selectionEndPosition - chunkStartPosition;
            var removedText = runInfo.chunk.getTextInChunk(offsetStartSelectionAtChunk, interval.length);
            result.registerItem(new history_runs_1.HistoryRun(runInfo.run.getType(), runInfo.run.getCharPropsBundle(this.modelManipulator.model), selectionStartPosition, removedText));
            runInfo.run.incLength(-interval.length);
            runInfo.chunk.textBuffer = [runInfo.chunk.textBuffer.substr(0, offsetStartSelectionAtChunk), runInfo.chunk.textBuffer.substr(offsetEndSelectionAtChunk)].join('');
            var paragraphIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.subDocument.paragraphs, function (p) { return p.startLogPosition.value; }, selectionStartPosition);
            this.subDocument.paragraphs[paragraphIndex].length -= interval.length;
            var sectionIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.subDocument.documentModel.sections, function (s) { return s.startLogPosition.value; }, selectionStartPosition);
            this.modifySectionLength(this.subDocument.documentModel.sections[sectionIndex], -interval.length);
            runs_base_manipulator_1.RunsBaseManipulator.moveRunsInChunk(runInfo.chunk, runInfo.runIndex + 1, -interval.length);
            this.subDocument.positionManager.advance(selectionStartPosition, -interval.length);
            this.modelManipulator.notifyModelChanged(new interval_removed_1.IntervalRemovedSubDocumentChange(this.subDocument.id, interval, removedText));
            return true;
        }
        return false;
    };
    RemoveIntervalOperation.prototype.canRemoveRun = function (run, absolutePosition, isLastRunInParagraph) {
        if (run.getType() === run_type_1.RunType.ParagraphRun) {
            this.cellsIterator.moveTo(absolutePosition);
            var currentCell = this.cellsIterator.getCurrent();
            if (currentCell && absolutePosition === currentCell.endParagrapPosition.value - 1)
                return false;
            var nextCell = this.cellsIterator.getNext();
            if (nextCell && nextCell.startParagraphPosition.value === absolutePosition + 1) {
                if (!isLastRunInParagraph)
                    return false;
                var prevCell = this.cellsIterator.getPrev();
                if (prevCell && prevCell.parentRow.parentTable.getLastCell() === prevCell)
                    return false;
            }
        }
        return true;
    };
    RemoveIntervalOperation.prototype.fillResult = function (interval, result) {
        var iterator = this.subDocument.getRunIterator(interval);
        var isInsertPropertiesAndStyleIndexToCurrentParagraph = undefined;
        var lastParagraphRemovingLength = 0;
        while (iterator.moveNext()) {
            var currentRun = iterator.currentRun;
            var currentChunk = iterator.currentChunk;
            var currentInterval = iterator.currentInterval();
            lastParagraphRemovingLength += currentInterval.length;
            if (!this.canRemoveRun(currentRun, currentInterval.start, iterator.currentRun.paragraph.length === lastParagraphRemovingLength)) {
                if (currentRun.isParagraphOrSectionRun())
                    lastParagraphRemovingLength = 0;
                continue;
            }
            switch (currentRun.getType()) {
                case run_type_1.RunType.TextRun:
                    result.registerItem(new history_runs_1.HistoryRun(currentRun.getType(), currentRun.getCharPropsBundle(this.modelManipulator.model), currentInterval.start, currentChunk.getRunText(currentRun)));
                    break;
                case run_type_1.RunType.ParagraphRun:
                case run_type_1.RunType.SectionRun:
                    if (isInsertPropertiesAndStyleIndexToCurrentParagraph === undefined)
                        isInsertPropertiesAndStyleIndexToCurrentParagraph = currentRun.paragraph.startLogPosition.value == interval.start;
                    var paragraph;
                    if (isInsertPropertiesAndStyleIndexToCurrentParagraph)
                        paragraph = currentRun.paragraph;
                    else {
                        var nextParagraphIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.subDocument.paragraphs, function (p) { return p.startLogPosition.value; }, currentRun.paragraph.startLogPosition.value) + 1;
                        paragraph = this.subDocument.paragraphs[nextParagraphIndex];
                    }
                    if (currentRun.getType() == run_type_1.RunType.ParagraphRun) {
                        result.registerItem(new history_runs_1.HistoryRunParagraph(currentRun.getType(), currentRun.getCharPropsBundle(this.modelManipulator.model), paragraph.getParagraphBundleFull(this.modelManipulator.model), currentInterval.start, currentChunk.getRunText(currentRun), isInsertPropertiesAndStyleIndexToCurrentParagraph));
                    }
                    else {
                        result.registerItem(new history_runs_1.HistoryRunSection(currentRun.getCharPropsBundle(this.modelManipulator.model), paragraph.getParagraphBundleFull(this.modelManipulator.model), iterator.currentSection, currentInterval.start, isInsertPropertiesAndStyleIndexToCurrentParagraph));
                    }
                    lastParagraphRemovingLength = 0;
                    break;
                case run_type_1.RunType.InlinePictureRun:
                    var currentPictureRun = currentRun;
                    if (!(currentPictureRun instanceof inline_picture_run_1.InlinePictureRun))
                        throw new Error("In TexManipulator.getHistoryRunsFromInterval currentPictureRun not have type InlinePictureRun");
                    result.registerItem(new history_runs_1.HistoryRunInlinePicture(currentInterval.start, currentRun.getCharPropsBundle(this.modelManipulator.model), currentPictureRun.info.clone()));
                    break;
                case run_type_1.RunType.FieldCodeStartRun:
                    var globalOffset = currentInterval.start;
                    var fieldIndex = field_1.Field.normedBinaryIndexOf(this.subDocument.fields, globalOffset + 1);
                    var field = this.subDocument.fields[fieldIndex];
                    result.registerItem(new history_runs_1.HistoryRunFieldCodeStart(currentRun.getType(), currentRun.getCharPropsBundle(this.modelManipulator.model), globalOffset, currentChunk.getRunText(currentRun), field.showCode, field.getFieldStartPosition(), field.getSeparatorPosition(), field.getFieldEndPosition(), field.getHyperlinkInfo() ? field.getHyperlinkInfo().clone() : undefined));
                    break;
                case run_type_1.RunType.FieldCodeEndRun:
                    result.registerItem(new history_runs_1.HistoryRunFieldCodeEnd(currentRun.getType(), currentRun.getCharPropsBundle(this.modelManipulator.model), currentInterval.start, currentChunk.getRunText(currentRun)));
                    break;
                case run_type_1.RunType.FieldResultEndRun:
                    result.registerItem(new history_runs_1.HistoryRunFieldResultEnd(currentRun.getType(), currentRun.getCharPropsBundle(this.modelManipulator.model), currentInterval.start, currentChunk.getRunText(currentRun)));
                    break;
                case run_type_1.RunType.AnchoredPictureRun:
                    var currentAnchoredRun = currentRun;
                    if (!(currentAnchoredRun instanceof anchored_picture_run_1.AnchoredPictureRun))
                        throw new Error("In TextManipulator.getHistoryRunsFromInterval currentAnchoredRun is not of type AnchoredPictureRun");
                    result.registerItem(new history_runs_1.HistoryRunAnchoredPicture(currentRun.getCharPropsBundle(this.modelManipulator.model), currentAnchoredRun.info.clone(), currentInterval.start));
                    break;
                case run_type_1.RunType.AnchoredTextBoxRun:
                    var currentAnchoredTextBoxRun = currentRun;
                    if (!(currentAnchoredTextBoxRun instanceof anchored_text_box_run_1.AnchoredTextBoxRun))
                        throw new Error("In TextManipulator.getHistoryRunsFromInterval currentAnchoredTextBoxRun is not of type AnchoredTextBoxRun");
                    result.registerItem(new history_runs_1.HistoryRunAnchoredTextBox(currentRun.getCharPropsBundle(this.modelManipulator.model), new text_box_manipulator_1.BaseTextBoxInfo(this.modelManipulator.model.subDocuments[currentAnchoredTextBoxRun.subDocId], currentAnchoredTextBoxRun.size.clone(), currentAnchoredTextBoxRun.shape.clone(), currentAnchoredTextBoxRun.anchorInfo.clone(), currentAnchoredTextBoxRun.textBoxProperties.clone(), currentAnchoredTextBoxRun.containerProperties.clone()), currentInterval.start));
                    break;
            }
        }
        iterator.reset();
        this.cellsIterator.reset();
    };
    RemoveIntervalOperation.prototype.removeAccumulatedInterval = function (removingInterval, newPosition, advanceDelta, removedTextList) {
        advanceDelta -= removingInterval.length;
        if (Math.abs(advanceDelta) > 0)
            this.subDocument.positionManager.advance(removingInterval.start, advanceDelta);
        if (removingInterval.length) {
            var removedText = removedTextList.join('');
            this.modelManipulator.notifyModelChanged(new interval_removed_1.IntervalRemovedSubDocumentChange(this.subDocument.id, removingInterval.clone(), removedText));
            removedTextList.splice(0);
        }
        removingInterval.start = newPosition;
        removingInterval.length = 0;
    };
    RemoveIntervalOperation.prototype.mergeParagraphsInternal = function (subDocument, paragraphIndex, setPropertiesSecondParagraph) {
        var firstParagraph = subDocument.paragraphs[paragraphIndex];
        var lastParagraph = subDocument.paragraphs[paragraphIndex + 1];
        var runInfo = subDocument.getRunAndIndexesByPosition(lastParagraph.startLogPosition.value - 1);
        if (setPropertiesSecondParagraph)
            this.copyPropertiesToParagraph(firstParagraph, lastParagraph);
        var runs = subDocument.getRunsByInterval(new fixed_1.FixedInterval(lastParagraph.startLogPosition.value, lastParagraph.length));
        var chunkIndexDelta = this.currentChunkIndex - runInfo.chunkIndex;
        this.currentChunkIndex = runInfo.chunkIndex;
        this.removeRunInternal(subDocument, runInfo.runIndex);
        this.currentChunkIndex += chunkIndexDelta;
        firstParagraph.length--;
        for (var i = 0, run; run = runs[i]; i++) {
            run.paragraph = firstParagraph;
            run.onCharacterPropertiesChanged();
            firstParagraph.length += run.getLength();
        }
        subDocument.positionManager.advance(lastParagraph.startLogPosition.value - 1, -1);
        subDocument.positionManager.unregisterPosition(lastParagraph.startLogPosition);
        subDocument.paragraphs.splice(paragraphIndex + 1, 1);
    };
    RemoveIntervalOperation.prototype.removeRunInternal = function (subDocument, runIndex) {
        var currentChunk = subDocument.chunks[this.currentChunkIndex];
        var currentRun = currentChunk.textRuns[runIndex];
        var removedText = currentChunk.textBuffer.substr(currentRun.startOffset, currentRun.getLength());
        currentChunk.textBuffer = currentChunk.textBuffer.substr(0, currentRun.startOffset) + currentChunk.textBuffer.substr(currentRun.startOffset + currentRun.getLength());
        currentChunk.textRuns.splice(runIndex, 1);
        runs_base_manipulator_1.RunsBaseManipulator.moveRunsInChunk(currentChunk, runIndex, -currentRun.getLength());
        if (currentChunk.textRuns.length === 0) {
            subDocument.positionManager.unregisterPosition(currentChunk.startLogPosition);
            subDocument.chunks.splice(this.currentChunkIndex--, 1);
        }
        return removedText;
    };
    RemoveIntervalOperation.prototype.copyPropertiesToParagraph = function (to, from) {
        to.paragraphStyle = from.paragraphStyle;
        to.setParagraphProperties(from.maskedParagraphProperties);
        if (from.hasParagraphMergedProperies())
            to.setParagraphMergedProperies(from.getParagraphMergedProperties());
        to.numberingListIndex = from.numberingListIndex;
        to.listLevelIndex = from.listLevelIndex;
        to.tabs = from.tabs.clone();
    };
    return RemoveIntervalOperation;
}());
exports.RemoveIntervalOperation = RemoveIntervalOperation;
var RemoveIntervalOperationResult = (function () {
    function RemoveIntervalOperationResult(cellsIterator) {
        this.historyRuns = [];
        this.nestingLevels = [];
        this.bookmarkItems = [];
        this.cellsIterator = cellsIterator;
    }
    RemoveIntervalOperationResult.prototype.registerItem = function (historyRun) {
        this.cellsIterator.moveTo(historyRun.offsetAtStartDocument);
        var cell = this.cellsIterator.getCurrent();
        this.registerItemCore(historyRun, cell ? cell.parentRow.parentTable.nestedLevel : -1);
    };
    RemoveIntervalOperationResult.prototype.registerItemCore = function (historyRun, nestingLevel) {
        this.historyRuns.push(historyRun);
        this.nestingLevels.push(nestingLevel);
    };
    RemoveIntervalOperationResult.prototype.removeLastParagraphRun = function () {
        var lastIndex = this.historyRuns.length - 1;
        var lastHistoryRun = this.historyRuns[lastIndex];
        if (lastHistoryRun && lastHistoryRun.type == run_type_1.RunType.ParagraphRun) {
            this.historyRuns.splice(lastIndex, 1);
            this.nestingLevels.splice(lastIndex, 1);
        }
    };
    RemoveIntervalOperationResult.prototype.getIterator = function () {
        return new RemoveIntervalOperationResultIterator(this.historyRuns, this.nestingLevels);
    };
    return RemoveIntervalOperationResult;
}());
exports.RemoveIntervalOperationResult = RemoveIntervalOperationResult;
var SelectedCellsIterator = (function () {
    function SelectedCellsIterator(subDocument, interval) {
        this.current = 0;
        this.cells = SelectedCellsIterator.getCellsByInterval(subDocument, interval);
    }
    SelectedCellsIterator.prototype.moveTo = function (position) {
        if (position < this.position)
            this.reset();
        this.position = position;
        var cell;
        while (cell = this.cells[this.current]) {
            if (position >= cell.endParagrapPosition.value)
                this.current++;
            else
                return true;
        }
        return false;
    };
    SelectedCellsIterator.prototype.getCurrent = function () {
        var cell = this.cells[this.current];
        return cell ? SelectedCellsIterator.correctCurrent(this.position, cell) : null;
    };
    SelectedCellsIterator.prototype.getPrev = function () {
        var cell = this.cells[this.current];
        if (cell && this.position >= cell.endParagrapPosition.value)
            return cell;
        return this.cells[this.current - 1] || null;
    };
    SelectedCellsIterator.prototype.getNext = function () {
        var cell = this.cells[this.current];
        if (cell && this.position < cell.startParagraphPosition.value)
            return cell;
        return this.cells[this.current + 1] || null;
    };
    SelectedCellsIterator.prototype.reset = function () {
        this.current = 0;
        this.position = 0;
    };
    SelectedCellsIterator.getCellsByInterval = function (subDocument, interval) {
        if (subDocument.tables.length === 0)
            return [];
        var table = subDocument.tablesByLevels[0][Math.max(0, search_1.SearchUtils.normedInterpolationIndexOf(subDocument.tablesByLevels[0], function (t) { return t.getStartPosition(); }, interval.start))];
        var intervalEnd = interval.end;
        if (intervalEnd < table.getStartPosition())
            return [];
        var result = [];
        this.collectCellsByIntervalCore(subDocument, result, table, interval.start, intervalEnd);
        return result.sort(function (c1, c2) { return c1.endParagrapPosition.value - c2.endParagrapPosition.value; });
    };
    SelectedCellsIterator.collectCellsByIntervalCore = function (subDocument, result, table, intervalStart, intervalEnd) {
        var nextTable = subDocument.tables[table.index + 1];
        if (nextTable && nextTable.getStartPosition() <= intervalEnd)
            this.collectCellsByIntervalCore(subDocument, result, nextTable, intervalStart, intervalEnd);
        for (var rowIndex = 0, row = void 0; row = table.rows[rowIndex]; rowIndex++) {
            for (var cellIndex = 0, cell = void 0; cell = row.cells[cellIndex]; cellIndex++) {
                if (intervalStart < cell.endParagrapPosition.value && intervalEnd > cell.startParagraphPosition.value)
                    result.push(cell);
                else if (intervalStart === cell.endParagrapPosition.value && cell.parentRow.parentTable.getLastCell() === cell)
                    result.push(cell);
                else if (cell.parentRow.parentTable.getFirstCell() === cell && cell.startParagraphPosition.value === intervalEnd)
                    result.push(cell);
                else if (cell.startParagraphPosition.value > intervalEnd)
                    return;
            }
        }
    };
    SelectedCellsIterator.correctCurrent = function (position, cell) {
        if (position >= cell.startParagraphPosition.value && position < cell.endParagrapPosition.value)
            return cell;
        if (position < cell.startParagraphPosition.value && cell.parentRow.parentTable.parentCell)
            return this.correctCurrent(position, cell.parentRow.parentTable.parentCell);
        return null;
    };
    return SelectedCellsIterator;
}());
exports.SelectedCellsIterator = SelectedCellsIterator;
var RemoveIntervalOperationResultIterator = (function () {
    function RemoveIntervalOperationResultIterator(historyRuns, nestingLevels) {
        this.position = -1;
        this.historyRuns = historyRuns;
        this.nestingLevels = nestingLevels;
    }
    RemoveIntervalOperationResultIterator.prototype.moveNext = function () {
        this.position++;
        this.currentHistoryRun = this.historyRuns[this.position];
        this.currentNestingLevel = this.nestingLevels[this.position];
        return !!this.currentHistoryRun;
    };
    return RemoveIntervalOperationResultIterator;
}());
exports.RemoveIntervalOperationResultIterator = RemoveIntervalOperationResultIterator;
