"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var search_1 = require("@devexpress/utils/lib/utils/search");
var bookmarks_1 = require("../../bookmarks");
var hyperlink_info_changed_1 = require("../../changes/sub-document/field/hyperlink-info-changed");
var inserted_1 = require("../../changes/sub-document/field/inserted");
var history_runs_1 = require("../../character/history-runs");
var field_1 = require("../../fields/field");
var run_type_1 = require("../../runs/run-type");
var sub_document_1 = require("../../sub-document");
var sub_document_inserter_1 = require("../document/sub-document-inserter");
var insert_paragraph_manipulator_params_1 = require("../paragraph-manipulator/insert-paragraph-manipulator-params");
var insert_text_manipulator_params_1 = require("../text-manipulator/insert-text-manipulator-params");
var RestoreRemovedIntervalOperation = (function () {
    function RestoreRemovedIntervalOperation(manipulator, subDocument) {
        this.currentTableIndex = undefined;
        this.modelManipulator = manipulator;
        this.subDocument = subDocument;
    }
    RestoreRemovedIntervalOperation.prototype.execute = function (removeOperationResult) {
        var iterator = removeOperationResult.getIterator();
        var subDocument = this.subDocument;
        var fields = this.subDocument.fields;
        var fieldStackHistory = [];
        while (iterator.moveNext()) {
            var historyRun = iterator.currentHistoryRun;
            switch (historyRun.type) {
                case run_type_1.RunType.ParagraphRun: {
                    if (!(historyRun instanceof history_runs_1.HistoryRunParagraph))
                        throw new Error("In unpackHistoryRunsToModel type text run = TextRunType.ParagraphRun, but type historyRun != HistoryRunParagraph. historyRun.offsetAtStartDocument = " +
                            historyRun.offsetAtStartDocument + ", historyRun.text = " + historyRun.text);
                    var historyRunParagraph = historyRun;
                    var currentTable = this.getTableForShifting(historyRunParagraph.offsetAtStartDocument);
                    this.modelManipulator.paragraph.insertParagraphInner(new insert_paragraph_manipulator_params_1.InsertParagraphManipulatorParams(new sub_document_1.SubDocumentPosition(subDocument, historyRunParagraph.offsetAtStartDocument), historyRunParagraph.charPropsBundle, historyRunParagraph.parPropsBundle, historyRunParagraph.applyDirectlyToNewParagraph));
                    if (currentTable && currentTable.nestedLevel > iterator.currentNestingLevel)
                        this.shiftTablesToPosition(currentTable, historyRunParagraph.offsetAtStartDocument + 1, iterator.currentNestingLevel);
                    break;
                }
                case run_type_1.RunType.SectionRun: {
                    if (!(historyRun instanceof history_runs_1.HistoryRunSection))
                        throw new Error("In unpackHistoryRunsToModel type text run = TextRunType.SectionRun, but type historyRun != HistoryRunSection. historyRun.offsetAtStartDocument = " +
                            historyRun.offsetAtStartDocument + ", historyRun.text = " + historyRun.text);
                    var historyRunSection = historyRun;
                    this.modelManipulator.section.insertSection(new sub_document_1.SubDocumentPosition(subDocument, historyRunSection.offsetAtStartDocument), historyRunSection.charPropsBundle, historyRunSection.sectionProperties, true, historyRunSection.parPropsBundle, historyRunSection.applyDirectlyToNewParagraph);
                    break;
                }
                case run_type_1.RunType.InlinePictureRun: {
                    if (!(historyRun instanceof history_runs_1.HistoryRunInlinePicture))
                        throw new Error("In unpackHistoryRunsToModel type text run = TextRunType.InlinePictureRun, but type historyRun != HistoryRunInlinePicture. historyRun.offsetAtStartDocument = " +
                            historyRun.offsetAtStartDocument + ", historyRun.text = " + historyRun.text);
                    var inlineHistoryRun = historyRun;
                    this.modelManipulator.picture.insertInlinePictureInner(new sub_document_1.SubDocumentPosition(subDocument, inlineHistoryRun.offsetAtStartDocument), inlineHistoryRun.charPropsBundle, inlineHistoryRun.picInfo, inlineHistoryRun.options);
                    break;
                }
                case run_type_1.RunType.FieldCodeStartRun: {
                    if (!(historyRun instanceof history_runs_1.HistoryRunFieldCodeStart))
                        throw new Error("In unpackHistoryRunsToModel type text run = TextRunType.HistoryRunFieldCodeStart, but type historyRun != HistoryRunFieldCodeStart. historyRun.offsetAtStartDocument = " +
                            historyRun.offsetAtStartDocument + ", historyRun.text = " + historyRun.text);
                    fieldStackHistory.push(historyRun);
                    this.modelManipulator.text.insertTextInner(new insert_text_manipulator_params_1.InsertTextManipulatorParams(new sub_document_1.SubDocumentPosition(subDocument, historyRun.offsetAtStartDocument), historyRun.charPropsBundle, historyRun.type, historyRun.text));
                    break;
                }
                case run_type_1.RunType.FieldResultEndRun: {
                    this.modelManipulator.text.insertTextInner(new insert_text_manipulator_params_1.InsertTextManipulatorParams(new sub_document_1.SubDocumentPosition(subDocument, historyRun.offsetAtStartDocument), historyRun.charPropsBundle, historyRun.type, historyRun.text));
                    var histFieldCodeStartRun = fieldStackHistory.pop();
                    var fieldInsertIndex = 0;
                    if (fields.length > 0) {
                        fieldInsertIndex = Math.max(0, field_1.Field.normedBinaryIndexOf(fields, histFieldCodeStartRun.startPosition + 1));
                        if (histFieldCodeStartRun.startPosition > fields[fieldInsertIndex].getFieldStartPosition())
                            fieldInsertIndex++;
                    }
                    var newField = new field_1.Field(subDocument.positionManager, fieldInsertIndex, histFieldCodeStartRun.startPosition, histFieldCodeStartRun.separatorPosition, histFieldCodeStartRun.endPosition, histFieldCodeStartRun.showCode, histFieldCodeStartRun.hyperlinkInfo ? histFieldCodeStartRun.hyperlinkInfo.clone() : undefined);
                    field_1.Field.addField(fields, newField);
                    this.modelManipulator.notifyModelChanged(new inserted_1.FieldInsertedSubDocumentChange(subDocument.id, histFieldCodeStartRun.startPosition, histFieldCodeStartRun.separatorPosition, histFieldCodeStartRun.endPosition));
                    if (histFieldCodeStartRun.hyperlinkInfo)
                        this.modelManipulator.notifyModelChanged(new hyperlink_info_changed_1.HyperlinkInfoChangedSubDocumentChange(subDocument.id, fixed_1.FixedInterval.fromPositions(histFieldCodeStartRun.separatorPosition + 1, histFieldCodeStartRun.endPosition - 1), fixed_1.FixedInterval.fromPositions(histFieldCodeStartRun.startPosition + 1, histFieldCodeStartRun.endPosition), histFieldCodeStartRun.hyperlinkInfo));
                    break;
                }
                case run_type_1.RunType.AnchoredPictureRun: {
                    var anchoredPictureHistoryRun = historyRun;
                    this.modelManipulator.picture.insertAnchoredPictureInner(new sub_document_1.SubDocumentPosition(subDocument, historyRun.offsetAtStartDocument), historyRun.charPropsBundle, anchoredPictureHistoryRun.picInfo);
                    break;
                }
                case run_type_1.RunType.AnchoredTextBoxRun: {
                    var anchoredTextBoxHistoryRun = historyRun;
                    var innerSubDocument = anchoredTextBoxHistoryRun.textBoxInfo.innerSubDocument;
                    anchoredTextBoxHistoryRun.textBoxInfo.innerSubDocument = null;
                    var newTextBoxRun = this.modelManipulator.textBox.insertAnchoredTextBox(new sub_document_1.SubDocumentPosition(subDocument, historyRun.offsetAtStartDocument), historyRun.charPropsBundle, anchoredTextBoxHistoryRun.textBoxInfo);
                    this.modelManipulator.subDocument.insertSubDocument(new sub_document_1.SubDocumentPosition(this.modelManipulator.model.subDocuments[newTextBoxRun.subDocId], 0), new sub_document_1.SubDocumentInterval(innerSubDocument, new fixed_1.FixedInterval(0, innerSubDocument.getDocumentEndPosition() - 1)), new sub_document_inserter_1.SubDocumentInserterOptions().set('insertParagraphMarkBeforeIfStartsWithTable', false));
                    break;
                }
                default: {
                    this.modelManipulator.text.insertTextInner(new insert_text_manipulator_params_1.InsertTextManipulatorParams(new sub_document_1.SubDocumentPosition(subDocument, historyRun.offsetAtStartDocument), historyRun.charPropsBundle, historyRun.type, historyRun.text));
                    break;
                }
            }
        }
        for (var _i = 0, _a = removeOperationResult.bookmarkItems; _i < _a.length; _i++) {
            var bkmTemplate = _a[_i];
            this.modelManipulator.bookmark.createBookmark(subDocument, bkmTemplate, false);
        }
        subDocument.bookmarks = subDocument.bookmarks.sort(bookmarks_1.ConstBookmark.comparer);
    };
    RestoreRemovedIntervalOperation.prototype.shiftTablesToPosition = function (table, position, minNestingLevel) {
        this.modelManipulator.table.changeTableStartPosition(this.subDocument, table, position);
        var prevTable = this.subDocument.tables[table.index - 1];
        if (prevTable && prevTable.nestedLevel > minNestingLevel)
            this.shiftTablesToPosition(prevTable, position, minNestingLevel);
    };
    RestoreRemovedIntervalOperation.prototype.getTableForShifting = function (position) {
        if (this.currentTableIndex === undefined) {
            this.currentTableIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.subDocument.tables, function (t) { return t.getStartPosition(); }, position);
            while (this.currentTableIndex > -1 && this.subDocument.tables[this.currentTableIndex].nestedLevel > 0)
                this.currentTableIndex--;
        }
        var table;
        while (table = this.subDocument.tables[this.currentTableIndex]) {
            if (position >= table.getEndPosition()) {
                this.currentTableIndex++;
                continue;
            }
            else if (position < table.getStartPosition())
                return null;
            var nextTable = this.subDocument.tables[this.currentTableIndex + 1];
            if (!nextTable || nextTable.getStartPosition() > position)
                return table;
            this.currentTableIndex++;
        }
        return null;
    };
    return RestoreRemovedIntervalOperation;
}());
exports.RestoreRemovedIntervalOperation = RestoreRemovedIntervalOperation;
