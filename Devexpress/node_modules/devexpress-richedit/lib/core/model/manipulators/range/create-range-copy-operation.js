"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var map_creator_1 = require("../../../../base-utils/map-creator");
var errors_1 = require("@devexpress/utils/lib/errors");
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var list_1 = require("@devexpress/utils/lib/utils/list");
var search_1 = require("@devexpress/utils/lib/utils/search");
var properties_bundle_1 = require("../../../rich-utils/properties-bundle");
var chunk_1 = require("../../chunk");
var document_model_1 = require("../../document-model");
var field_1 = require("../../fields/field");
var numbering_list_1 = require("../../numbering-lists/numbering-list");
var paragraph_1 = require("../../paragraph/paragraph");
var rich_utils_1 = require("../../rich-utils");
var run_type_1 = require("../../runs/run-type");
var simple_runs_1 = require("../../runs/simple-runs");
var section_1 = require("../../section/section");
var sub_document_1 = require("../../sub-document");
var table_1 = require("../../tables/main-structures/table");
var table_cell_1 = require("../../tables/main-structures/table-cell");
var table_row_1 = require("../../tables/main-structures/table-row");
var table_units_1 = require("../../tables/secondary-structures/table-units");
var table_utils_1 = require("../../tables/table-utils");
var bookmarks_manipulator_1 = require("../bookmarks-manipulator");
var tables_manipulator_1 = require("../tables/tables-manipulator");
var common_1 = require("@devexpress/utils/lib/utils/common");
var CreateRangeCopyOperation = (function () {
    function CreateRangeCopyOperation(subDocument) {
        this.newOffsetAtStartChunk = 0;
        this.additionalParagraphRunPositions = {};
        this.subDocument = subDocument;
        this.documentModel = subDocument.documentModel;
    }
    CreateRangeCopyOperation.prototype.copyStyles = function (newDocumentModel) {
        newDocumentModel.characterStyles = list_1.ListUtils.deepCopy(this.documentModel.characterStyles);
        newDocumentModel.paragraphStyles = list_1.ListUtils.deepCopy(this.documentModel.paragraphStyles);
        newDocumentModel.numberingListStyles = list_1.ListUtils.deepCopy(this.documentModel.numberingListStyles);
        newDocumentModel.tableStyles = list_1.ListUtils.deepCopy(this.documentModel.tableStyles);
        newDocumentModel.tableCellStyles = list_1.ListUtils.deepCopy(this.documentModel.tableCellStyles);
    };
    CreateRangeCopyOperation.prototype.execute = function (intervals) {
        var newDocumentModel = this.initNewDocumentModel();
        var newSubDocument = newDocumentModel.mainSubDocument;
        this.copyStyles(newDocumentModel);
        if (list_1.ListUtils.allOf(intervals, function (curr) { return curr.length == 0; }))
            throw new Error(errors_1.Errors.InternalException);
        var currIntervalOffset = 0;
        for (var _i = 0, intervals_1 = intervals; _i < intervals_1.length; _i++) {
            var interval = intervals_1[_i];
            this.copyMainContent(interval, newDocumentModel, currIntervalOffset);
            currIntervalOffset += interval.length;
        }
        bookmarks_manipulator_1.BookmarksManipulator.copyBookmarksFromSubDocumentTo(this.subDocument, newSubDocument, intervals);
        newSubDocument.getLastChunk().isLast = true;
        this.copyTables(newSubDocument, intervals);
        var addedUselessParagraphMarkInEnd = this.tryAppendAdditionalParagraphRunInTheEnd(newSubDocument, false);
        return new RangeCopy(newDocumentModel, addedUselessParagraphMarkInEnd);
    };
    CreateRangeCopyOperation.prototype.copyMainContent = function (interval, newDocumentModel, currIntervalOffset) {
        var newSubDocument = newDocumentModel.mainSubDocument;
        var constRunIterator = this.subDocument.getConstRunIterator(interval);
        var numberingListCache = {};
        var abstractNumberingListCache = {};
        this.oldFieldStartIndex = -1;
        while (constRunIterator.moveNext()) {
            var oldCurrentRun = constRunIterator.currentRun;
            if (this.oldCurrentSection != constRunIterator.currentSection) {
                this.oldCurrentSection = constRunIterator.currentSection;
                this.newCurrentSection = this.appendNewSection(newSubDocument);
            }
            if (this.oldCurrentParagraph != oldCurrentRun.paragraph) {
                this.oldCurrentParagraph = oldCurrentRun.paragraph;
                this.newCurrentParagraph = this.appendNewParagraph(newSubDocument, abstractNumberingListCache, numberingListCache);
            }
            if (this.oldCurrentChunk != constRunIterator.currentChunk) {
                this.oldCurrentChunk = constRunIterator.currentChunk;
                this.newCurrentChunk = this.appendNewChunk(newSubDocument);
                this.newOffsetAtStartChunk = 0;
            }
            this.newCurrentParagraph.length += oldCurrentRun.getLength();
            this.newCurrentSection.setLength(newSubDocument, this.newCurrentSection.getLength() + oldCurrentRun.getLength());
            this.newCurrentChunk.textBuffer += this.oldCurrentChunk.getTextInChunk(oldCurrentRun.startOffset, oldCurrentRun.getLength());
            if (oldCurrentRun.getType() == run_type_1.RunType.FieldCodeStartRun)
                this.appendField(newSubDocument, oldCurrentRun, interval.start - currIntervalOffset);
            else if (oldCurrentRun.getType() == run_type_1.RunType.AnchoredTextBoxRun)
                this.documentModel.subDocuments[oldCurrentRun.subDocId].clone(newDocumentModel);
            this.newCurrentChunk.textRuns.push(oldCurrentRun.createSimularity(this.newOffsetAtStartChunk, oldCurrentRun.getLength(), this.newCurrentParagraph, newDocumentModel.stylesManager.addCharacterStyle(oldCurrentRun.characterStyle), newDocumentModel.cache.maskedCharacterPropertiesCache.getItem(oldCurrentRun.maskedCharacterProperties)));
            this.newOffsetAtStartChunk += oldCurrentRun.getLength();
        }
    };
    CreateRangeCopyOperation.prototype.appendField = function (newSubDocument, oldCurrentRun, globalOffset) {
        var oldFieldStartIndex = this.oldFieldStartIndex;
        var oldSubDocument = this.subDocument;
        if (oldFieldStartIndex < 0) {
            var oldFieldStartCodeRunOffset = this.oldCurrentChunk.startLogPosition.value + oldCurrentRun.startOffset;
            oldFieldStartIndex = field_1.Field.normedBinaryIndexOf(oldSubDocument.fields, oldFieldStartCodeRunOffset + 1);
        }
        else
            oldFieldStartIndex++;
        var oldField = oldSubDocument.fields[oldFieldStartIndex];
        var newField = new field_1.Field(newSubDocument.positionManager, newSubDocument.fields.length, oldField.getFieldStartPosition() - globalOffset, oldField.getSeparatorPosition() - globalOffset, oldField.getFieldEndPosition() - globalOffset, oldField.showCode, oldField.getHyperlinkInfo() ? oldField.getHyperlinkInfo().clone() : undefined);
        newSubDocument.fields.push(newField);
        newField.initParent(newSubDocument.fields);
        this.oldFieldStartIndex = oldFieldStartIndex;
    };
    CreateRangeCopyOperation.prototype.appendParagraphMarkInTheEnd = function (newSubDocument, position, sectionEnd) {
        this.newCurrentParagraph.length += 1;
        this.newCurrentSection.setLength(newSubDocument, this.newCurrentSection.getLength() + 1);
        var text = sectionEnd ? rich_utils_1.RichUtils.specialCharacters.SectionMark : rich_utils_1.RichUtils.specialCharacters.ParagraphMark;
        var runType = sectionEnd ? simple_runs_1.SectionRun : simple_runs_1.ParagraphRun;
        this.newCurrentChunk.textBuffer += text;
        this.newCurrentChunk.textRuns.push(new runType(position, this.newCurrentParagraph, new properties_bundle_1.MaskedCharacterPropertiesBundle(newSubDocument.getLastRun().maskedCharacterProperties, newSubDocument.getLastRun().characterStyle)));
        this.newOffsetAtStartChunk++;
    };
    CreateRangeCopyOperation.prototype.appendNewChunk = function (newSubDocument) {
        var newCurrentChunkAbsolutePosition = newSubDocument.chunks.length ? newSubDocument.getLastChunk().getEndPosition() : 0, newCurrentChunkPosition = newSubDocument.positionManager.registerPosition(newCurrentChunkAbsolutePosition), newCurrentChunk = new chunk_1.Chunk(newCurrentChunkPosition, "", false);
        newSubDocument.chunks.push(newCurrentChunk);
        return newCurrentChunk;
    };
    CreateRangeCopyOperation.prototype.appendNewSection = function (newSubDocument) {
        this.tryAppendAdditionalParagraphRunInTheEnd(newSubDocument, true);
        var lastSection = newSubDocument.documentModel.sections[newSubDocument.documentModel.sections.length - 1];
        var newCurrentSectionAbsolutePosition = lastSection ? lastSection.getEndPosition() : 0, newCurrentSectionPosition = newSubDocument.positionManager.registerPosition(newCurrentSectionAbsolutePosition);
        var newCurrentSection = new section_1.Section(newSubDocument.documentModel, newCurrentSectionPosition, 0, this.oldCurrentSection.sectionProperties.clone());
        newSubDocument.documentModel.sections.push(newCurrentSection);
        return newCurrentSection;
    };
    CreateRangeCopyOperation.prototype.appendNewParagraph = function (newSubDocument, abstractNumberingListCache, numberingListCache) {
        this.tryAppendAdditionalParagraphRunInTheEnd(newSubDocument, false);
        var oldCurrentParagraph = this.oldCurrentParagraph;
        var oldDocumentModel = oldCurrentParagraph.subDocument.documentModel;
        var lastParagraph = newSubDocument.paragraphs[newSubDocument.paragraphs.length - 1];
        var newCurrentParagraphAbsolutePosition = lastParagraph ? lastParagraph.getEndPosition() : 0;
        var newCurrentParagraphPosition = newSubDocument.positionManager.registerPosition(newCurrentParagraphAbsolutePosition);
        var newCurrentParagraphStyle = newSubDocument.documentModel.stylesManager.addParagraphStyle(oldCurrentParagraph.paragraphStyle);
        var newCurrentMaskedParagraphProperties = newSubDocument.documentModel.cache.maskedParagraphPropertiesCache.getItem(oldCurrentParagraph.maskedParagraphProperties);
        var newCurrentParagraph = new paragraph_1.Paragraph(newSubDocument, newCurrentParagraphPosition, 0, newCurrentParagraphStyle, newCurrentMaskedParagraphProperties);
        var newCurrentParagraphNumberingListIndex = -1, newAbstractNumberingListIndex = -1;
        if (oldCurrentParagraph.numberingListIndex >= 0) {
            var oldNumberingList = oldDocumentModel.numberingLists[oldCurrentParagraph.numberingListIndex];
            newCurrentParagraphNumberingListIndex = numberingListCache[oldNumberingList.getId()];
            if (newCurrentParagraphNumberingListIndex === undefined) {
                var oldAbstractNumberingList = oldDocumentModel.abstractNumberingLists[oldNumberingList.abstractNumberingListIndex];
                newAbstractNumberingListIndex = abstractNumberingListCache[oldAbstractNumberingList.getId()];
                if (newAbstractNumberingListIndex === undefined) {
                    var newAbstractNumberingList = new numbering_list_1.AbstractNumberingList(newSubDocument.documentModel);
                    newAbstractNumberingList.copyFrom(oldAbstractNumberingList);
                    newAbstractNumberingListIndex = newSubDocument.documentModel.abstractNumberingLists.push(newAbstractNumberingList) - 1;
                    abstractNumberingListCache[oldAbstractNumberingList.getId()] = newAbstractNumberingListIndex;
                }
                var newNumberingList = new numbering_list_1.NumberingList(newSubDocument.documentModel, newAbstractNumberingListIndex);
                newNumberingList.copyFrom(oldNumberingList);
                newCurrentParagraphNumberingListIndex = newSubDocument.documentModel.numberingLists.push(newNumberingList) - 1;
                numberingListCache[oldNumberingList.getId()] = newCurrentParagraphNumberingListIndex;
            }
        }
        newCurrentParagraph.listLevelIndex = oldCurrentParagraph.listLevelIndex;
        newCurrentParagraph.numberingListIndex = newCurrentParagraphNumberingListIndex;
        newSubDocument.paragraphs.push(newCurrentParagraph);
        return newCurrentParagraph;
    };
    CreateRangeCopyOperation.prototype.tryAppendAdditionalParagraphRunInTheEnd = function (newSubDocument, sectionEnd) {
        var lastChunk = newSubDocument.getLastChunk();
        if (!lastChunk)
            return false;
        var lastRun = lastChunk.textRuns[lastChunk.textRuns.length - 1];
        if (!lastRun)
            return false;
        if (!lastRun.isParagraphOrSectionRun()) {
            this.appendParagraphMarkInTheEnd(newSubDocument, lastRun.startOffset + lastRun.getLength(), sectionEnd);
            this.additionalParagraphRunPositions[lastChunk.getEndPosition() - 1] = true;
            return true;
        }
        return false;
    };
    CreateRangeCopyOperation.prototype.initNewDocumentModel = function () {
        var newDocumentModel = new document_model_1.DocumentModel(this.documentModel.modelOptions, 0);
        newDocumentModel.defaultCharacterProperties = newDocumentModel.cache.maskedCharacterPropertiesCache.getItem(this.documentModel.defaultCharacterProperties);
        newDocumentModel.defaultParagraphProperties = newDocumentModel.cache.maskedParagraphPropertiesCache.getItem(this.documentModel.defaultParagraphProperties);
        newDocumentModel.defaultTableProperties = this.documentModel.defaultTableProperties.clone();
        newDocumentModel.defaultTableRowProperties = newDocumentModel.cache.tableRowPropertiesCache.getItem(this.documentModel.defaultTableRowProperties);
        newDocumentModel.defaultTableCellProperties = newDocumentModel.cache.tableCellPropertiesCache.getItem(this.documentModel.defaultTableCellProperties);
        newDocumentModel.colorProvider.officeTheme.copyFrom(this.documentModel.colorProvider.officeTheme);
        return newDocumentModel;
    };
    CreateRangeCopyOperation.prototype.getNestedLevel = function (newSubDocument, sourceTable, nestedLevel) {
        if (sourceTable.nestedLevel > nestedLevel)
            return nestedLevel + 1;
        if (!sourceTable.parentCell)
            return 0;
        var newParentTableIndex = this.mapSourceTableIndexToTarget[sourceTable.getParentTable().index];
        return common_1.isDefined(newParentTableIndex) ? newSubDocument.tables[newParentTableIndex].nestedLevel + 1 : -1;
    };
    CreateRangeCopyOperation.prototype.copyTables = function (newSubDocument, intervals) {
        var tables = this.subDocument.tables;
        this.mapSourceTableIndexToTarget = new map_creator_1.MapCreator().get();
        if (!tables.length)
            return;
        var pos = intervals[0].start;
        var startTableIndex = Math.max(0, search_1.SearchUtils.normedInterpolationIndexOf(tables, function (t) { return t.getStartPosition(); }, pos));
        startTableIndex = table_1.Table.correctBoundTable(tables, startTableIndex, pos, function (index) { return --index; }).index;
        var nestedLevel = -1;
        var endSelectionPosition = intervals[0].end;
        var prevLength = 0;
        for (var i = startTableIndex, table = void 0; table = this.subDocument.tables[i]; i++) {
            if (table.nestedLevel != nestedLevel)
                nestedLevel = this.getNestedLevel(newSubDocument, table, nestedLevel);
            var tableStartPosition = table.getStartPosition();
            var tableInterval = table.interval;
            while (intervals.length > 0 && tableStartPosition >= intervals[0].end) {
                if (this.additionalParagraphRunPositions[intervals[0].end])
                    prevLength++;
                prevLength += intervals[0].length;
                intervals.shift();
            }
            if (!intervals.length)
                break;
            if (algorithms_1.IntervalAlgorithms.getIntersectionNonNullLength(table.interval, intervals[0])) {
                if (intervals[0].containsInterval(tableInterval)) {
                    this.appendWholeTable(newSubDocument, table, intervals[0].start - prevLength, nestedLevel);
                }
                else {
                    var selectedCellInfos = this.getSelectedCells(table, intervals.slice(0), prevLength);
                    if (this.canCopyParticallyTable(selectedCellInfos))
                        this.appendParticallyTable(newSubDocument, selectedCellInfos, nestedLevel);
                    else
                        nestedLevel = -1;
                }
            }
            else if (tableStartPosition >= endSelectionPosition)
                break;
        }
    };
    CreateRangeCopyOperation.prototype.appendWholeTable = function (newSubDocument, table, positionDelta, newNestedLevel) {
        var newTable = this.createTable(newSubDocument, table, newNestedLevel, positionDelta);
        newTable.preferredWidth = table.preferredWidth.clone();
        newTable.lookTypes = table.lookTypes;
        for (var i = 0, row = void 0; row = table.rows[i]; i++) {
            var newRow = new table_row_1.TableRow(newTable, newSubDocument.documentModel.cache.tableRowPropertiesCache.getItem(row.properties.clone()));
            newTable.rows.push(newRow);
            newRow.height = row.height.clone();
            if (row.tablePropertiesException)
                newRow.tablePropertiesException = row.tablePropertiesException.clone();
            newRow.gridBefore = row.gridBefore;
            newRow.gridAfter = row.gridAfter;
            newRow.widthAfter = row.widthAfter.clone();
            newRow.widthBefore = row.widthBefore.clone();
            for (var j = 0, cell = void 0; cell = row.cells[j]; j++) {
                var newCell = this.cloneTableCell(newSubDocument, newRow, cell);
                newCell.verticalMerging = cell.verticalMerging;
                newCell.startParagraphPosition = newSubDocument.positionManager.registerPosition(cell.startParagraphPosition.value - positionDelta);
                newCell.endParagrapPosition = newSubDocument.positionManager.registerPosition(cell.endParagrapPosition.value - positionDelta);
                newRow.cells.push(newCell);
            }
        }
    };
    CreateRangeCopyOperation.prototype.appendParticallyTable = function (newSubDocument, selectedCellInfos, newNestedLevel) {
        var minLeftColumnIndex = Number.MAX_VALUE;
        var maxRightColumnIndex = 0;
        var table = selectedCellInfos[0][0].cell.parentRow.parentTable;
        for (var i = 0, horCells = void 0; horCells = selectedCellInfos[i]; i++) {
            var leftColumnIndex = table_utils_1.TableCellUtils.getStartColumnIndex(horCells[0].cell);
            var rightColumnIndex = table_utils_1.TableCellUtils.getEndColumnIndex(horCells[horCells.length - 1].cell);
            minLeftColumnIndex = Math.min(minLeftColumnIndex, leftColumnIndex);
            maxRightColumnIndex = Math.max(maxRightColumnIndex, rightColumnIndex);
        }
        var newStartPosition = selectedCellInfos[0][0].cell.startParagraphPosition.value - selectedCellInfos[0][0].positionDelta;
        var newTable = this.createTable(newSubDocument, table, newNestedLevel, newStartPosition);
        newTable.preferredWidth = table_units_1.TableWidthUnit.create(0, table_units_1.TableWidthUnitType.Auto);
        for (var i = 0, horCellInfos = void 0; horCellInfos = selectedCellInfos[i]; i++) {
            var leftColumnIndex = table_utils_1.TableCellUtils.getStartColumnIndex(horCellInfos[0].cell);
            var rightColumnIndex = table_utils_1.TableCellUtils.getEndColumnIndex(horCellInfos[horCellInfos.length - 1].cell);
            var row = horCellInfos[0].cell.parentRow;
            var newRow = new table_row_1.TableRow(newTable, newSubDocument.documentModel.cache.tableRowPropertiesCache.getItem(row.properties.clone()));
            newTable.rows.push(newRow);
            newRow.height = row.height.clone();
            newRow.gridBefore = leftColumnIndex - minLeftColumnIndex;
            newRow.gridAfter = maxRightColumnIndex - rightColumnIndex;
            for (var j = 0, cellInfo = void 0; cellInfo = horCellInfos[j]; j++) {
                var newCell = this.cloneTableCell(newSubDocument, newRow, cellInfo.cell);
                newCell.startParagraphPosition = newSubDocument.positionManager.registerPosition(cellInfo.cell.startParagraphPosition.value - cellInfo.positionDelta);
                newCell.endParagrapPosition = newSubDocument.positionManager.registerPosition(cellInfo.cell.endParagrapPosition.value - cellInfo.positionDelta);
                newRow.cells.push(newCell);
            }
        }
        tables_manipulator_1.TablesManipulator.normalizeCellColumnSpansWithoutHistory(newTable, true);
    };
    CreateRangeCopyOperation.prototype.canCopyParticallyTable = function (selectedCellInfos) {
        if (selectedCellInfos.length === 0)
            return false;
        var prevRowEndPosition = selectedCellInfos[0][0].cell.parentRow.getEndPosition();
        var prevLeftColumnIndex = table_utils_1.TableCellUtils.getStartColumnIndex(selectedCellInfos[0][0].cell);
        var prevRightColumnIndex = table_utils_1.TableCellUtils.getEndColumnIndex(selectedCellInfos[0][selectedCellInfos[0].length - 1].cell);
        for (var i = 0, horCells = void 0; horCells = selectedCellInfos[i]; i++) {
            var prevCellEndPosition = horCells[0].cell.endParagrapPosition.value;
            for (var j = 1, cellInfo = void 0; cellInfo = horCells[j]; j++) {
                if (cellInfo.cell.startParagraphPosition.value !== prevCellEndPosition)
                    return false;
                prevCellEndPosition = cellInfo.cell.endParagrapPosition.value;
            }
            if (i > 0) {
                if (horCells[0].cell.parentRow.getStartPosition() !== prevRowEndPosition)
                    return false;
                var leftColumnIndex = table_utils_1.TableCellUtils.getStartColumnIndex(horCells[0].cell);
                var rightColumnIndex = table_utils_1.TableCellUtils.getEndColumnIndex(horCells[horCells.length - 1].cell);
                if (rightColumnIndex < prevLeftColumnIndex || leftColumnIndex > prevRightColumnIndex)
                    return false;
                prevRowEndPosition = horCells[0].cell.parentRow.getEndPosition();
            }
        }
        return true;
    };
    CreateRangeCopyOperation.prototype.cloneTableCell = function (newSubDocument, newRow, sourceCell) {
        var newCell = new table_cell_1.TableCell(newRow, newSubDocument.documentModel.cache.tableCellPropertiesCache.getItem(sourceCell.properties.clone()));
        newCell.columnSpan = sourceCell.columnSpan;
        newCell.conditionalFormatting = sourceCell.conditionalFormatting;
        newCell.preferredWidth = sourceCell.preferredWidth.clone();
        newCell.style = sourceCell.style;
        return newCell;
    };
    CreateRangeCopyOperation.prototype.createTable = function (newSubDocument, oldTable, newNestedLevel, newDocumentStartPosition) {
        var newTableStyle = newSubDocument.documentModel.stylesManager.addTableStyle(oldTable.style);
        var newTable = new table_1.Table(oldTable.properties.clone(), newTableStyle);
        newTable.nestedLevel = newNestedLevel;
        if (newNestedLevel > 0) {
            var newStartPosition = oldTable.getStartPosition() - newDocumentStartPosition;
            newTable.parentCell = table_1.Table.getTableCellByPosition(newSubDocument.tables, newStartPosition);
        }
        newTable.index = newSubDocument.tables.push(newTable) - 1;
        this.mapSourceTableIndexToTarget[oldTable.index] = newTable.index;
        (newSubDocument.tablesByLevels[newNestedLevel] || (newSubDocument.tablesByLevels[newNestedLevel] = [])).push(newTable);
        return newTable;
    };
    CreateRangeCopyOperation.prototype.getSelectedCells = function (table, intervals, prevLength) {
        var currentIntervalIndex = 0;
        var maxIntervalIndex = intervals.length - 1;
        var selectedCellInfos = [];
        for (var rowIndex = 0, row = void 0; row = table.rows[rowIndex]; rowIndex++) {
            var horCells = [];
            for (var cellIndex = 0, cell = void 0; cell = row.cells[cellIndex]; cellIndex++) {
                while (currentIntervalIndex <= maxIntervalIndex && intervals[currentIntervalIndex].end < cell.endParagrapPosition.value) {
                    if (this.additionalParagraphRunPositions[intervals[currentIntervalIndex].end])
                        prevLength++;
                    prevLength += intervals[currentIntervalIndex].length;
                    currentIntervalIndex++;
                }
                if (currentIntervalIndex > maxIntervalIndex)
                    break;
                if (intervals[currentIntervalIndex].containsInterval(cell.interval)) {
                    horCells.push(new TableCellInfo(cell, intervals[currentIntervalIndex].start - prevLength));
                }
            }
            if (horCells.length)
                selectedCellInfos.push(horCells);
            if (currentIntervalIndex > maxIntervalIndex)
                break;
        }
        return selectedCellInfos;
    };
    return CreateRangeCopyOperation;
}());
exports.CreateRangeCopyOperation = CreateRangeCopyOperation;
var RangeCopy = (function () {
    function RangeCopy(model, addedUselessParagraphMarkInEnd) {
        this.model = model;
        this.addedUselessParagraphMarkInEnd = addedUselessParagraphMarkInEnd;
    }
    RangeCopy.prototype.insertTo = function (modelManipulator, subDocPosition) {
        var sourceInterval = new fixed_1.FixedInterval(0, this.model.mainSubDocument.getDocumentEndPosition()
            - (this.addedUselessParagraphMarkInEnd ? 1 : 0));
        return modelManipulator.subDocument.insertSubDocument(subDocPosition, new sub_document_1.SubDocumentInterval(this.model.mainSubDocument, sourceInterval));
    };
    RangeCopy.prototype.insertToTable = function (modelManipulator, insertPosition, targetTableInfo) {
        var sourceTable = this.model.mainSubDocument.tables[0];
        if (!sourceTable)
            return this.insertTo(modelManipulator, insertPosition);
        return this.overlapTableContent(modelManipulator, sourceTable, targetTableInfo);
    };
    RangeCopy.prototype.overlapTableContent = function (modelManipulator, sourceTable, targetTableInfo) {
        var firstCellIndex = targetTableInfo.rawData.firstCellInfo.cellIndex;
        var lastCellIndex = targetTableInfo.rawData.lastCellInfo.cellIndex;
        var firstRowIndex = targetTableInfo.rawData.firstRowInfo.rowIndex;
        var lastRowIndex = targetTableInfo.rawData.lastRowInfo.rowIndex;
        if (firstCellIndex == lastCellIndex) {
            lastCellIndex = firstCellIndex + sourceTable.rows[0].cells.length - 1;
            if (firstRowIndex == lastRowIndex)
                lastRowIndex = firstRowIndex + sourceTable.rows.length - 1;
        }
        for (var i = firstRowIndex; i <= lastRowIndex; i++) {
            for (var j = firstCellIndex; j <= lastCellIndex; j++) {
                if (i >= targetTableInfo.table.rows.length)
                    return targetTableInfo.table.interval;
                this.overlapTableCellContent(modelManipulator, sourceTable, targetTableInfo, i, j);
            }
        }
        return targetTableInfo.table.interval;
    };
    RangeCopy.prototype.overlapTableCellContent = function (modelManipulator, sourceTable, targetTableInfo, rowIndex, columnIndex) {
        var targetCell = targetTableInfo.table.rows[rowIndex].cells[columnIndex];
        if (!targetCell)
            return;
        var i = (rowIndex - targetTableInfo.rawData.firstRowInfo.rowIndex) % sourceTable.rows.length;
        var j = (columnIndex - targetTableInfo.rawData.firstCellInfo.cellIndex) % sourceTable.rows[i].cells.length;
        var sourceCell = sourceTable.rows[i].cells[j];
        var copyOperation = new CreateRangeCopyOperation(this.model.mainSubDocument);
        var rangeCopy = copyOperation.execute([sourceCell.interval]);
        modelManipulator.range.removeInterval(new sub_document_1.SubDocumentInterval(modelManipulator.model.mainSubDocument, targetCell.interval), false, true);
        rangeCopy.addedUselessParagraphMarkInEnd = true;
        rangeCopy.insertTo(modelManipulator, new sub_document_1.SubDocumentPosition(modelManipulator.model.mainSubDocument, targetCell.interval.start));
    };
    RangeCopy.create = function (subDocIntervals) {
        return new CreateRangeCopyOperation(subDocIntervals.subDocument).execute(subDocIntervals.intervals);
    };
    return RangeCopy;
}());
exports.RangeCopy = RangeCopy;
var TableCellInfo = (function () {
    function TableCellInfo(cell, positionDelta) {
        this.cell = cell;
        this.positionDelta = positionDelta;
    }
    return TableCellInfo;
}());
