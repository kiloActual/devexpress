"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var list_1 = require("@devexpress/utils/lib/utils/list");
var chunk_1 = require("../../chunk");
var runs_base_manipulator_1 = require("../runs-base-manipulator");
var ChunkSizeCorrector = (function () {
    function ChunkSizeCorrector() {
        this.maxChunkSize = 4096;
        this.maxRunSizeCoeff = 0.25;
        this.maxRunSize = Math.floor(this.maxRunSizeCoeff * this.maxChunkSize);
    }
    ChunkSizeCorrector.prototype.correctChunkSizeAtChunkIndex = function (subDocument, chunkIndex) {
        this.subDocument = subDocument;
        this.chunks = subDocument.chunks;
        this.originChunk = this.chunks[chunkIndex];
        this.originChunkIndex = chunkIndex;
        this.originChunkRuns = this.originChunk.textRuns;
        this.startCorrect();
    };
    ChunkSizeCorrector.prototype.correctChunkSizeAtInsertPosition = function (subDocument, insertPosition) {
        this.subDocument = subDocument;
        this.chunks = subDocument.chunks;
        var originRunInfo = this.subDocument.getRunAndIndexesByPosition(insertPosition);
        this.originChunk = originRunInfo.chunk;
        this.originChunkRuns = originRunInfo.chunk.textRuns;
        this.originChunkIndex = originRunInfo.chunkIndex;
        this.startCorrect();
    };
    ChunkSizeCorrector.prototype.startCorrect = function () {
        if (this.originChunk.textBuffer.length <= this.maxChunkSize)
            return;
        this.needMoveLength = this.originChunk.textBuffer.length - this.maxChunkSize;
        if (this.needMoveLength < this.maxChunkSize) {
            if (this.isMoveToPrevChunk())
                return;
            if (this.isMoveToNextChunk())
                return;
        }
        this.moveToNewNextChunks();
    };
    ChunkSizeCorrector.prototype.isMoveToPrevChunk = function () {
        var prevChunk = this.chunks[this.originChunkIndex - 1];
        if (!prevChunk)
            return false;
        var runIndexFrom = 0;
        var run;
        var totallyMoveLength = 0;
        for (; run = this.originChunkRuns[runIndexFrom]; runIndexFrom++) {
            if (run.getLength() > this.maxRunSize) {
                this.originChunk.splitRun(runIndexFrom, this.maxRunSize);
            }
            totallyMoveLength += run.getLength();
            if (totallyMoveLength >= this.needMoveLength)
                break;
        }
        if (totallyMoveLength + prevChunk.textBuffer.length > this.maxChunkSize)
            return false;
        var prevChunkOffset = prevChunk.textBuffer.length;
        for (; runIndexFrom >= 0; runIndexFrom--) {
            run = this.originChunkRuns.shift();
            prevChunk.textRuns.push(run);
            run.startOffset = prevChunkOffset;
            prevChunkOffset += run.getLength();
        }
        prevChunk.textBuffer += this.originChunk.textBuffer.substr(0, totallyMoveLength);
        this.originChunk.textBuffer = this.originChunk.textBuffer.substr(totallyMoveLength);
        this.subDocument.positionManager.unregisterPosition(this.originChunk.startLogPosition);
        this.originChunk.startLogPosition = this.subDocument.positionManager.registerPosition(this.originChunk.startLogPosition.value + totallyMoveLength);
        runs_base_manipulator_1.RunsBaseManipulator.moveRunsInChunk(this.originChunk, 0, -totallyMoveLength);
        return true;
    };
    ChunkSizeCorrector.prototype.isMoveToNextChunk = function () {
        var nextChunk = this.chunks[this.originChunkIndex + 1];
        if (!nextChunk)
            return false;
        var runIndexFrom = this.originChunkRuns.length - 1;
        var run;
        var totallyMoveLength = 0;
        for (; run = this.originChunkRuns[runIndexFrom]; runIndexFrom--) {
            while (run.getLength() > this.maxRunSize) {
                this.originChunk.splitRun(runIndexFrom, this.maxRunSize);
                run = this.originChunkRuns[++runIndexFrom];
            }
            totallyMoveLength += run.getLength();
            if (totallyMoveLength >= this.needMoveLength)
                break;
        }
        if (totallyMoveLength + nextChunk.textBuffer.length > this.maxChunkSize)
            return false;
        runs_base_manipulator_1.RunsBaseManipulator.moveRunsInChunk(nextChunk, 0, totallyMoveLength);
        var offsetFirstRun = totallyMoveLength;
        for (runIndexFrom = this.originChunkRuns.length - runIndexFrom; runIndexFrom > 0; runIndexFrom--) {
            run = this.originChunkRuns.pop();
            nextChunk.textRuns.unshift(run);
            offsetFirstRun -= run.getLength();
            run.startOffset = offsetFirstRun;
        }
        var startMovedPosition = this.originChunk.textBuffer.length - totallyMoveLength;
        nextChunk.textBuffer = this.originChunk.textBuffer.substring(startMovedPosition) + nextChunk.textBuffer;
        this.originChunk.textBuffer = this.originChunk.textBuffer.substring(0, startMovedPosition);
        this.subDocument.positionManager.unregisterPosition(nextChunk.startLogPosition);
        nextChunk.startLogPosition = this.subDocument.positionManager.registerPosition(nextChunk.startLogPosition.value - totallyMoveLength);
        return true;
    };
    ChunkSizeCorrector.prototype.moveToNewNextChunks = function () {
        var isLast = list_1.ListUtils.last(this.chunks).isLast;
        var runIndexFrom = this.originChunkRuns.length - 1;
        var run;
        var totallyMoveLength = 0;
        for (; run = this.originChunkRuns[runIndexFrom]; runIndexFrom--) {
            while (run.getLength() > this.maxRunSize) {
                this.originChunk.splitRun(runIndexFrom, this.maxRunSize);
                run = this.originChunkRuns[++runIndexFrom];
            }
            totallyMoveLength += run.getLength();
            if (totallyMoveLength >= this.needMoveLength)
                break;
        }
        var newChunk = undefined;
        var runOffset = 0;
        var indexInsertNewChunk = this.originChunkIndex + 1;
        var chunkStartPosition = this.originChunk.startLogPosition.value + this.originChunkRuns[runIndexFrom].startOffset;
        for (var currRunIndex = runIndexFrom; run = this.originChunkRuns[currRunIndex]; currRunIndex++) {
            if (newChunk == undefined || runOffset + run.getLength() > this.maxChunkSize) {
                if (newChunk)
                    newChunk.textBuffer = this.originChunk.textBuffer.substr(newChunk.startLogPosition.value - this.originChunk.startLogPosition.value, runOffset);
                newChunk = new chunk_1.Chunk(this.subDocument.positionManager.registerPosition(chunkStartPosition), "", false);
                this.chunks.splice(indexInsertNewChunk, 0, newChunk);
                indexInsertNewChunk++;
                runOffset = 0;
            }
            newChunk.textRuns.push(run);
            run.startOffset = runOffset;
            chunkStartPosition += run.getLength();
            runOffset += run.getLength();
        }
        newChunk.textBuffer = this.originChunk.textBuffer.substr(newChunk.startLogPosition.value - this.originChunk.startLogPosition.value, runOffset);
        var originPrevRun = this.originChunkRuns[runIndexFrom - 1];
        this.originChunk.textBuffer = this.originChunk.textBuffer.substring(0, originPrevRun.startOffset + originPrevRun.getLength());
        this.originChunkRuns.splice(runIndexFrom);
        this.originChunk.isLast = false;
        this.chunks[this.chunks.length - 1].isLast = isLast;
    };
    return ChunkSizeCorrector;
}());
exports.ChunkSizeCorrector = ChunkSizeCorrector;
