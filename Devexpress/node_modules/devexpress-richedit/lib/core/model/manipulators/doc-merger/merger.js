"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var list_1 = require("@devexpress/utils/lib/utils/list");
var properties_bundle_1 = require("../../../rich-utils/properties-bundle");
var hyperlink_info_changed_1 = require("../../changes/sub-document/field/hyperlink-info-changed");
var inserted_1 = require("../../changes/sub-document/field/inserted");
var field_1 = require("../../fields/field");
var numbering_list_1 = require("../../numbering-lists/numbering-list");
var anchored_picture_run_1 = require("../../runs/anchored-picture-run");
var inline_picture_run_1 = require("../../runs/inline-picture-run");
var run_type_1 = require("../../runs/run-type");
var sub_document_1 = require("../../sub-document");
var base_manipulator_1 = require("../base-manipulator");
var insert_paragraph_manipulator_params_1 = require("../paragraph-manipulator/insert-paragraph-manipulator-params");
var text_box_manipulator_1 = require("../text-box-manipulator");
var insert_text_manipulator_params_1 = require("../text-manipulator/insert-text-manipulator-params");
var DocumentMerger = (function (_super) {
    tslib_1.__extends(DocumentMerger, _super);
    function DocumentMerger(manipulator) {
        return _super.call(this, manipulator) || this;
    }
    DocumentMerger.prototype.mergeDocumentModel = function (sourceInfo, targetSubDocPos) {
        var _this = this;
        this.history.beginTransaction();
        var targetSubDocument = targetSubDocPos.subDocument;
        var targetPosition = targetSubDocPos.position;
        var sourceSubDocument = sourceInfo.subDocument;
        var sourceInterval = sourceInfo.interval;
        var fromDocumentModel = sourceSubDocument.documentModel;
        var toDocumentModel = targetSubDocument.documentModel;
        var constRunIterator = sourceSubDocument.getConstRunIterator(sourceInterval);
        var fromFieldIndexesWhatNeedCopyInfo = [];
        var fromFields = sourceSubDocument.fields;
        var toFields = targetSubDocument.fields;
        var modelsOffset = targetPosition - sourceInterval.start;
        var insertImgCacheInfo = function (cacheInfo) {
            cacheInfo = cacheInfo.clone();
            toDocumentModel.cache.imageCache.registerFromAnotherModel(cacheInfo);
            _this.modelManipulator.picture.loader.load(cacheInfo);
            return cacheInfo;
        };
        var isMoved = constRunIterator.moveNext();
        if (isMoved && this.needInsertParagraphBeforeTable(sourceSubDocument, sourceInterval)) {
            this.insertParagraph(toDocumentModel, targetSubDocument, constRunIterator.currentRun, targetPosition, -1, constRunIterator.currentRun.paragraph.listLevelIndex);
            targetPosition++;
        }
        var toCurrentPosition = targetPosition;
        while (isMoved) {
            var currentRun = constRunIterator.currentRun;
            switch (currentRun.getType()) {
                case run_type_1.RunType.FieldCodeStartRun:
                    var fromGlobPos = constRunIterator.currentChunk.startLogPosition.value + currentRun.startOffset;
                    fromFieldIndexesWhatNeedCopyInfo.push(field_1.Field.normedBinaryIndexOf(sourceSubDocument.fields, fromGlobPos + 1));
                case run_type_1.RunType.FieldCodeEndRun:
                case run_type_1.RunType.FieldResultEndRun:
                case run_type_1.RunType.TextRun:
                case run_type_1.RunType.LayoutDependentRun:
                    var insertedText = constRunIterator.currentChunk.getRunText(currentRun);
                    var insertedMaskedCharacterProperties = toDocumentModel.cache.maskedCharacterPropertiesCache.getItem(currentRun.maskedCharacterProperties);
                    var insertedCharacterStyle = toDocumentModel.stylesManager.addCharacterStyle(currentRun.characterStyle);
                    this.modelManipulator.text.insertTextInner(new insert_text_manipulator_params_1.InsertTextManipulatorParams(new sub_document_1.SubDocumentPosition(targetSubDocument, toCurrentPosition), new properties_bundle_1.MaskedCharacterPropertiesBundle(insertedMaskedCharacterProperties, insertedCharacterStyle), currentRun.getType() == run_type_1.RunType.LayoutDependentRun && targetSubDocument.isMain() ? run_type_1.RunType.TextRun : currentRun.getType(), insertedText));
                    break;
                case run_type_1.RunType.InlinePictureRun: {
                    var currentPictureRun = currentRun;
                    if (!(currentPictureRun instanceof inline_picture_run_1.InlinePictureRun))
                        throw new Error("In TexManipulator.insertPartSubDocumentInOtherSubDocument currentPictureRun not have type InlinePictureRun");
                    var info = currentPictureRun.info.clone();
                    info.size.cacheInfo = insertImgCacheInfo(info.size.cacheInfo);
                    this.modelManipulator.picture.insertInlinePictureInner(new sub_document_1.SubDocumentPosition(targetSubDocument, toCurrentPosition), currentPictureRun.getCharPropsBundle(toDocumentModel), info);
                    break;
                }
                case run_type_1.RunType.AnchoredPictureRun: {
                    var currentAnchoredPictureRun = currentRun;
                    if (!(currentAnchoredPictureRun instanceof anchored_picture_run_1.AnchoredPictureRun))
                        throw new Error("In TexManipulator.insertPartSubDocumentInOtherSubDocument currentAnchoredPictureRun not have type AnchoredPictureRun");
                    this.modelManipulator.picture.insertAnchoredPictureInner(new sub_document_1.SubDocumentPosition(targetSubDocument, toCurrentPosition), currentAnchoredPictureRun.getCharPropsBundle(toDocumentModel), currentAnchoredPictureRun.info.clone());
                    break;
                }
                case run_type_1.RunType.InlineTextBoxRun:
                    break;
                case run_type_1.RunType.AnchoredTextBoxRun: {
                    var currentAnchoredTextBoxRun = currentRun;
                    if (targetSubDocument.isTextBox()) {
                        this.modelManipulator.text.insertTextInner(new insert_text_manipulator_params_1.InsertTextManipulatorParams(new sub_document_1.SubDocumentPosition(targetSubDocument, toCurrentPosition), currentAnchoredTextBoxRun.getCharPropsBundle(toDocumentModel), run_type_1.RunType.TextRun, " "));
                        break;
                    }
                    var newAnchoredTextBox = this.modelManipulator.textBox.insertAnchoredTextBox(new sub_document_1.SubDocumentPosition(targetSubDocument, toCurrentPosition), currentRun.getCharPropsBundle(toDocumentModel), new text_box_manipulator_1.BaseTextBoxInfo(null, currentAnchoredTextBoxRun.size.clone(), currentAnchoredTextBoxRun.shape.clone(), currentAnchoredTextBoxRun.anchorInfo.clone(), currentAnchoredTextBoxRun.textBoxProperties.clone(), currentAnchoredTextBoxRun.containerProperties.clone()));
                    var sourceSubDoc = this.modelManipulator.model.subDocuments[currentAnchoredTextBoxRun.subDocId];
                    var targetSubDoc = this.modelManipulator.model.subDocuments[newAnchoredTextBox.subDocId];
                    this.mergeDocumentModel(new sub_document_1.SubDocumentInterval(sourceSubDoc, new fixed_1.FixedInterval(0, sourceSubDoc.getDocumentEndPosition())), new sub_document_1.SubDocumentPosition(targetSubDoc, 0));
                    this.modelManipulator.range.removeIntervalInner(targetSubDoc, new fixed_1.FixedInterval(targetSubDoc.getDocumentEndPosition() - 2, 1), false);
                    break;
                }
                case run_type_1.RunType.ParagraphRun:
                    var toNumberingListIndex = -1;
                    var toListLevelIndex = currentRun.paragraph.listLevelIndex;
                    if (currentRun.paragraph.numberingListIndex >= 0) {
                        var fromNumberingList = fromDocumentModel.numberingLists[currentRun.paragraph.numberingListIndex];
                        toNumberingListIndex = toDocumentModel.getNumberingListIndexById(fromNumberingList.getId());
                        if (toNumberingListIndex < 0) {
                            var toAbstractNumberingListIndex = toDocumentModel.getAbstractNumberingListIndexById(fromDocumentModel.abstractNumberingLists[fromNumberingList.abstractNumberingListIndex].getId());
                            if (toAbstractNumberingListIndex < 0) {
                                var toAbstractNumberingList = new numbering_list_1.AbstractNumberingList(toDocumentModel);
                                toAbstractNumberingList.copyFrom(fromDocumentModel.abstractNumberingLists[fromNumberingList.abstractNumberingListIndex]);
                                toAbstractNumberingListIndex = this.modelManipulator.numberingList.addAbstractNumberingList(toAbstractNumberingList);
                            }
                            var toNumberingList = new numbering_list_1.NumberingList(toDocumentModel, toAbstractNumberingListIndex);
                            toNumberingList.copyFrom(fromNumberingList);
                            toNumberingListIndex = this.modelManipulator.numberingList.addNumberingList(toNumberingList);
                        }
                    }
                    if (toNumberingListIndex < 0) {
                        var toParagraph = targetSubDocument.getParagraphByPosition(toCurrentPosition);
                        var toParagraphNumberingListIndex = toParagraph.getNumberingListIndex();
                        if (toParagraphNumberingListIndex >= 0) {
                            if (targetPosition === toParagraph.startLogPosition.value) {
                                toNumberingListIndex = toParagraphNumberingListIndex;
                                toListLevelIndex = toParagraph.getListLevelIndex();
                            }
                        }
                    }
                    this.insertParagraph(toDocumentModel, targetSubDocument, currentRun, toCurrentPosition, toNumberingListIndex, toListLevelIndex);
                    break;
                case run_type_1.RunType.SectionRun:
                    this.modelManipulator.section.insertSection(new sub_document_1.SubDocumentPosition(targetSubDocument, toCurrentPosition), currentRun.getCharPropsBundle(toDocumentModel), constRunIterator.currentSection.sectionProperties.clone(), true, currentRun.paragraph.getParagraphBundleFull(toDocumentModel), true);
                    break;
                default: throw new Error("In TextManipulator.insertPartSubDocumentInOtherSubDocument need insert some inknown run type = " + currentRun.getType());
            }
            toCurrentPosition += currentRun.getLength();
            isMoved = constRunIterator.moveNext();
        }
        var newTables = [];
        for (var i = 0, table = void 0; table = sourceSubDocument.tables[i]; i++)
            newTables.push(this.modelManipulator.table.pasteTable(targetSubDocument, table, targetPosition + table.getStartPosition()));
        if (fromFieldIndexesWhatNeedCopyInfo.length > 0) {
            var toStartCodePosFirstField = modelsOffset + fromFields[fromFieldIndexesWhatNeedCopyInfo[0]].getCodeStartPosition();
            var toFieldIndex = field_1.Field.normedBinaryIndexOf(toFields, toStartCodePosFirstField);
            if (toFieldIndex < 0 || toFields[toFieldIndex].getCodeStartPosition() < toStartCodePosFirstField)
                toFieldIndex++;
            while (fromFieldIndexesWhatNeedCopyInfo.length > 0) {
                var fromField = sourceSubDocument.fields[fromFieldIndexesWhatNeedCopyInfo.shift()];
                var newField = new field_1.Field(targetSubDocument.positionManager, toFieldIndex, fromField.getFieldStartPosition() + modelsOffset, fromField.getSeparatorPosition() + modelsOffset, fromField.getFieldEndPosition() + modelsOffset, fromField.showCode, fromField.isHyperlinkField() ? fromField.getHyperlinkInfo().clone() : undefined);
                field_1.Field.addField(toFields, newField);
                toFieldIndex++;
                this.modelManipulator.notifyModelChanged(new inserted_1.FieldInsertedSubDocumentChange(targetSubDocument.id, newField.getFieldStartPosition(), newField.getSeparatorPosition(), newField.getFieldEndPosition()));
                if (newField.isHyperlinkField())
                    this.modelManipulator.notifyModelChanged(new hyperlink_info_changed_1.HyperlinkInfoChangedSubDocumentChange(targetSubDocument.id, newField.getResultInterval(), newField.getCodeInterval(), newField.getHyperlinkInfo()));
            }
        }
        this.modelManipulator.bookmark.insertBookmarksFromSubDocument(sourceSubDocument, targetSubDocument, sourceInterval, modelsOffset);
        this.history.endTransaction();
        return newTables;
    };
    DocumentMerger.prototype.needInsertParagraphBeforeTable = function (sourceSubDocument, sourceInterval) {
        var paragraph = sourceSubDocument.getParagraphByPosition(sourceInterval.start);
        if (paragraph.interval.start != sourceInterval.start)
            return false;
        return list_1.ListUtils.anyOf(sourceSubDocument.tables, function (table) { return table.interval.start <= sourceInterval.start && table.interval.end >= sourceInterval.start; });
    };
    DocumentMerger.prototype.insertParagraph = function (toDocumentModel, targetSubDocument, currentRun, toCurrentPosition, toNumberingListIndex, toListLevelIndex) {
        this.modelManipulator.paragraph.insertParagraphInner(new insert_paragraph_manipulator_params_1.InsertParagraphManipulatorParams(new sub_document_1.SubDocumentPosition(targetSubDocument, toCurrentPosition), currentRun.getCharPropsBundle(toDocumentModel), new properties_bundle_1.MaskedParagraphPropertiesBundleFull(toDocumentModel.cache.maskedParagraphPropertiesCache.getItem(currentRun.paragraph.maskedParagraphProperties), currentRun.paragraph.paragraphStyle, new properties_bundle_1.ParagraphListInfo(toNumberingListIndex, toListLevelIndex), currentRun.paragraph.tabs.clone()), true, function () { }));
    };
    return DocumentMerger;
}(base_manipulator_1.BaseManipulator));
exports.DocumentMerger = DocumentMerger;
