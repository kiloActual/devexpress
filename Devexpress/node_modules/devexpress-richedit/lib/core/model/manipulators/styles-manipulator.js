"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var search_1 = require("@devexpress/utils/lib/utils/search");
var create_style_link_1 = require("../changes/model/create-style-link");
var delete_style_link_1 = require("../changes/model/delete-style-link");
var character_style_applied_1 = require("../changes/sub-document/style/character-style-applied");
var paragraph_style_applied_1 = require("../changes/sub-document/style/paragraph-style-applied");
var character_style_1 = require("../character/character-style");
var field_context_menu_helper_1 = require("../fields/field-context-menu-helper");
var apply_style_history_items_1 = require("../history/items/apply-style-history-items");
var character_properties_history_items_1 = require("../history/items/character-properties-history-items");
var create_style_link_history_item_1 = require("../history/items/create-style-link-history-item");
var paragraph_properties_history_items_1 = require("../history/items/paragraph-properties-history-items");
var history_item_state_1 = require("../history/states/history-item-state");
var history_item_state_object_1 = require("../history/states/history-item-state-object");
var control_1 = require("../options/control");
var styles_manager_1 = require("../styles-manager");
var sub_document_1 = require("../sub-document");
var base_manipulator_1 = require("./base-manipulator");
var StylesManipulator = (function (_super) {
    tslib_1.__extends(StylesManipulator, _super);
    function StylesManipulator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StylesManipulator.prototype.setLinkStyle = function (characterStyle, paragraphStyle) {
        this.modelManipulator.model.stylesManager.addCharacterStyle(characterStyle);
        this.modelManipulator.model.stylesManager.registerLink(characterStyle, paragraphStyle);
        this.modelManipulator.notifyModelChanged(new create_style_link_1.CreateStyleLinkModelChange(paragraphStyle.styleName));
    };
    StylesManipulator.prototype.restoreLinkStyle = function (characterStyle, paragraphStyle) {
        this.modelManipulator.model.stylesManager.removeLastStyle();
        this.modelManipulator.model.stylesManager.unregisterLink(characterStyle, paragraphStyle);
        this.modelManipulator.notifyModelChanged(new delete_style_link_1.DeleteStyleLinkModelChange(paragraphStyle.styleName));
    };
    StylesManipulator.prototype.setCharacterStyle = function (subDocument, interval, style, restoreHyperlinks) {
        var oldState = new history_item_state_1.HistoryItemIntervalState();
        if (!control_1.ControlOptions.isEnabled(subDocument.documentModel.options.characterStyle))
            return oldState;
        var newState = new history_item_state_1.HistoryItemIntervalState();
        var iterator = subDocument.getRunIterator(interval);
        while (iterator.moveNext()) {
            var applyingStyle = style;
            var currentInterval = iterator.currentInterval();
            if (restoreHyperlinks) {
                var field = field_context_menu_helper_1.FieldContextMenuHelper.showHyperlinkItems(subDocument.fields, currentInterval);
                if (field && field.isHyperlinkField()) {
                    if (iterator.currentRun.characterStyle.styleName === character_style_1.CharacterStyle.hyperlinkStyleName)
                        continue;
                    else
                        applyingStyle = subDocument.documentModel.getCharacterStyleByName(character_style_1.CharacterStyle.hyperlinkStyleName);
                }
            }
            oldState.register(new history_item_state_object_1.HistoryItemIntervalStyleStateObject(currentInterval, iterator.currentRun.characterStyle));
            newState.register(new history_item_state_object_1.HistoryItemIntervalStyleStateObject(currentInterval, applyingStyle));
            iterator.currentRun.characterStyle = applyingStyle;
            iterator.currentRun.onCharacterPropertiesChanged();
        }
        if (!newState.isEmpty())
            this.modelManipulator.notifyModelChanged(new character_style_applied_1.CharacterStyleAppliedSubDocumentChange(subDocument.id, newState));
        return oldState;
    };
    StylesManipulator.prototype.restoreCharacterStyle = function (subDocument, state) {
        if (!control_1.ControlOptions.isEnabled(subDocument.documentModel.options.characterStyle))
            return;
        if (state.isEmpty())
            return;
        for (var stateValue, i = 0; stateValue = state.objects[i]; i++) {
            var iterator = subDocument.getRunIterator(stateValue.interval);
            while (iterator.moveNext()) {
                iterator.currentRun.characterStyle = stateValue.value;
                iterator.currentRun.onCharacterPropertiesChanged();
            }
        }
        this.modelManipulator.notifyModelChanged(new character_style_applied_1.CharacterStyleAppliedSubDocumentChange(subDocument.id, state));
    };
    StylesManipulator.prototype.setParagraphStyle = function (subDocument, interval, style) {
        var oldState = new history_item_state_1.HistoryItemIntervalState();
        if (!control_1.ControlOptions.isEnabled(subDocument.documentModel.options.paragraphStyle))
            return oldState;
        var newState = new history_item_state_1.HistoryItemIntervalState();
        var paragraphs = subDocument.getParagraphsByInterval(interval);
        for (var paragraph, i = 0; paragraph = paragraphs[i]; i++) {
            var paragraphInterval = new fixed_1.FixedInterval(paragraph.startLogPosition.value, paragraph.length);
            oldState.register(new history_item_state_object_1.HistoryItemIntervalStyleStateObject(paragraphInterval, paragraph.paragraphStyle));
            newState.register(new history_item_state_object_1.HistoryItemIntervalStyleStateObject(paragraphInterval, style));
            paragraph.paragraphStyle = style;
            paragraph.onParagraphPropertiesChanged();
            this.resetMergedCharacterProperties(subDocument, paragraphInterval);
        }
        this.modelManipulator.notifyModelChanged(new paragraph_style_applied_1.ParagraphStyleAppliedSubDocumentChange(subDocument.id, newState));
        return oldState;
    };
    StylesManipulator.prototype.restoreParagraphStyle = function (subDocument, state) {
        if (!control_1.ControlOptions.isEnabled(subDocument.documentModel.options.paragraphStyle))
            return;
        for (var stateValue, i = 0; stateValue = state.objects[i]; i++) {
            var paragraphs = subDocument.getParagraphsByInterval(stateValue.interval);
            for (var j = 0, paragraph; paragraph = paragraphs[j]; j++) {
                paragraph.paragraphStyle = stateValue.value;
                paragraph.onParagraphPropertiesChanged();
                this.resetMergedCharacterProperties(subDocument, new fixed_1.FixedInterval(paragraph.startLogPosition.value, paragraph.length));
            }
        }
        this.modelManipulator.notifyModelChanged(new paragraph_style_applied_1.ParagraphStyleAppliedSubDocumentChange(subDocument.id, state));
    };
    StylesManipulator.prototype.resetMergedCharacterProperties = function (subDocument, interval) {
        var runs = subDocument.getRunsByInterval(interval);
        for (var i = 0, run; run = runs[i]; i++)
            run.onCharacterPropertiesChanged();
    };
    StylesManipulator.prototype.applyCharacterStyle = function (subDocInterval, style, restoreHyperlinks) {
        if (!control_1.ControlOptions.isEnabled(this.modelManipulator.modelManager.richOptions.control.characterStyle) || !style)
            return false;
        this.history.beginTransaction();
        this.history.addAndRedo(new character_properties_history_items_1.FontUseValueHistoryItem(this.modelManipulator, subDocInterval, 0));
        this.history.addAndRedo(new apply_style_history_items_1.ApplyCharacterStyleHistoryItem(this.modelManipulator, subDocInterval, style, restoreHyperlinks));
        this.history.endTransaction();
        return true;
    };
    StylesManipulator.prototype.applyCharacterStyleByName = function (subDocInterval, styleName) {
        var characterStyle = this.model.getCharacterStyleByName(styleName);
        if (!characterStyle)
            characterStyle = this.model.stylesManager.addCharacterStyle(styles_manager_1.StylesManager.getPresetCharacterStyleByName(styleName).clone());
        return this.applyCharacterStyle(subDocInterval, characterStyle, false);
    };
    StylesManipulator.prototype.applyParagraphStyleByName = function (subDocInterval, styleName) {
        var paragraphStyle = this.model.getParagraphStyleByName(styleName);
        if (!paragraphStyle)
            paragraphStyle = this.model.stylesManager.addParagraphStyle(styles_manager_1.StylesManager.getPresetParagraphStyleByName(styleName).clone());
        return this.applyParagraphStyle(subDocInterval, paragraphStyle);
    };
    StylesManipulator.prototype.applyParagraphStyle = function (subDocInterval, style) {
        if (!control_1.ControlOptions.isEnabled(this.modelManipulator.modelManager.richOptions.control.paragraphStyle) || !style)
            return false;
        var count = this.calculateAffectedParagraphCount(subDocInterval);
        if (count > 0 && control_1.ControlOptions.isEnabled(this.modelManipulator.modelManager.richOptions.control.paragraphStyle)) {
            var paragraphIndex = search_1.SearchUtils.normedInterpolationIndexOf(subDocInterval.subDocument.paragraphs, function (p) { return p.startLogPosition.value; }, subDocInterval.interval.start);
            this.history.beginTransaction();
            for (var i = 0; i < count; i++) {
                var paragraph = subDocInterval.subDocument.paragraphs[paragraphIndex + i];
                var paragraphInterval = new fixed_1.FixedInterval(paragraph.startLogPosition.value, paragraph.length);
                this.history.addAndRedo(new apply_style_history_items_1.ApplyParagraphStyleHistoryItem(this.modelManipulator, new sub_document_1.SubDocumentInterval(subDocInterval.subDocument, paragraphInterval), style));
                this.history.addAndRedo(new paragraph_properties_history_items_1.ParagraphUseValueHistoryItem(this.modelManipulator, new sub_document_1.SubDocumentInterval(subDocInterval.subDocument, paragraphInterval), 0));
                this.history.addAndRedo(new character_properties_history_items_1.FontUseValueHistoryItem(this.modelManipulator, new sub_document_1.SubDocumentInterval(subDocInterval.subDocument, paragraphInterval), 0));
            }
            this.history.endTransaction();
        }
        else {
            if (!control_1.ControlOptions.isEnabled(this.modelManipulator.modelManager.richOptions.control.characterStyle))
                return false;
            if (!style.linkedStyle)
                this.createCharacterStyle(style);
            return this.applyCharacterStyle(subDocInterval, style.linkedStyle, false);
        }
        return true;
    };
    StylesManipulator.prototype.calculateAffectedParagraphCount = function (subDocInterval) {
        var paragraphs = subDocInterval.subDocument.getParagraphsByInterval(subDocInterval.interval);
        if (paragraphs.length > 1)
            return paragraphs.length;
        var paragraph = paragraphs[0];
        var lastParagraphCharSelected = subDocInterval.interval.length >= paragraph.length - 1;
        if (subDocInterval.interval.start === paragraph.startLogPosition.value && lastParagraphCharSelected || subDocInterval.interval.length === 0)
            return 1;
        return 0;
    };
    StylesManipulator.prototype.createCharacterStyle = function (paragraphStyle) {
        var charStyle = new character_style_1.CharacterStyle(paragraphStyle.styleName + " Char", paragraphStyle.localizedName + " Char", false, false, false, false, paragraphStyle.maskedCharacterProperties);
        this.history.addAndRedo(new create_style_link_history_item_1.CreateStyleLinkHistoryItem(this.modelManipulator, charStyle, paragraphStyle));
    };
    return StylesManipulator;
}(base_manipulator_1.BaseManipulator));
exports.StylesManipulator = StylesManipulator;
