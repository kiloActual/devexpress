"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var list_1 = require("@devexpress/utils/lib/utils/list");
var string_1 = require("@devexpress/utils/lib/utils/map/string");
var load_font_1 = require("../changes/model/load-font");
var merged_props_reset_1 = require("../changes/sub-document/properties/merged-props-reset");
var document_model_1 = require("../document-model");
var json_character_enums_1 = require("../json/enums/json-character-enums");
var json_font_info_converter_1 = require("../json/importers/json-font-info-converter");
var linked_interval_1 = require("../position/linked-interval");
var base_manipulator_1 = require("./base-manipulator");
var FontManipulator = (function (_super) {
    tslib_1.__extends(FontManipulator, _super);
    function FontManipulator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.loadingFontInfosHashtable = {};
        return _this;
    }
    FontManipulator.prototype.loadFontInfo = function (fontInfo, subDocument, applyNewFontOnIntervalsAfterLoad, measurer) {
        var _a, _b, _c;
        if (this.modelManipulator.modelManager.richOptions.fonts.limitedFonts)
            return;
        var existingInfo = string_1.StringMapUtils.elementBy(this.loadingFontInfosHashtable, function (info) { return info.fontInfo.name == fontInfo.name; });
        if (existingInfo) {
            existingInfo.addRequest(subDocument, applyNewFontOnIntervalsAfterLoad);
            return;
        }
        var fontCache = this.modelManipulator.model.cache.fontInfoCache;
        var fontIndex = fontCache.count;
        this.loadingFontInfosHashtable[fontInfo.name] = new OnLoadingFontInfoItem(subDocument, applyNewFontOnIntervalsAfterLoad, fontInfo);
        this.modelManipulator.notifyModelChanged(new load_font_1.LoadFontInfoModelChange(fontInfo));
        fontInfo.isLoad = false;
        fontCache.getItem(fontInfo);
        var modelManager = this.modelManipulator.modelManager;
        if (modelManager.clientMode) {
            var jsonItem = json_font_info_converter_1.JSONFontInfoConverter.convertToJSON(fontInfo);
            fontCache.merge((_a = {}, _a[fontIndex] = jsonItem, _a), json_font_info_converter_1.JSONFontInfoConverter.convertFromJSON);
            var newFontInfo = modelManager.modelManipulator.font.applyFontInfoLoadedOnPaste(measurer, (_b = {}, _b[json_character_enums_1.JSONLoadFontInfoCommand.FontInfoIndex] = fontIndex, _b), (_c = {}, _c[fontIndex] = jsonItem, _c));
            this.modelManipulator.raiseFontAdded(newFontInfo);
        }
    };
    FontManipulator.prototype.applyFontInfoLoadedOnPaste = function (measurer, jsonServerParams, jsonFontInfoCache) {
        var jsonFontInfo = jsonFontInfoCache[jsonServerParams[json_character_enums_1.JSONLoadFontInfoCommand.FontInfoIndex]];
        var name = jsonFontInfo[json_character_enums_1.JSONFontInfoProperty.Name];
        var existingNewFontInfo = this.model.cache.fontInfoCache.getItemByName(name);
        if (existingNewFontInfo.isLoad)
            return existingNewFontInfo;
        var onLoadingFontInfoItem = this.loadingFontInfosHashtable[existingNewFontInfo.name];
        if (!onLoadingFontInfoItem)
            return existingNewFontInfo;
        var modelManipulator = this.modelManipulator;
        delete this.loadingFontInfosHashtable[existingNewFontInfo.name];
        measurer.clearCache();
        json_font_info_converter_1.JSONFontInfoConverter.convertFromJSON(jsonFontInfo, existingNewFontInfo);
        onLoadingFontInfoItem.applyFont(modelManipulator);
        return existingNewFontInfo;
    };
    FontManipulator.prototype.addFontByName = function (name, cssName) {
        var newFont = this.model.cache.fontInfoCache.addFont(name, cssName);
        this.modelManipulator.raiseFontAdded(newFont);
        return newFont;
    };
    FontManipulator.prototype.removeFont = function (font) {
        this.model.cache.fontInfoCache.deleteFont(font);
        this.modelManipulator.raiseFontRemoved(font);
    };
    return FontManipulator;
}(base_manipulator_1.BaseManipulator));
exports.FontManipulator = FontManipulator;
var OnLoadingFontInfoItem = (function () {
    function OnLoadingFontInfoItem(subDocument, applyNewFontOnIntervalsAfterLoad, fontInfo) {
        this.fontInfo = fontInfo;
        this.subDocuments = [subDocument];
        this.applyNewFontOnIntervalsAfterLoad = [this.getLinkedIntervals(subDocument, applyNewFontOnIntervalsAfterLoad)];
    }
    OnLoadingFontInfoItem.prototype.addRequest = function (subDocument, applyNewFontOnIntervalsAfterLoad) {
        var intervals = this.getLinkedIntervals(subDocument, applyNewFontOnIntervalsAfterLoad);
        var index = this.subDocuments.indexOf(subDocument);
        if (index < 0) {
            this.subDocuments.push(subDocument);
            this.applyNewFontOnIntervalsAfterLoad.push(intervals);
        }
        else
            list_1.ListUtils.addListOnTail(this.applyNewFontOnIntervalsAfterLoad[index], intervals);
    };
    OnLoadingFontInfoItem.prototype.applyFont = function (modelManipulator) {
        var _this = this;
        list_1.ListUtils.forEach(this.subDocuments, function (subDocument, index) {
            var resetInterval = null;
            var mergedFixedIntervals = algorithms_1.IntervalAlgorithms.getMergedIntervals(list_1.ListUtils.map(_this.applyNewFontOnIntervalsAfterLoad[index], function (interval) { return interval.getFixedInterval(); }), true);
            for (var _i = 0, mergedFixedIntervals_1 = mergedFixedIntervals; _i < mergedFixedIntervals_1.length; _i++) {
                var interval = mergedFixedIntervals_1[_i];
                if (interval.length > 0) {
                    modelManipulator.characterProperties.fontName.setValue(subDocument, interval, _this.fontInfo, true);
                    var changed = subDocument.resetMergedFormattingCache(document_model_1.ResetFormattingCacheType.All, interval);
                    resetInterval = resetInterval ? resetInterval.expand(changed) : changed;
                }
            }
            if (resetInterval)
                modelManipulator.notifyModelChanged(new merged_props_reset_1.ParagraphAndCharacterMergedPropertiesResetSubDocumentChange(subDocument.id, resetInterval));
        });
        this.destructor();
    };
    OnLoadingFontInfoItem.prototype.getLinkedIntervals = function (subDocument, intervals) {
        return list_1.ListUtils.map(intervals, function (fixedInterval) {
            return new linked_interval_1.LinkedInterval(subDocument.positionManager, fixedInterval);
        });
    };
    OnLoadingFontInfoItem.prototype.destructor = function () {
        var _this = this;
        list_1.ListUtils.forEach(this.subDocuments, function (subDoc, index) {
            for (var _i = 0, _a = _this.applyNewFontOnIntervalsAfterLoad[index]; _i < _a.length; _i++) {
                var int = _a[_i];
                int.destructor(subDoc.positionManager);
            }
        });
    };
    return OnLoadingFontInfoItem;
}());
