"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var enum_1 = require("@devexpress/utils/lib/utils/enum");
var list_1 = require("@devexpress/utils/lib/utils/list");
var layout_anchored_object_box_1 = require("../../../layout/main-structures/layout-boxes/layout-anchored-object-box");
var anchor_info_property_history_item_1 = require("../../history/items/floating-objects/anchor-info-property-history-item");
var model_iterator_1 = require("../../model-iterator");
var run_type_1 = require("../../runs/run-type");
var sub_document_1 = require("../../sub-document");
var base_manipulator_1 = require("../base-manipulator");
var comparers_1 = require("./comparers");
var PosAndAncInfo = (function () {
    function PosAndAncInfo(anchorInfo, position) {
        this.anchorInfo = anchorInfo;
        this.position = position;
    }
    return PosAndAncInfo;
}());
exports.PosAndAncInfo = PosAndAncInfo;
var ZOrderManipulator = (function (_super) {
    tslib_1.__extends(ZOrderManipulator, _super);
    function ZOrderManipulator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ZOrderManipulator.prototype.getNewZOrder = function (subDoc) {
        var objects = this.getFloatingObjects(subDoc);
        return objects.length ? list_1.ListUtils.last(objects).anchorInfo.zOrder + ZOrderManipulator.STEP : ZOrderManipulator.STEP;
    };
    ZOrderManipulator.prototype.getFloatingObjects = function (subDoc) {
        var anchorInfos = [];
        var iterator = new model_iterator_1.ModelIterator(subDoc, false);
        iterator.setPosition(0);
        do {
            if (enum_1.EnumUtils.isAnyOf(iterator.run.getType(), run_type_1.RunType.AnchoredPictureRun, run_type_1.RunType.AnchoredTextBoxRun))
                anchorInfos.push(new PosAndAncInfo(iterator.run.anchorInfo, iterator.getAbsolutePosition()));
        } while (iterator.moveToNextRun());
        return anchorInfos.sort(comparers_1.posAndAncInfoOneSubDocComparer);
    };
    ZOrderManipulator.prototype.setNewZOrder = function (IModelAccessor, subDocument, position, newZOrder) {
        IModelAccessor.history.addAndRedo(new anchor_info_property_history_item_1.AnchorInfoPropertyHistoryItem(this.modelManipulator, new sub_document_1.SubDocumentInterval(subDocument, new fixed_1.FixedInterval(position, 1)), newZOrder, IModelAccessor.modelManipulator.floatingObject.anchorInfo.zOrder));
    };
    ZOrderManipulator.prototype.bringToFront = function (IModelAccessor, parentSubDocument, position) {
        var objects = this.getFloatingObjects(parentSubDocument);
        if (list_1.ListUtils.last(objects).position == position)
            return true;
        var newZOrder = list_1.ListUtils.last(objects).anchorInfo.zOrder + ZOrderManipulator.STEP;
        this.setNewZOrder(IModelAccessor, parentSubDocument, position, newZOrder);
        return true;
    };
    ZOrderManipulator.prototype.sendToBack = function (IModelAccessor, parentSubDocument, position) {
        var objects = this.getFloatingObjects(parentSubDocument);
        var firstObject = objects[0];
        if (firstObject.position == position)
            return true;
        var minZOrder = firstObject.anchorInfo.zOrder;
        if (minZOrder > 0) {
            this.setNewZOrder(IModelAccessor, parentSubDocument, position, Math.floor(minZOrder / 2));
            return true;
        }
        var objInd = list_1.ListUtils.indexBy(objects, function (elem) { return elem.position == position; });
        objects.splice(objInd, 1);
        IModelAccessor.history.beginTransaction();
        this.setNewZOrder(IModelAccessor, parentSubDocument, position, 1);
        this.advanceOrder(IModelAccessor, parentSubDocument, objects, 0, 2, false);
        IModelAccessor.history.endTransaction();
        return true;
    };
    ZOrderManipulator.prototype.bringForward = function (IModelAccessor, parentSubDocument, position) {
        var objects = this.getFloatingObjects(parentSubDocument);
        if (list_1.ListUtils.last(objects).position == position)
            return true;
        var objInd = list_1.ListUtils.indexBy(objects, function (elem) { return elem.position == position; });
        var newZValue = objects[objInd + 1].anchorInfo.zOrder + 1;
        IModelAccessor.history.beginTransaction();
        this.setNewZOrder(IModelAccessor, parentSubDocument, position, newZValue);
        this.advanceOrder(IModelAccessor, parentSubDocument, objects, objInd + 2, newZValue + 1, objects[objInd].anchorInfo.levelType == layout_anchored_object_box_1.AnchoredObjectLevelType.BehindText);
        IModelAccessor.history.endTransaction();
        return true;
    };
    ZOrderManipulator.prototype.sendBackward = function (IModelAccessor, parentSubDocument, position) {
        var objects = this.getFloatingObjects(parentSubDocument);
        if (objects[0].position == position)
            return true;
        var objInd = list_1.ListUtils.indexBy(objects, function (elem) { return elem.position == position; });
        var newZValue = objects[objInd - 1].anchorInfo.zOrder + 1;
        var obj = objects.splice(objInd, 1)[0];
        IModelAccessor.history.beginTransaction();
        this.setNewZOrder(IModelAccessor, parentSubDocument, position, newZValue);
        this.advanceOrder(IModelAccessor, parentSubDocument, objects, objInd - 1, newZValue + 1, obj.anchorInfo.levelType == layout_anchored_object_box_1.AnchoredObjectLevelType.BehindText);
        IModelAccessor.history.endTransaction();
        return true;
    };
    ZOrderManipulator.prototype.advanceOrder = function (IModelAccessor, subDocument, objects, fromIndex, minValue, advanceOnlyBehindText) {
        for (var ind = fromIndex, obj = objects[fromIndex], nextObj = void 0; obj; ind++) {
            nextObj = objects[ind];
            if (obj.anchorInfo.zOrder >= minValue || advanceOnlyBehindText && obj.anchorInfo.levelType != layout_anchored_object_box_1.AnchoredObjectLevelType.BehindText)
                break;
            var interval = fixed_1.FixedInterval.fromPositions(minValue, nextObj ? nextObj.anchorInfo.zOrder : obj.anchorInfo.zOrder + ZOrderManipulator.STEP * 2).normalizeLength();
            minValue = Math.floor(interval.center);
            this.setNewZOrder(IModelAccessor, subDocument, obj.position, minValue);
            minValue++;
            obj = nextObj;
        }
    };
    ZOrderManipulator.STEP = 1024;
    return ZOrderManipulator;
}(base_manipulator_1.BaseManipulator));
exports.ZOrderManipulator = ZOrderManipulator;
