"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var size_1 = require("@devexpress/utils/lib/geometry/size");
var search_1 = require("@devexpress/utils/lib/utils/search");
var anchor_info_1 = require("../floating-objects/anchor-info");
var enums_1 = require("../floating-objects/enums");
var sizes_1 = require("../floating-objects/sizes");
var text_box_properties_1 = require("../floating-objects/text-box-properties");
var anchored_picture_run_1 = require("../runs/anchored-picture-run");
var anchored_text_box_run_1 = require("../runs/anchored-text-box-run");
var inline_picture_run_1 = require("../runs/inline-picture-run");
var inline_text_box_run_1 = require("../runs/inline-text-box-run");
var run_type_1 = require("../runs/run-type");
var simple_runs_1 = require("../runs/simple-runs");
var text_run_1 = require("../runs/text-run");
var shape_1 = require("../shapes/shape");
var base_manipulator_1 = require("./base-manipulator");
var insert_picture_manipulator_params_1 = require("./picture-manipulator/insert-picture-manipulator-params");
var RunsBaseManipulator = (function (_super) {
    tslib_1.__extends(RunsBaseManipulator, _super);
    function RunsBaseManipulator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RunsBaseManipulator.prototype.insertRunInternal = function (subDocPos, charPropsBundle, type, text) {
        var subDocument = subDocPos.subDocument;
        var insertPositionAtStartDocument = subDocPos.position;
        var lastCharacterIndex = subDocument.getDocumentEndPosition();
        if (insertPositionAtStartDocument >= lastCharacterIndex)
            insertPositionAtStartDocument--;
        var chunkIndex = search_1.SearchUtils.normedInterpolationIndexOf(subDocument.chunks, function (c) { return c.startLogPosition.value; }, insertPositionAtStartDocument);
        var chunk = subDocument.chunks[chunkIndex];
        var startOffsetAtChunk = insertPositionAtStartDocument - chunk.startLogPosition.value;
        var currentRunIndex = search_1.SearchUtils.normedInterpolationIndexOf(chunk.textRuns, function (r) { return r.startOffset; }, startOffsetAtChunk);
        var currentRun = chunk.textRuns[currentRunIndex];
        var sectionIndex = search_1.SearchUtils.normedInterpolationIndexOf(subDocument.documentModel.sections, function (s) { return s.startLogPosition.value; }, insertPositionAtStartDocument);
        subDocument.documentModel.sections[sectionIndex].setLength(subDocument, subDocument.documentModel.sections[sectionIndex].getLength() + text.length);
        chunk.textBuffer = [chunk.textBuffer.substr(0, startOffsetAtChunk), text, chunk.textBuffer.substr(startOffsetAtChunk)].join('');
        if (startOffsetAtChunk != currentRun.startOffset) {
            if (type == run_type_1.RunType.TextRun && currentRun.getType() == run_type_1.RunType.TextRun && currentRun.characterStyle.equalsByName(charPropsBundle.style) &&
                currentRun.maskedCharacterProperties.equals(charPropsBundle.props)) {
                currentRun.incLength(text.length);
                RunsBaseManipulator.moveRunsInChunk(chunk, currentRunIndex + 1, text.length);
                subDocument.positionManager.advance(insertPositionAtStartDocument + 1, text.length);
                return { chunkIndex: chunkIndex, runIndex: currentRunIndex };
            }
            chunk.splitRun(currentRunIndex, startOffsetAtChunk - currentRun.startOffset);
            currentRunIndex++;
            currentRun = chunk.textRuns[currentRunIndex];
        }
        subDocument.positionManager.advance(insertPositionAtStartDocument + 1, text.length);
        var newTextRun;
        var prevRun = chunk.textRuns[currentRunIndex - 1];
        if (prevRun && type == run_type_1.RunType.TextRun && prevRun.getType() == run_type_1.RunType.TextRun && prevRun.characterStyle.equalsByName(charPropsBundle.style) &&
            prevRun.maskedCharacterProperties.equals(charPropsBundle.props)) {
            prevRun.incLength(text.length);
            RunsBaseManipulator.moveRunsInChunk(chunk, currentRunIndex, text.length);
            return { chunkIndex: chunkIndex, runIndex: currentRunIndex - 1 };
        }
        else {
            if (type == run_type_1.RunType.TextRun && currentRun.getType() == run_type_1.RunType.TextRun && currentRun.characterStyle.equalsByName(charPropsBundle.style) &&
                currentRun.maskedCharacterProperties.equals(charPropsBundle.props)) {
                currentRun.incLength(text.length);
                RunsBaseManipulator.moveRunsInChunk(chunk, currentRunIndex + 1, text.length);
                return { chunkIndex: chunkIndex, runIndex: currentRunIndex };
            }
            else {
                newTextRun = RunTemplateCreatorHelper.createRun[type](startOffsetAtChunk, text.length, currentRun.paragraph, charPropsBundle);
                chunk.textRuns.splice(currentRunIndex, 0, newTextRun);
                RunsBaseManipulator.moveRunsInChunk(chunk, currentRunIndex + 1, text.length);
                return { chunkIndex: chunkIndex, runIndex: currentRunIndex };
            }
        }
    };
    RunsBaseManipulator.moveRunsInChunk = function (chunk, startRunIndex, offset) {
        for (var i = startRunIndex, run = void 0; run = chunk.textRuns[i]; i++)
            run.startOffset += offset;
    };
    return RunsBaseManipulator;
}(base_manipulator_1.BaseManipulator));
exports.RunsBaseManipulator = RunsBaseManipulator;
var RunTemplateCreatorHelper = (function () {
    function RunTemplateCreatorHelper() {
    }
    RunTemplateCreatorHelper.createRun = (_a = {},
        _a[run_type_1.RunType.TextRun] = function (startOffset, length, paragraph, charPropsBundle) {
            return new text_run_1.TextRun(startOffset, length, paragraph, charPropsBundle);
        },
        _a[run_type_1.RunType.ParagraphRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new simple_runs_1.ParagraphRun(startOffset, paragraph, charPropsBundle);
        },
        _a[run_type_1.RunType.SectionRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new simple_runs_1.SectionRun(startOffset, paragraph, charPropsBundle);
        },
        _a[run_type_1.RunType.FieldCodeStartRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new simple_runs_1.FieldCodeStartRun(startOffset, paragraph, charPropsBundle);
        },
        _a[run_type_1.RunType.FieldCodeEndRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new simple_runs_1.FieldCodeEndRun(startOffset, paragraph, charPropsBundle);
        },
        _a[run_type_1.RunType.FieldResultEndRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new simple_runs_1.FieldResultEndRun(startOffset, paragraph, charPropsBundle);
        },
        _a[run_type_1.RunType.AnchoredPictureRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new anchored_picture_run_1.AnchoredPictureRun(startOffset, paragraph, charPropsBundle, insert_picture_manipulator_params_1.AnchorPictureInfo.defaultInfo(null, new size_1.Size(0, 0)), -1);
        },
        _a[run_type_1.RunType.AnchoredTextBoxRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new anchored_text_box_run_1.AnchoredTextBoxRun(startOffset, paragraph, charPropsBundle, new shape_1.Shape(), -1, new sizes_1.AnchorTextBoxSize(true, 0, new size_1.Size(0, 0), new size_1.Size(0, 0), enums_1.RelativeWidthType.Page, enums_1.RelativeHeightType.Page, true, true), new anchor_info_1.AnchorInfo(), -1, new text_box_properties_1.TextBoxProperties());
        },
        _a[run_type_1.RunType.InlinePictureRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new inline_picture_run_1.InlinePictureRun(startOffset, paragraph, charPropsBundle, insert_picture_manipulator_params_1.InlinePictureInfo.defaultInfo(null));
        },
        _a[run_type_1.RunType.InlineTextBoxRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new inline_text_box_run_1.InlineTextBoxRun(startOffset, paragraph, charPropsBundle, new shape_1.Shape(), -1, new sizes_1.InlineTextBoxSize(true, 0, new size_1.Size(0, 0)), new text_box_properties_1.TextBoxProperties());
        },
        _a[run_type_1.RunType.LayoutDependentRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new simple_runs_1.LayoutDependentRun(startOffset, paragraph, charPropsBundle);
        },
        _a[run_type_1.RunType.FootNoteRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new simple_runs_1.FootNoteRun(startOffset, paragraph, charPropsBundle);
        },
        _a[run_type_1.RunType.EndNoteRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new simple_runs_1.EndNoteRun(startOffset, paragraph, charPropsBundle);
        },
        _a[run_type_1.RunType.NoteSeparatorRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new simple_runs_1.NoteSeparatorRun(startOffset, paragraph, charPropsBundle);
        },
        _a[run_type_1.RunType.NoteContinuationSeparatorRun] = function (startOffset, _length, paragraph, charPropsBundle) {
            return new simple_runs_1.NoteContinuationSeparatorRun(startOffset, paragraph, charPropsBundle);
        },
        _a);
    return RunTemplateCreatorHelper;
}());
