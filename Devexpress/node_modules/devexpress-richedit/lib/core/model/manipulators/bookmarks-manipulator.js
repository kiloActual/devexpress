"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var boundary_1 = require("@devexpress/utils/lib/intervals/boundary");
var list_1 = require("@devexpress/utils/lib/utils/list");
var number_1 = require("@devexpress/utils/lib/utils/map/number");
var search_1 = require("@devexpress/utils/lib/utils/search");
var bookmarks_1 = require("../bookmarks");
var created_1 = require("../changes/sub-document/bookmark/created");
var deleted_1 = require("../changes/sub-document/bookmark/deleted");
var base_manipulator_1 = require("./base-manipulator");
var BookmarksManipulator = (function (_super) {
    tslib_1.__extends(BookmarksManipulator, _super);
    function BookmarksManipulator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BookmarksManipulator.prototype.createBookmark = function (subDocument, bkmTemplate, needSort) {
        subDocument.bookmarks.push(new bookmarks_1.Bookmark(subDocument.positionManager, bkmTemplate, bkmTemplate.name));
        if (needSort)
            subDocument.bookmarks = subDocument.bookmarks.sort(bookmarks_1.ConstBookmark.comparer);
        this.modelManipulator.notifyModelChanged(new created_1.BookmarkCreatedSubDocumentChange(subDocument.id, bkmTemplate));
    };
    BookmarksManipulator.prototype.deleteBookmark = function (subDocument, bkmTemplate, bookmarkIndex) {
        if (bookmarkIndex === void 0) { bookmarkIndex = list_1.ListUtils.indexBy(subDocument.bookmarks, function (b) { return b.constBookmark.equals(bkmTemplate); }); }
        subDocument.bookmarks.splice(bookmarkIndex, 1)[0].destructor(subDocument.positionManager);
        this.modelManipulator.notifyModelChanged(new deleted_1.BookmarkDeletedSubDocumentChange(subDocument.id, bkmTemplate));
    };
    BookmarksManipulator.findBookmark = function (subDocuments, name) {
        var bookmark;
        var subDocument = number_1.NumberMapUtils.elementBy(subDocuments, function (subDoc) {
            return !!(bookmark = list_1.ListUtils.elementBy(subDoc.bookmarks, function (bm) { return bm.name == name; }));
        });
        return subDocument ? new bookmarks_1.BookmarkAndSubDocument(bookmark, subDocument) : null;
    };
    BookmarksManipulator.copyBookmarksFromSubDocumentTo = function (fromSubDocument, toSubDocument, fromIntervals) {
        var bkms = [];
        algorithms_1.IntervalAlgorithms.handleAffectedObjects(fromSubDocument.bookmarks, algorithms_1.IntervalAlgorithms.getMergedIntervalsTemplate(fromIntervals, true, new boundary_1.BoundaryInterval(0, 0)), function (bkm, _index, interval, intersection) {
            if (intersection.length || bkm.interval.length == 0)
                bkms.push(new bookmarks_1.ConstBookmark(new boundary_1.BoundaryInterval(bkm.start - interval.start, bkm.end - interval.start), bkm.name));
        }, BookmarksManipulator.findBookmarkStartIndex);
        toSubDocument.bookmarks = list_1.ListUtils.map(list_1.ListUtils.unique(bkms, bookmarks_1.ConstBookmark.comparer, bookmarks_1.ConstBookmark.comparer), function (tmlBkm) { return tmlBkm.createBookmark(toSubDocument.positionManager); });
    };
    BookmarksManipulator.prototype.deleteBookmarks = function (subDocument, interval) {
        var bookmarks = subDocument.bookmarks;
        var result = [];
        var ind = search_1.SearchUtils.normedInterpolationIndexOf(bookmarks, function (b) { return b.start; }, interval.start);
        for (var currBkm = void 0; (currBkm = bookmarks[ind]) && currBkm.start >= interval.start; ind--)
            ;
        ind = Math.max(0, ind);
        for (var curr = void 0; (curr = bookmarks[ind]) && curr.interval.start <= interval.end;) {
            if (interval.containsInterval(curr.interval)) {
                var tmpl = curr.constBookmark;
                this.deleteBookmark(subDocument, tmpl, ind);
                result.push(tmpl);
            }
            else
                ind++;
        }
        return result;
    };
    BookmarksManipulator.prototype.insertBookmarksFromSubDocument = function (fromSubDocument, toSubDocument, fromInterval, modelsConstOffset) {
        var bookmarks = fromSubDocument.bookmarks;
        var ind = search_1.SearchUtils.normedInterpolationIndexOf(bookmarks, function (b) { return b.start; }, fromInterval.start);
        for (var currBkm = void 0; (currBkm = bookmarks[ind]) && currBkm.start >= fromInterval.start; ind--)
            ;
        ind = Math.max(0, ind);
        for (var bkm = void 0; (bkm = bookmarks[ind]) && bkm.start <= fromInterval.end; ind++) {
            if (fromInterval.containsInterval(bkm.interval)) {
                var template = bkm.constBookmark;
                template.interval.start += modelsConstOffset;
                template.interval.end += modelsConstOffset;
                this.createBookmark(toSubDocument, template, false);
            }
        }
        toSubDocument.bookmarks = toSubDocument.bookmarks.sort(bookmarks_1.ConstBookmark.comparer);
    };
    BookmarksManipulator.findBookmarkStartIndex = function (_pos, _bookmarks) {
        return 0;
    };
    return BookmarksManipulator;
}(base_manipulator_1.BaseManipulator));
exports.BookmarksManipulator = BookmarksManipulator;
