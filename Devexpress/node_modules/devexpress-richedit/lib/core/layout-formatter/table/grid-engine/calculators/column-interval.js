"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var min_max_1 = require("@devexpress/utils/lib/class/min-max");
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var table_units_1 = require("../../../../model/tables/secondary-structures/table-units");
var GridColumnBase = (function () {
    function GridColumnBase(interval) {
        this.width = interval.type == table_units_1.TableWidthUnitType.ModelUnits ? unit_converter_1.UnitConverter.twipsToPixelsF(interval.width) : interval.width;
        this.type = interval.type;
        this.percentValue = 0;
        this.preferredWidth = 0;
        this.bounds = new min_max_1.MinMaxNumber(0, 0);
    }
    Object.defineProperty(GridColumnBase.prototype, "isPercentBased", {
        get: function () {
            return this.type == table_units_1.TableWidthUnitType.FiftiethsOfPercent;
        },
        enumerable: true,
        configurable: true
    });
    GridColumnBase.prototype.updateMinBound = function (val) {
        if (val > this.bounds.minElement)
            this.bounds.minElement = val;
    };
    GridColumnBase.prototype.updateMaxBound = function (val) {
        if (val > this.bounds.maxElement)
            this.bounds.maxElement = val;
    };
    GridColumnBase.totalMinWidth = function (columns, startColumnIndex, endColumnIndex) {
        if (startColumnIndex === void 0) { startColumnIndex = 0; }
        if (endColumnIndex === void 0) { endColumnIndex = columns.length; }
        var result = 0;
        for (var columnIndex = startColumnIndex; columnIndex < endColumnIndex; columnIndex++)
            result += columns[columnIndex].bounds.minElement;
        return result;
    };
    GridColumnBase.totalMaxWidth = function (columns, startColumnIndex, endColumnIndex) {
        if (startColumnIndex === void 0) { startColumnIndex = 0; }
        if (endColumnIndex === void 0) { endColumnIndex = columns.length; }
        var result = 0;
        for (var columnIndex = startColumnIndex; columnIndex < endColumnIndex; columnIndex++)
            result += columns[columnIndex].bounds.maxElement;
        return result;
    };
    GridColumnBase.totalWidth = function (columns, startColumnIndex, endColumnIndex) {
        if (startColumnIndex === void 0) { startColumnIndex = 0; }
        if (endColumnIndex === void 0) { endColumnIndex = columns.length; }
        var result = 0;
        for (var columnIndex = startColumnIndex; columnIndex < endColumnIndex; columnIndex++)
            result += columns[columnIndex].width;
        return result;
    };
    GridColumnBase.totalPercentWidth = function (columns, startColumnIndex, endColumnIndex) {
        if (startColumnIndex === void 0) { startColumnIndex = 0; }
        if (endColumnIndex === void 0) { endColumnIndex = columns.length; }
        var result = 0;
        for (var columnIndex = startColumnIndex; columnIndex < endColumnIndex; columnIndex++)
            result += columns[columnIndex].percentValue;
        return result;
    };
    GridColumnBase.totalPreferredWidth = function (columns, startColumnIndex, endColumnIndex) {
        if (startColumnIndex === void 0) { startColumnIndex = 0; }
        if (endColumnIndex === void 0) { endColumnIndex = columns.length; }
        var result = 0;
        for (var columnIndex = startColumnIndex; columnIndex < endColumnIndex; columnIndex++)
            result += columns[columnIndex].preferredWidth;
        return result;
    };
    GridColumnBase.getLastDXAColumnIndex = function (columns, startColumnIndex, endColumnIndex) {
        if (startColumnIndex === void 0) { startColumnIndex = 0; }
        if (endColumnIndex === void 0) { endColumnIndex = columns.length; }
        for (var columnIndex = endColumnIndex - 1; columnIndex >= startColumnIndex; columnIndex--)
            if (columns[columnIndex].preferredWidth)
                return columnIndex;
        return -1;
    };
    return GridColumnBase;
}());
exports.GridColumnBase = GridColumnBase;
var ColumnIntervalFixed = (function (_super) {
    tslib_1.__extends(ColumnIntervalFixed, _super);
    function ColumnIntervalFixed() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ColumnIntervalFixed;
}(GridColumnBase));
exports.ColumnIntervalFixed = ColumnIntervalFixed;
var ColumnIntervalAuto = (function (_super) {
    tslib_1.__extends(ColumnIntervalAuto, _super);
    function ColumnIntervalAuto(interval) {
        var _this = _super.call(this, interval) || this;
        _this.totalHorizontalMargins = 0;
        return _this;
    }
    ColumnIntervalAuto.totalHorizontalMargins = function (columns, startColumnIndex, endColumnIndex) {
        var result = 0;
        for (var columnIndex = startColumnIndex; columnIndex < endColumnIndex; columnIndex++)
            result += columns[columnIndex].totalHorizontalMargins;
        return result;
    };
    ColumnIntervalAuto.hasColumnsWithoutPreferredWidth = function (columns, startColumnIndex, endColumnIndex) {
        if (startColumnIndex === void 0) { startColumnIndex = 0; }
        if (endColumnIndex === void 0) { endColumnIndex = columns.length; }
        for (var columnIndex = startColumnIndex; columnIndex < endColumnIndex; columnIndex++)
            if (!columns[columnIndex].preferredWidth)
                return true;
        return false;
    };
    return ColumnIntervalAuto;
}(GridColumnBase));
exports.ColumnIntervalAuto = ColumnIntervalAuto;
