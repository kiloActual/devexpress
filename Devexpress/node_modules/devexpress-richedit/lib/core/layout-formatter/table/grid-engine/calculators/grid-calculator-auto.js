"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var list_1 = require("@devexpress/utils/lib/utils/list");
var table_1 = require("../../../../model/tables/main-structures/table");
var table_base_structures_1 = require("../../../../model/tables/secondary-structures/table-base-structures");
var table_units_1 = require("../../../../model/tables/secondary-structures/table-units");
var column_interval_1 = require("./column-interval");
var grid_calculator_1 = require("./grid-calculator");
var table_cell_width_calculator_1 = require("./table-width-calculators/table-cell-width-calculator");
var GridCalculatorAuto = (function (_super) {
    tslib_1.__extends(GridCalculatorAuto, _super);
    function GridCalculatorAuto() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GridCalculatorAuto.prototype.makeInterval = function (interval) {
        return new column_interval_1.ColumnIntervalAuto(interval);
    };
    GridCalculatorAuto.prototype.applyCellsWidth = function (_intervals) {
        this.calcCacheCellWidths();
        this.applyCellContentWidth();
    };
    GridCalculatorAuto.prototype.autofitTail = function (totalWidth, estimatedTableWidth) {
        if (this.currCache.layoutType == table_base_structures_1.TableLayoutType.Fixed)
            return;
        var totalMinWidth = column_interval_1.GridColumnBase.totalMinWidth(this.columns);
        var maxPermissibleTableWidth = totalMinWidth;
        if (estimatedTableWidth <= this.percentBaseWidth)
            maxPermissibleTableWidth = Math.min(maxPermissibleTableWidth, this.percentBaseWidth);
        maxPermissibleTableWidth = Math.max(estimatedTableWidth, maxPermissibleTableWidth);
        if (!this.currCache.isFixedTableWidth)
            maxPermissibleTableWidth = Math.min(this.percentBaseWidth, maxPermissibleTableWidth);
        if (totalWidth > maxPermissibleTableWidth) {
            if (maxPermissibleTableWidth > totalMinWidth) {
                this.compressTableGrid(maxPermissibleTableWidth);
            }
            else {
                this.compressProportionallyMinWidth(maxPermissibleTableWidth, totalMinWidth);
            }
        }
    };
    GridCalculatorAuto.prototype.compressProportionallyMinWidth = function (totalWidth, rest) {
        for (var i = 0; i < this.columns.length; i++) {
            var column = this.columns[i];
            var newColumnWidth = rest > 0 ? Math.max(column.bounds.minElement * totalWidth / rest, grid_calculator_1.GridCalculator.minColumnWidth) : grid_calculator_1.GridCalculator.minColumnWidth;
            column.width = newColumnWidth;
            totalWidth -= newColumnWidth;
            rest -= column.bounds.minElement;
        }
    };
    GridCalculatorAuto.prototype.calcCacheCellWidths = function () {
        var pos = new table_1.TablePosition(this.table, -1, -1);
        while (pos.moveToNextRow())
            while (pos.moveToNextCell())
                new table_cell_width_calculator_1.TableCellWidthCalculator(this.subDocument, this.boxIterator, this.grid, this.cache, pos, this.percentBaseWidth).cellWidth();
    };
    GridCalculatorAuto.prototype.applyCellContentWidth = function () {
        var pos = new table_1.TablePosition(this.table, -1, -1);
        while (pos.moveToNextRow()) {
            var columnIndex = pos.row.gridBefore;
            while (pos.moveToNextCell()) {
                if (pos.cell.columnSpan == 1)
                    this.applyCellContentWidthWithoutSpan(this.columns, pos, columnIndex);
                columnIndex += pos.cell.columnSpan;
            }
        }
        for (var _i = 0, _a = this.columns; _i < _a.length; _i++) {
            var column = _a[_i];
            if (column.bounds.minElement == 0 && column.bounds.maxElement == 0) {
                if (column.isPercentBased)
                    column.bounds.minElement = column.bounds.maxElement = 1;
                else
                    column.bounds.minElement = column.bounds.maxElement = Math.max(1, column.width);
            }
        }
        pos.initIndexes(-1, -1);
        while (pos.moveToNextRow()) {
            var columnIndex = pos.row.gridBefore;
            while (pos.moveToNextCell()) {
                if (pos.cell.columnSpan > 1)
                    this.applyCellContentWidthWithSpan(this.columns, pos, columnIndex);
                columnIndex += pos.cell.columnSpan;
            }
        }
        for (var _b = 0, _c = this.columns; _b < _c.length; _b++) {
            var column = _c[_b];
            column.width = column.bounds.maxElement = Math.max(column.bounds.maxElement, grid_calculator_1.GridCalculator.minColumnWidth);
        }
    };
    GridCalculatorAuto.prototype.applyCellContentWidthWithoutSpan = function (columns, pos, columnIndex) {
        var cellCache = this.currCache.rows[pos.rowIndex].cells[pos.cellIndex];
        var info = cellCache.contentWidthsInfo;
        var cellMinWidth = Math.max(grid_calculator_1.GridCalculator.minColumnWidth, info.minElement);
        var cellMaxWidth = Math.max(grid_calculator_1.GridCalculator.minColumnWidth, info.maxElement);
        var column = columns[columnIndex];
        column.updateMinBound(cellMinWidth);
        column.updateMaxBound(cellMaxWidth);
        column.totalHorizontalMargins = Math.max(column.totalHorizontalMargins, cellCache.horizontalMargins);
        var preferredWidth = pos.cell.preferredWidth;
        var cellWidthType = preferredWidth.type;
        if (cellWidthType == table_units_1.TableWidthUnitType.FiftiethsOfPercent) {
            if (preferredWidth.value > 0) {
                column.type = table_units_1.TableWidthUnitType.FiftiethsOfPercent;
                var percentWidth = Math.min(this.maxPercentWidth, preferredWidth.value);
                column.percentValue = Math.max(percentWidth, column.percentValue);
            }
            else if (this.currCache.isFixedTableWidth) {
                this.applyPreferredWidth(column, cellMinWidth, 0);
            }
        }
        else if (cellWidthType == table_units_1.TableWidthUnitType.ModelUnits)
            this.applyPreferredWidth(column, cellMinWidth, preferredWidth.asNumber(this.percentBaseWidth, unit_converter_1.UnitConverter.twipsToPixels));
    };
    GridCalculatorAuto.prototype.applyPreferredWidth = function (column, cellMinWidth, preferredWidth) {
        preferredWidth = Math.max(cellMinWidth, preferredWidth);
        column.preferredWidth = Math.max(column.preferredWidth, preferredWidth);
        column.updateMaxBound(column.preferredWidth);
    };
    GridCalculatorAuto.prototype.applyCellContentWidthWithSpan = function (columns, pos, startColumnIndex) {
        var endColumnIndex = startColumnIndex + pos.cell.columnSpan - 1;
        var nextEndColumnIndex = endColumnIndex + 1;
        var cellCache = this.currCache.rows[pos.rowIndex].cells[pos.cellIndex];
        var info = cellCache.contentWidthsInfo;
        var cellMinWidth = Math.max(grid_calculator_1.GridCalculator.minColumnWidth, info.minElement);
        var cellMaxWidth = Math.max(grid_calculator_1.GridCalculator.minColumnWidth, info.maxElement);
        var preferredWidth = pos.cell.preferredWidth;
        var lastColumn = this.columns[endColumnIndex];
        if (preferredWidth.type == table_units_1.TableWidthUnitType.FiftiethsOfPercent) {
            var totalPercent = column_interval_1.GridColumnBase.totalPercentWidth(this.columns, startColumnIndex, nextEndColumnIndex);
            var currrentPercentValue = Math.min(this.maxPercentWidth, preferredWidth.value);
            if (list_1.ListUtils.allOf(this.columns, function (col) { return col.isPercentBased; }, startColumnIndex, nextEndColumnIndex)) {
                var totalBefore = column_interval_1.GridColumnBase.totalPercentWidth(this.columns, startColumnIndex, endColumnIndex);
                lastColumn.percentValue = Math.max(currrentPercentValue - totalBefore, lastColumn.percentValue);
            }
            else if (totalPercent > 0) {
                var percentRest_1 = Math.max(0, currrentPercentValue - totalPercent);
                var totaNoPercentMaxWidth_1 = 0;
                list_1.ListUtils.forEach(this.columns, function (col) {
                    if (!col.isPercentBased)
                        totaNoPercentMaxWidth_1 += col.bounds.maxElement;
                }, startColumnIndex, nextEndColumnIndex);
                list_1.ListUtils.forEach(this.columns, function (col) {
                    if (!col.isPercentBased) {
                        col.percentValue = Math.max(1, percentRest_1 * col.bounds.maxElement / totaNoPercentMaxWidth_1);
                        col.type = table_units_1.TableWidthUnitType.FiftiethsOfPercent;
                    }
                }, startColumnIndex, nextEndColumnIndex);
            }
        }
        else if (preferredWidth.type == table_units_1.TableWidthUnitType.ModelUnits) {
            var preferredWidthValue = preferredWidth.asNumber(this.percentBaseWidth, unit_converter_1.UnitConverter.twipsToPixelsF);
            preferredWidthValue = Math.max(cellMinWidth, preferredWidthValue);
            cellMaxWidth = preferredWidthValue;
            if (list_1.ListUtils.allOf(this.columns, function (col) { return !col.isPercentBased && col.preferredWidth > 0; }, startColumnIndex, nextEndColumnIndex)) {
                var totalMaxWidthBefore = column_interval_1.GridColumnBase.totalMaxWidth(this.columns, startColumnIndex, endColumnIndex);
                lastColumn.preferredWidth = Math.max(lastColumn.preferredWidth, preferredWidthValue - totalMaxWidthBefore);
                lastColumn.updateMaxBound(lastColumn.preferredWidth);
                var gridMinWidth_1 = column_interval_1.GridColumnBase.totalMinWidth(this.columns, startColumnIndex, nextEndColumnIndex);
                if (cellMinWidth > gridMinWidth_1)
                    this.enlargeColumnsMinWidthByPreferredWidth(startColumnIndex, endColumnIndex, cellMinWidth, preferredWidthValue);
                return;
            }
        }
        var gridMinWidth = column_interval_1.ColumnIntervalAuto.totalMinWidth(columns, startColumnIndex, nextEndColumnIndex);
        if (cellMinWidth > gridMinWidth)
            this.enlargeColumnsMinWidth(columns, startColumnIndex, nextEndColumnIndex, cellMinWidth);
        var gridMaxWidth = column_interval_1.ColumnIntervalAuto.totalMaxWidth(columns, startColumnIndex, nextEndColumnIndex);
        if (cellMaxWidth > gridMaxWidth)
            this.enlargeColumnsMaxWidth(columns, startColumnIndex, nextEndColumnIndex, gridMaxWidth, cellMaxWidth);
        var gridTotalMargins = column_interval_1.ColumnIntervalAuto.totalHorizontalMargins(columns, startColumnIndex, nextEndColumnIndex);
        if (cellCache.horizontalMargins > gridTotalMargins)
            this.enlargeColumnsHorizontalMargins(columns, startColumnIndex, nextEndColumnIndex, gridTotalMargins, cellCache.horizontalMargins);
    };
    GridCalculatorAuto.prototype.enlargeColumnsMinWidthByPreferredWidth = function (startColumnIndex, endColumnIndex, cellMinWidth, totalPreferredWidth) {
        var restMinWidth = cellMinWidth;
        var restTotalPreferredWidth = totalPreferredWidth;
        for (var i = endColumnIndex; i >= startColumnIndex; i--) {
            var column = this.columns[i];
            if (column.preferredWidth > 0 && restTotalPreferredWidth > 0) {
                column.bounds.minElement = column.preferredWidth * restMinWidth / restTotalPreferredWidth;
                column.updateMaxBound(column.bounds.minElement);
                restMinWidth -= column.bounds.minElement;
                restTotalPreferredWidth -= column.preferredWidth;
            }
        }
    };
    GridCalculatorAuto.prototype.enlargeColumnsHorizontalMargins = function (columns, startColumnIndex, endColumnIndex, oldWidth, newWidth) {
        var equalSpace = oldWidth == 0;
        var totalDelta = newWidth - oldWidth;
        var totalCount = endColumnIndex - startColumnIndex + 1;
        for (var i = endColumnIndex - 1, column = void 0; (column = columns[i]) && totalDelta > 0; i--) {
            var delta = equalSpace ? totalDelta / totalCount : totalDelta * column.totalHorizontalMargins / oldWidth;
            totalDelta -= delta;
            oldWidth -= column.totalHorizontalMargins;
            column.totalHorizontalMargins += delta;
            totalCount--;
        }
    };
    GridCalculatorAuto.prototype.enlargeColumnsMinWidth = function (columns, startColumnIndex, endColumnIndex, newWidth) {
        var hasColumnsWithoutPreferredWidth = column_interval_1.ColumnIntervalAuto.hasColumnsWithoutPreferredWidth(columns, startColumnIndex, endColumnIndex);
        var zeroMinWidthCount = 0;
        var existingMinWidth = 0;
        list_1.ListUtils.forEach(columns, function (column) {
            if (column.bounds.minElement == 0 && column.bounds.maxElement == 0)
                zeroMinWidthCount++;
            else
                existingMinWidth += column.bounds.minElement;
        }, startColumnIndex, endColumnIndex);
        var rest = column_interval_1.ColumnIntervalAuto.totalMaxWidth(columns, startColumnIndex, endColumnIndex) +
            column_interval_1.ColumnIntervalAuto.totalMinWidth(columns, startColumnIndex, endColumnIndex);
        var equalSpace = rest == 0;
        if (equalSpace || zeroMinWidthCount > 0) {
            rest = endColumnIndex - startColumnIndex;
            newWidth -= existingMinWidth;
        }
        list_1.ListUtils.reverseForEach(columns, function (column) {
            if (!hasColumnsWithoutPreferredWidth || column.preferredWidth == 0) {
                if (zeroMinWidthCount > 0 && (column.bounds.minElement > 0 || column.bounds.maxElement > 0))
                    return;
                var factor = (equalSpace || zeroMinWidthCount > 0) ? 1 : (column.bounds.minElement + column.bounds.maxElement);
                var newMinWidth = factor * newWidth / rest;
                rest -= factor;
                newWidth -= newMinWidth;
                column.updateMinBound(newMinWidth);
                column.updateMaxBound(column.bounds.minElement);
            }
        }, endColumnIndex - 1, startColumnIndex);
    };
    GridCalculatorAuto.prototype.enlargeColumnsMaxWidth = function (columns, startColumnIndex, endColumnIndex, oldWidth, newWidth) {
        var allColumnsHavePreferredWidth = list_1.ListUtils.allOf(columns, function (col) { return col.preferredWidth != 0; }, startColumnIndex, endColumnIndex);
        var rest = oldWidth;
        list_1.ListUtils.reverseForEach(columns, function (column) {
            if (allColumnsHavePreferredWidth || column.preferredWidth == 0) {
                var newMaxWidth = rest != 0 ? column.bounds.maxElement * newWidth / rest : 0;
                rest -= column.bounds.maxElement;
                newWidth -= newMaxWidth;
                if (rest < 0)
                    rest = 0;
                if (newWidth < 0)
                    newWidth = 0;
                column.bounds.maxElement = Math.max(grid_calculator_1.GridCalculator.minColumnWidth, newMaxWidth);
            }
        }, endColumnIndex - 1, startColumnIndex);
    };
    return GridCalculatorAuto;
}(grid_calculator_1.GridCalculator));
exports.GridCalculatorAuto = GridCalculatorAuto;
