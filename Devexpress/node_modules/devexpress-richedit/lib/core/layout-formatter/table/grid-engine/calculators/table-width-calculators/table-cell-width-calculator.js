"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var min_max_1 = require("../../../../../../base-utils/min-max");
var min_max_2 = require("@devexpress/utils/lib/class/min-max");
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var constants_1 = require("@devexpress/utils/lib/constants");
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var list_1 = require("@devexpress/utils/lib/utils/list");
var table_1 = require("../../../../../model/tables/main-structures/table");
var table_base_structures_1 = require("../../../../../model/tables/secondary-structures/table-base-structures");
var table_units_1 = require("../../../../../model/tables/secondary-structures/table-units");
var table_width_calculator_1 = require("./table-width-calculator");
var TableCellWidthCalculator = (function () {
    function TableCellWidthCalculator(subDocument, boxIterator, grid, cache, pos, percentBaseWidth) {
        this.subDocument = subDocument;
        this.boxIterator = boxIterator;
        this.cache = cache;
        this.pos = pos;
        this.percentBaseWidth = percentBaseWidth;
        this.grid = grid;
    }
    TableCellWidthCalculator.prototype.cellWidth = function () {
        var currCache = this.cache[this.grid.table.index];
        var info = this.grid.tableCellInfos[this.pos.rowIndex][this.pos.cellIndex];
        if (this.pos.cell.verticalMerging == table_base_structures_1.TableCellMergingState.Continue)
            return currCache.rows[info.getStartRowIndex()].cells[info.getCellIndexAbs(info.getStartRowIndex())].contentWidthsInfo;
        var table = this.pos.table;
        var cellStartRowIndex = info.getStartRowIndex();
        this.pos = new table_1.TablePosition(table, cellStartRowIndex, info.getCellIndexAbs(cellStartRowIndex)).init();
        var cellCache = currCache.rows[this.pos.rowIndex].cells[this.pos.cellIndex];
        var horizontalBorders = cellCache.leftBorderWidth + cellCache.rightBorderWidth;
        var cellPreferredWidth = this.pos.cell.preferredWidth;
        var cellPreferredWidthValue = cellPreferredWidth.asNumber(this.percentBaseWidth, unit_converter_1.UnitConverter.twipsToPixelsF);
        if (currCache.layoutType == table_base_structures_1.TableLayoutType.Fixed) {
            var outerWidth_1 = cellCache.horizontalMargins + cellCache.spacing + horizontalBorders;
            var result = Math.max(outerWidth_1, cellPreferredWidthValue);
            return cellCache.contentWidthsInfo = new min_max_2.MinMaxNumber(result, result);
        }
        else {
            var contentWidths = this.cellWidthCore(this.pos);
            if (cellCache.noWrap && cellPreferredWidth.type != table_units_1.TableWidthUnitType.ModelUnits) {
                var maxWidth = Math.max(contentWidths.minElement, contentWidths.maxElement);
                contentWidths = new min_max_2.MinMaxNumber(maxWidth, maxWidth);
            }
            var resultMinWidth = contentWidths.minElement + cellCache.horizontalMargins + cellCache.spacing + horizontalBorders;
            if (cellCache.noWrap && cellPreferredWidth.type == table_units_1.TableWidthUnitType.ModelUnits)
                resultMinWidth = Math.max(cellPreferredWidthValue, resultMinWidth);
            resultMinWidth = Math.min(constants_1.Constants.MAX_SAFE_INTEGER, resultMinWidth);
            var resultMaxWidth = contentWidths.maxElement + cellCache.horizontalMargins + cellCache.spacing + horizontalBorders;
            if (cellPreferredWidth.type == table_units_1.TableWidthUnitType.ModelUnits)
                resultMaxWidth = Math.max(resultMinWidth, cellPreferredWidthValue);
            resultMaxWidth = Math.min(constants_1.Constants.MAX_SAFE_INTEGER, resultMaxWidth);
            return cellCache.contentWidthsInfo = new min_max_2.MinMaxNumber(resultMinWidth, resultMaxWidth);
        }
    };
    TableCellWidthCalculator.prototype.getTableWidth = function (table, percentBaseWidth) {
        var tablePreferredWidth = table.preferredWidth;
        var tableIndent = table.getActualTableIndent(this.subDocument.documentModel.defaultTableProperties);
        var result = new table_width_calculator_1.TableWidthCalculator(this.subDocument, this.boxIterator, this.cache, table, 0).tableWidth();
        if (tablePreferredWidth.type != table_units_1.TableWidthUnitType.Nil && tablePreferredWidth.type != table_units_1.TableWidthUnitType.Auto) {
            var tableWidth = tablePreferredWidth.asNumber(percentBaseWidth, unit_converter_1.UnitConverter.twipsToPixelsF) +
                tableIndent.asNumber(percentBaseWidth, unit_converter_1.UnitConverter.twipsToPixelsF);
            min_max_1.updateMinMaxBounds(result, new min_max_2.MinMaxNumber(tableWidth, tableWidth));
        }
        return result;
    };
    TableCellWidthCalculator.prototype.getInnerTables = function (pos) {
        var lowerLevelIndex = pos.table.nestedLevel + 1;
        var tables = this.boxIterator.subDocument.tablesByLevels[lowerLevelIndex];
        var cellStartPos = pos.cell.startParagraphPosition.value;
        var cellEndPos = pos.cell.endParagrapPosition.value;
        var result = [];
        if (tables)
            for (var tbl = void 0, tblIndex = 0; (tbl = tables[tblIndex])
                && cellStartPos <= tbl.getStartPosition() && tbl.getEndPosition() < cellEndPos; tblIndex++)
                if (tbl.nestedLevel == lowerLevelIndex)
                    result.push(tbl);
        return result;
    };
    TableCellWidthCalculator.prototype.cellWidthCore = function (pos) {
        var subDocument = this.boxIterator.subDocument;
        var paragraphs = subDocument.paragraphs;
        var minMax = new min_max_2.MinMaxNumber(0, 0);
        var innerTables = this.getInnerTables(pos);
        for (var _i = 0, innerTables_1 = innerTables; _i < innerTables_1.length; _i++) {
            var tbl = innerTables_1[_i];
            min_max_1.updateMinMaxBounds(minMax, this.getTableWidth(tbl, 0));
        }
        for (var _a = 0, _b = algorithms_1.IntervalAlgorithms.reflectIntervals(list_1.ListUtils.map(innerTables, function (t) { return t.interval; }), pos.cell.interval); _a < _b.length; _a++) {
            var interval = _b[_a];
            var firstParInd = subDocument.getParagraphIndexByPosition(interval.start);
            var intervalEnd = interval.end;
            for (var parInd = firstParInd, par = void 0; (par = paragraphs[parInd]) && (par.startLogPosition.value < intervalEnd); parInd++)
                min_max_1.updateMinMaxBounds(minMax, this.boxIterator.getParagraphBounds(parInd));
        }
        return minMax;
    };
    return TableCellWidthCalculator;
}());
exports.TableCellWidthCalculator = TableCellWidthCalculator;
