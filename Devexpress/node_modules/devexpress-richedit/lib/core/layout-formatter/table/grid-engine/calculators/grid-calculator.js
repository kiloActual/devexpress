"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var errors_1 = require("@devexpress/utils/lib/errors");
var list_1 = require("@devexpress/utils/lib/utils/list");
var table_units_1 = require("../../../../model/tables/secondary-structures/table-units");
var columns_1 = require("../columns");
var column_interval_1 = require("./column-interval");
var calculator_1 = require("./column-width-engine/calculator");
var GridCalculator = (function () {
    function GridCalculator(grid, cache, boxIterator, avaliableSpacing) {
        this.accuracy = 8;
        this.maxPercentWidth = 5000;
        this.grid = grid;
        this.cache = cache;
        this.boxIterator = boxIterator;
        this.maxTableWidth = avaliableSpacing;
        this.percentBaseWidth = Math.max(0, avaliableSpacing - this.currCache.indent.asNumberNoPercentType(unit_converter_1.UnitConverter.twipsToPixelsF));
        var intervals = calculator_1.Calculator.getIntervals(this.table);
        if (list_1.ListUtils.unsafeAnyOf(intervals, function (c) { return c.colSpan != 1; }))
            throw new Error(errors_1.Errors.InternalException);
        this.columns = list_1.ListUtils.map(intervals, this.makeInterval);
        this.applyCellsWidth(intervals);
        this.autofitTable();
    }
    Object.defineProperty(GridCalculator.prototype, "table", {
        get: function () { return this.grid.table; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GridCalculator.prototype, "currCache", {
        get: function () { return this.cache[this.table.index]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GridCalculator.prototype, "subDocument", {
        get: function () { return this.boxIterator.subDocument; },
        enumerable: true,
        configurable: true
    });
    GridCalculator.prototype.convertTableWidthUnitToTwips = function (value) {
        if (value.type == table_units_1.TableWidthUnitType.ModelUnits)
            return value.value;
        if (value.type == table_units_1.TableWidthUnitType.FiftiethsOfPercent)
            return value.value * unit_converter_1.UnitConverter.pixelsToTwipsF(this.percentBaseWidth) / this.maxPercentWidth;
        return 0;
    };
    GridCalculator.prototype.getFixedTableWidthInTwips = function () {
        if (this.currCache.preferredWidth.type == table_units_1.TableWidthUnitType.FiftiethsOfPercent)
            return this.convertTableWidthUnitToTwips(this.currCache.indent) + this.convertTableWidthUnitToTwips(this.currCache.preferredWidth);
        return this.convertTableWidthUnitToTwips(this.currCache.preferredWidth);
    };
    GridCalculator.prototype.calculateEstimatedTableWidth = function () {
        var count = this.columns.length;
        var result = 0;
        var totalPercentWidth = 0;
        var totalNoPercentWidth = 0;
        for (var i = 0; i < count; i++) {
            var column = this.columns[i];
            var contentWidth = Math.max(column.bounds.maxElement, column.bounds.minElement);
            if (column.isPercentBased && column.percentValue > 0) {
                result = Math.max(contentWidth * this.maxPercentWidth / column.percentValue, result);
                totalPercentWidth += column.percentValue;
            }
            else {
                totalNoPercentWidth += contentWidth;
            }
        }
        if (totalNoPercentWidth == 0 && totalPercentWidth > 0)
            return result;
        var restTotalPercent = this.maxPercentWidth - totalPercentWidth;
        if (restTotalPercent <= 0)
            return this.maxTableWidth;
        result = Math.max(totalNoPercentWidth * this.maxPercentWidth / restTotalPercent, result);
        return Math.min(result, this.maxTableWidth);
    };
    GridCalculator.prototype.getColumns = function () {
        return new columns_1.Columns(this.columns);
    };
    GridCalculator.prototype.autofitTable = function () {
        var estimatedTableWidth = this.currCache.isFixedTableWidth
            ? unit_converter_1.UnitConverter.twipsToPixelsF(this.getFixedTableWidthInTwips()) : this.calculateEstimatedTableWidth();
        var count = this.columns.length;
        var restEstimatedWidth = estimatedTableWidth;
        var totalMaxWidthNoSet = 0;
        var totalMinWidthNoSet = 0;
        var totalModelUnit = 0;
        var totalMinWidthModelUnit = 0;
        var totalPercent = 0;
        for (var i = 0; i < count; i++) {
            var column = this.columns[i];
            if (column.isPercentBased && column.percentValue > 0) {
                totalPercent += column.percentValue;
            }
            else if (!column.isPercentBased && column.preferredWidth > 0) {
                totalModelUnit += column.preferredWidth;
                totalMinWidthModelUnit += column.bounds.minElement;
            }
            else {
                totalMaxWidthNoSet += column.bounds.maxElement;
                totalMinWidthNoSet += column.bounds.minElement;
            }
        }
        restEstimatedWidth = this.autofitPercentWidthColumns(estimatedTableWidth, totalPercent, totalModelUnit != 0 || totalMinWidthNoSet != 0);
        restEstimatedWidth = this.autofitModelUnitWidthColumns(restEstimatedWidth, totalModelUnit, totalMinWidthModelUnit, totalMinWidthNoSet);
        this.autofitNoSetWidthColumns(restEstimatedWidth, totalMinWidthNoSet, totalMaxWidthNoSet);
        for (var i = 0; i < count; i++) {
            var column = this.columns[i];
            column.width = Math.max(column.width, column.bounds.minElement);
        }
        this.autofitTail(column_interval_1.GridColumnBase.totalWidth(this.columns), estimatedTableWidth);
    };
    GridCalculator.prototype.autofitNoSetWidthColumns = function (restEstimatedWidth, totalMinWidthNoSet, totalMaxWidthNoSet) {
        if (restEstimatedWidth > 0) {
            var overflow = totalMaxWidthNoSet - restEstimatedWidth;
            var restWidthForCompress = totalMaxWidthNoSet - totalMinWidthNoSet;
            if (overflow > 0 && restWidthForCompress > overflow)
                this.compressWidthProportionallyOfDifferenceMaxAndMinWidth(overflow, restWidthForCompress, function (column) { return column.isPercentBased || column.preferredWidth > 0; });
            else
                this.enlargeWidthProportionallyMaxWidth(totalMaxWidthNoSet, restEstimatedWidth, function (column) { return !column.isPercentBased && column.preferredWidth == 0; });
        }
    };
    GridCalculator.prototype.compressWidthProportionallyOfDifferenceMaxAndMinWidth = function (totalDelta, rest, condition) {
        for (var i = this.columns.length - 1; i >= 0 && totalDelta > 0 && rest > 0; i--) {
            var column = this.columns[i];
            if (condition(column))
                continue;
            var delta = (column.bounds.maxElement - column.bounds.minElement) * totalDelta / rest;
            column.width = column.bounds.maxElement - delta;
            rest -= column.bounds.maxElement - column.bounds.minElement;
            totalDelta -= delta;
        }
    };
    GridCalculator.prototype.autofitPercentWidthColumns = function (estimatedTableWidth, totalPercent, hasOtherTypeColumns) {
        if (totalPercent <= 0)
            return estimatedTableWidth;
        var restTotalPercent = Math.min(this.maxPercentWidth, totalPercent);
        var restEstimatedWidth = estimatedTableWidth;
        if (hasOtherTypeColumns)
            restTotalPercent = this.maxPercentWidth;
        list_1.ListUtils.forEach(this.columns, function (column) {
            var columnPercentValue = Math.min(restTotalPercent, column.percentValue);
            if (column.percentValue && column.percentValue > 0 && restTotalPercent > 0) {
                column.width = Math.max(restEstimatedWidth * columnPercentValue / restTotalPercent, column.bounds.minElement);
                restEstimatedWidth -= column.width;
                restTotalPercent -= columnPercentValue;
            }
        });
        return restEstimatedWidth;
    };
    GridCalculator.prototype.autofitModelUnitWidthColumns = function (restEstimatedWidth, totalModelUnit, totalMinWidthModelUnit, totalMinWidthNoSet) {
        if (totalModelUnit <= 0)
            return restEstimatedWidth;
        if (restEstimatedWidth > 0) {
            var overflow = totalModelUnit - restEstimatedWidth + totalMinWidthNoSet;
            var restWidthForCompress = totalModelUnit - totalMinWidthModelUnit;
            if (overflow > 0 && restWidthForCompress > overflow)
                this.compressWidthProportionallyOfDifferencePreferredWidthAndMinWidth(overflow, restWidthForCompress, true);
            else if (totalMinWidthNoSet != 0)
                this.applyPrefferedWidth();
            else
                this.enlargeWidthProportionallyMaxWidth(totalModelUnit, restEstimatedWidth, function (column) { return !column.isPercentBased && column.preferredWidth > 0; });
        }
        return restEstimatedWidth - totalModelUnit;
    };
    GridCalculator.prototype.applyPrefferedWidth = function () {
        list_1.ListUtils.forEach(this.columns, function (column) {
            if (!column.isPercentBased && column.preferredWidth > 0)
                column.width = column.preferredWidth;
        });
    };
    GridCalculator.prototype.compressWidthProportionallyOfDifferencePreferredWidthAndMinWidth = function (totalDelta, rest, ignorePercent) {
        if (ignorePercent === void 0) { ignorePercent = false; }
        for (var i = this.columns.length - 1; i >= 0 && totalDelta > 0 && rest > 0; i--) {
            var column = this.columns[i];
            if (column.preferredWidth > 0 && (!ignorePercent || !column.isPercentBased)) {
                var delta = (column.preferredWidth - column.bounds.minElement) * totalDelta / rest;
                column.width = Math.max(column.preferredWidth - delta, GridCalculator.minColumnWidth);
                rest -= column.preferredWidth - column.bounds.minElement;
                totalDelta -= delta;
            }
        }
    };
    GridCalculator.prototype.enlargeWidthProportionallyMaxWidth = function (totalMaxWidth, rest, condition) {
        list_1.ListUtils.forEach(this.columns, function (column) {
            if (condition(column) && totalMaxWidth > 0) {
                column.width = rest * column.bounds.maxElement / totalMaxWidth;
                rest -= column.width;
                totalMaxWidth -= column.bounds.maxElement;
            }
        });
    };
    GridCalculator.prototype.compressTableGrid = function (newTableWidth) {
        var startIndex = 0;
        var endIndex = this.columns.length - 1;
        var deltas = [];
        var deltasTotalWidth = 0;
        var initialTableWidth = 0;
        for (var i = startIndex; i <= endIndex; i++) {
            initialTableWidth += this.columns[i].width;
            var delta = Math.max(this.columns[i].width - this.columns[i].bounds.minElement, 0);
            deltas.push(delta);
            deltasTotalWidth += delta;
        }
        var deltaTableWidth = initialTableWidth - newTableWidth;
        if (deltasTotalWidth > deltaTableWidth)
            this.compressProportionallyWidthCore(deltas, deltasTotalWidth, deltaTableWidth);
        else {
            for (var i = startIndex; i <= endIndex; i++)
                this.columns[i].width -= deltas[i];
            this.changeColumnsProportionally(startIndex, endIndex, initialTableWidth - deltasTotalWidth, newTableWidth);
        }
    };
    GridCalculator.prototype.compressProportionallyWidthCore = function (items, totalItemsWidth, deltaTableWidth) {
        var colCount = this.columns.length;
        if (totalItemsWidth == 0) {
            var rest = deltaTableWidth;
            totalItemsWidth = colCount;
            for (var i = 0; i < colCount; i++) {
                var delta = (i != colCount - 1) ? deltaTableWidth / totalItemsWidth : rest;
                this.columns[i].width = Math.max(this.columns[i].width - delta, 0);
                rest -= delta;
            }
            return;
        }
        for (var i = 0; i < colCount; i++) {
            var delta = deltaTableWidth * items[i] / totalItemsWidth;
            this.columns[i].width -= delta;
            deltaTableWidth -= delta;
            totalItemsWidth -= items[i];
            if (totalItemsWidth == 0) {
                break;
            }
        }
    };
    GridCalculator.prototype.changeColumnsProportionally = function (startIndex, endIndex, initialWidth, newWidth) {
        var deltaTableWidth = Math.abs(newWidth - initialWidth);
        var rest = deltaTableWidth;
        for (var i = startIndex; i <= endIndex; i++) {
            var delta = (i != endIndex) ? this.columns[i].width * deltaTableWidth / initialWidth : rest;
            if (initialWidth > newWidth)
                this.columns[i].width = Math.max(GridCalculator.minColumnWidth, this.columns[i].width - delta);
            else
                this.columns[i].width += delta;
            rest -= delta;
        }
    };
    GridCalculator.minColumnWidth = unit_converter_1.UnitConverter.twipsToPixelsF(1);
    return GridCalculator;
}());
exports.GridCalculator = GridCalculator;
