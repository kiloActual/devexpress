"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BorderCreator = (function () {
    function BorderCreator() {
    }
    BorderCreator.setColumnHorizontalBorders = function (currTableColumnInfo, rowInfo, currColumnHorizontalBorders, isThisColumnFirstInTable) {
        var tblRows = currTableColumnInfo.tableRows;
        var columnInfoYOffset = currTableColumnInfo.y;
        for (var tblRowIndex = 0, tblRow = void 0; tblRow = tblRows[tblRowIndex]; tblRowIndex++) {
            var isThisRowFirstInColumn = tblRowIndex == 0;
            var isThisRowLastInColumn = tblRowIndex == tblRows.length - 1;
            var rowCellSpacing = rowInfo[tblRow.rowIndex].cellSpacing;
            var rowBrd = currColumnHorizontalBorders[tblRowIndex];
            if (rowCellSpacing > 0) {
                var endIndex = void 0;
                if (isThisRowFirstInColumn) {
                    rowBrd[0].yPosition = tblRow.y;
                    rowBrd[0].isOffsetFromTop = true;
                    rowBrd[1].yPosition = rowBrd[0].yPosition + rowBrd[0].maxWidth + rowCellSpacing * (isThisColumnFirstInTable ? 2 : 1) + rowBrd[1].maxWidth;
                    rowBrd[1].isOffsetFromTop = false;
                    endIndex = 3;
                }
                else {
                    rowBrd[0].yPosition = tblRow.y + rowCellSpacing + rowBrd[0].maxWidth;
                    rowBrd[0].isOffsetFromTop = false;
                    endIndex = 2;
                }
                if (isThisRowLastInColumn) {
                    rowBrd[endIndex].yPosition = tblRow.bottom - rowBrd[endIndex].maxWidth;
                    rowBrd[endIndex].isOffsetFromTop = true;
                    rowBrd[endIndex - 1].yPosition = rowBrd[endIndex].yPosition - rowCellSpacing * 2 - rowBrd[endIndex - 1].maxWidth;
                    rowBrd[endIndex - 1].isOffsetFromTop = true;
                }
                else {
                    rowBrd[endIndex - 1].yPosition = tblRow.bottom - rowCellSpacing - rowBrd[endIndex - 1].maxWidth;
                    rowBrd[endIndex - 1].isOffsetFromTop = true;
                }
            }
            else {
                rowBrd[0].yPosition = isThisRowFirstInColumn ? tblRow.y : tblRow.y - rowBrd[0].maxWidth / 2;
                rowBrd[0].isOffsetFromTop = true;
                if (isThisRowLastInColumn) {
                    rowBrd[1].yPosition = tblRow.bottom - rowBrd[1].maxWidth;
                    rowBrd[1].isOffsetFromTop = true;
                }
            }
            for (var _i = 0, rowBrd_1 = rowBrd; _i < rowBrd_1.length; _i++) {
                var brd = rowBrd_1[_i];
                brd.yPosition -= columnInfoYOffset;
            }
        }
    };
    BorderCreator.setColumnVerticalBorders = function (currTableColumnInfo, grid, rowInfo, isThisColumnFirstInTable, currColumnHorizontalBorders, newVerticalBorders, verticalBorders, considerSpacing) {
        var tblRows = currTableColumnInfo.tableRows;
        var rows = grid.table.rows;
        for (var tblRowIndex = 0, tblRow = void 0; tblRow = tblRows[tblRowIndex]; tblRowIndex++) {
            var isRowFirstInColumn = tblRowIndex == 0;
            var isRowLastInColumn = tblRowIndex == tblRows.length - 1;
            var horRowBorders = currColumnHorizontalBorders[tblRowIndex];
            var nextHorRowBorders = currColumnHorizontalBorders[tblRowIndex + 1];
            var lastHorBorderLineIndex = horRowBorders.length - 1;
            var rowBorders = [];
            newVerticalBorders.push(rowBorders);
            var rowIndex = tblRow.rowIndex;
            var cells = rows[rowIndex].cells;
            var rowCellSpacing = considerSpacing ? rowInfo[rowIndex].cellSpacing : 0;
            for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                var isFirstCellInRow = cellIndex == 0;
                var isLastCellInRow = cellIndex == cells.length - 1;
                var cellGridInfo = grid.tableCellInfos[rowIndex][cellIndex];
                var isThisCellMergedByTop = !isRowFirstInColumn && cellGridInfo.getStartRowIndex() != rowIndex;
                var isThisCellMergedByBottom = !isRowLastInColumn && cellGridInfo.getStartRowIndex() + cellGridInfo.getNumRowsInCell() - 1 != rowIndex;
                var cellBorders = [];
                rowBorders.push(cellBorders);
                for (var _i = 0, _a = verticalBorders[rowIndex][cellIndex]; _i < _a.length; _i++) {
                    var brd = _a[_i];
                    cellBorders.push(brd.clone());
                }
                var topCellBordersLine = void 0;
                var bottomCellBordersLine = void 0;
                if (rowCellSpacing > 0) {
                    topCellBordersLine = horRowBorders[isRowFirstInColumn ? 1 : 0];
                    bottomCellBordersLine = horRowBorders[lastHorBorderLineIndex - (isRowLastInColumn ? 1 : 0)];
                }
                else {
                    topCellBordersLine = horRowBorders[0];
                    bottomCellBordersLine = isRowLastInColumn ? horRowBorders[lastHorBorderLineIndex] : nextHorRowBorders[0];
                }
                var yPos = topCellBordersLine.yPosition + (topCellBordersLine.isOffsetFromTop ? topCellBordersLine.maxWidth : 0);
                var yEndPos = bottomCellBordersLine.yPosition - (bottomCellBordersLine.isOffsetFromTop ? 0 : bottomCellBordersLine.maxWidth);
                for (var vertCellBorderIndex = 0, vertCellBorder = void 0; vertCellBorder = cellBorders[vertCellBorderIndex]; vertCellBorderIndex++) {
                    var isFirstBorderInCell = vertCellBorderIndex == 0;
                    var isLastBorderInCell = vertCellBorderIndex == cellBorders.length - 1;
                    var isBoundBorder = isFirstCellInRow && isFirstBorderInCell || isLastBorderInCell && isLastCellInRow;
                    vertCellBorder.yPos = yPos;
                    if (isBoundBorder || isThisCellMergedByTop)
                        vertCellBorder.yPos -= rowCellSpacing * (isThisColumnFirstInTable && isRowFirstInColumn ? 2 : 1) + topCellBordersLine.maxWidth;
                    vertCellBorder.length = yEndPos - vertCellBorder.yPos;
                    if (isBoundBorder || isThisCellMergedByBottom)
                        vertCellBorder.length += rowCellSpacing * (isRowLastInColumn ? 2 : 1) + bottomCellBordersLine.maxWidth;
                }
            }
        }
    };
    return BorderCreator;
}());
exports.BorderCreator = BorderCreator;
