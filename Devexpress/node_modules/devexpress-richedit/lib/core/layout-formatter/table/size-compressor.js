"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var point_1 = require("@devexpress/utils/lib/geometry/point");
var rectangle_1 = require("@devexpress/utils/lib/geometry/rectangle");
var size_1 = require("@devexpress/utils/lib/geometry/size");
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var list_1 = require("@devexpress/utils/lib/utils/list");
var number_1 = require("@devexpress/utils/lib/utils/map/number");
var LayoutTableSizeCompressor = (function () {
    function LayoutTableSizeCompressor() {
    }
    LayoutTableSizeCompressor.tableRowContentCompress = function (row) {
        for (var _i = 0, _a = row.rowCells; _i < _a.length; _i++) {
            var cell = _a[_i];
            LayoutTableSizeCompressor.cellCompress(cell, cell.createRectangle());
        }
    };
    LayoutTableSizeCompressor.tableCompress = function (tableInfo, boundsRelativeColumn) {
        LayoutTableSizeCompressor.compress(tableInfo, boundsRelativeColumn, true, false);
        var boundsRelativeTable = tableInfo.clone().moveRectangle(-tableInfo.x, -tableInfo.y);
        for (var _i = 0, _a = tableInfo.tableRows; _i < _a.length; _i++) {
            var row = _a[_i];
            LayoutTableSizeCompressor.rowCompress(row, boundsRelativeTable, boundsRelativeColumn);
        }
        LayoutTableSizeCompressor.compressBorders(tableInfo.horizontalBorders, boundsRelativeTable, true);
        LayoutTableSizeCompressor.compressBorders(tableInfo.horizontalCursorBorders, boundsRelativeTable, true);
        LayoutTableSizeCompressor.compressBorders(tableInfo.verticalBorders, boundsRelativeTable, false);
        LayoutTableSizeCompressor.compressBorders(tableInfo.verticalCursorBorders, boundsRelativeTable, false);
    };
    LayoutTableSizeCompressor.compressBorders = function (borders, boundsRelativeTable, isHorizontal) {
        var newBorders = [];
        for (var _i = 0, borders_1 = borders; _i < borders_1.length; _i++) {
            var brd = borders_1[_i];
            if ((isHorizontal ? LayoutTableSizeCompressor.compressHorizontalBorder : LayoutTableSizeCompressor.compressVerticalBorder)(brd, boundsRelativeTable))
                newBorders.push(brd);
        }
        if (borders.length != newBorders.length) {
            borders.splice(0);
            list_1.ListUtils.addListOnTail(borders, newBorders);
        }
    };
    LayoutTableSizeCompressor.rowCompress = function (row, boundsRelativeTable, boundsRelativeColumn) {
        LayoutTableSizeCompressor.compress(row, boundsRelativeColumn, true, false);
        for (var _i = 0, _a = row.backgroundInfos; _i < _a.length; _i++) {
            var bcgInfo = _a[_i];
            LayoutTableSizeCompressor.compress(bcgInfo, boundsRelativeTable, true, false);
        }
        for (var _b = 0, _c = row.rowCells; _b < _c.length; _b++) {
            var cell = _c[_b];
            LayoutTableSizeCompressor.cellCompress(cell, boundsRelativeColumn);
        }
    };
    LayoutTableSizeCompressor.cellCompress = function (cell, boundsRelativeColumn) {
        LayoutTableSizeCompressor.compress(cell, boundsRelativeColumn, true, false);
        for (var _i = 0, _a = cell.layoutRows; _i < _a.length; _i++) {
            var layoutRow = _a[_i];
            LayoutTableSizeCompressor.compress(layoutRow, boundsRelativeColumn, true, true);
        }
        boundsRelativeColumn = cell;
        number_1.NumberMapUtils.forEach(cell.internalTables, function (tbl) { return LayoutTableSizeCompressor.tableCompress(tbl, boundsRelativeColumn); });
    };
    LayoutTableSizeCompressor.compress = function (obj, bounds, changeWhenNoIntersection, isLayoutRow) {
        var intersection = rectangle_1.Rectangle.getIntersection(obj, bounds);
        if (intersection) {
            if (isLayoutRow && obj.x < bounds.x)
                obj.applyXOffsetToBoxes(obj.x - bounds.x);
            obj.setGeomerty(intersection);
            return true;
        }
        if (changeWhenNoIntersection) {
            var deviation = new rectangle_1.RectangleDeviation(bounds, new point_1.Point(obj.x, obj.y)).calcDeviation().deviation;
            var devRight = deviation.get(rectangle_1.HitTestDeviation.Right);
            var devBottom = deviation.get(rectangle_1.HitTestDeviation.Bottom);
            var newObjX = devRight ? bounds.right : obj.x;
            var newObjY = devBottom ? bounds.bottom : obj.y;
            obj.setPosition(new point_1.Point(newObjX, newObjY));
            obj.setSize(new size_1.Size(devRight ? 0 : Math.min(obj.right, bounds.right) - newObjX, devBottom ? 0 : Math.min(obj.bottom, bounds.bottom) - newObjY));
        }
        return false;
    };
    LayoutTableSizeCompressor.compressVerticalBorder = function (border, bounds) {
        var horIntersection = algorithms_1.IntervalAlgorithms.getIntersection(new fixed_1.FixedInterval(border.xPos, border.borderInfo.width), new fixed_1.FixedInterval(bounds.x, bounds.width));
        if (horIntersection) {
            var vertIntersection = algorithms_1.IntervalAlgorithms.getIntersection(new fixed_1.FixedInterval(border.yPos, border.length), new fixed_1.FixedInterval(bounds.y, bounds.height));
            if (vertIntersection) {
                border.length = Math.min(border.yPos + border.length, bounds.bottom) - border.yPos;
                return true;
            }
            if (border.yPos > bounds.bottom) {
                border.yPos = bounds.bottom;
                border.length = 0;
            }
            return false;
        }
        border.length = Math.min(border.yPos + border.length, bounds.bottom) - border.yPos;
        if (border.xPos < bounds.x)
            return true;
        border.xPos = bounds.right;
        border.borderInfo.width = 0;
        return false;
    };
    LayoutTableSizeCompressor.compressHorizontalBorder = function (border, bounds) {
        var vertIntersection = algorithms_1.IntervalAlgorithms.getIntersection(new fixed_1.FixedInterval(border.yPos, border.borderInfo.width), new fixed_1.FixedInterval(bounds.y, bounds.height));
        if (vertIntersection) {
            var horIntersection = algorithms_1.IntervalAlgorithms.getIntersection(new fixed_1.FixedInterval(border.xPos, border.length), new fixed_1.FixedInterval(bounds.x, bounds.width));
            if (horIntersection) {
                border.length = Math.min(border.xPos + border.length, bounds.right) - border.xPos;
                return true;
            }
            if (border.xPos > bounds.right) {
                border.xPos = bounds.right;
                border.length = 0;
            }
            return false;
        }
        border.length = Math.min(border.xPos + border.length, bounds.right) - border.xPos;
        if (border.yPos < bounds.y)
            return true;
        border.yPos = bounds.bottom;
        border.borderInfo.width = 0;
        return false;
    };
    return LayoutTableSizeCompressor;
}());
exports.LayoutTableSizeCompressor = LayoutTableSizeCompressor;
