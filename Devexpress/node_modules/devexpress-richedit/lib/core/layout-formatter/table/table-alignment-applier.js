"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var list_1 = require("@devexpress/utils/lib/utils/list");
var number_1 = require("@devexpress/utils/lib/utils/map/number");
var layout_table_cell_info_1 = require("../../layout/table/layout-table-cell-info");
var table_cell_properties_merger_1 = require("../../model/tables/properties-mergers/table-cell-properties-merger");
var table_properties_merger_1 = require("../../model/tables/properties-mergers/table-properties-merger");
var table_row_properties_merger_1 = require("../../model/tables/properties-mergers/table-row-properties-merger");
var table_base_structures_1 = require("../../model/tables/secondary-structures/table-base-structures");
var TableAlignmentApplier = (function () {
    function TableAlignmentApplier() {
    }
    TableAlignmentApplier.getTableAlignment = function (table) {
        var firstRowAlignment = new table_row_properties_merger_1.TableRowPropertiesMergerHorizontalAlignment(table.rows[0].tablePropertiesException)
            .getProperty(table.rows[0].properties, table.style, table.rows[0].conditionalFormatting, null);
        var allRowAlignmentsEqual = firstRowAlignment != null && list_1.ListUtils.allOf(table.rows, function (row) {
            return new table_row_properties_merger_1.TableRowPropertiesMergerHorizontalAlignment(row.tablePropertiesException)
                .getProperty(row.properties, table.style, row.conditionalFormatting, null) == firstRowAlignment;
        });
        return allRowAlignmentsEqual ? firstRowAlignment : new table_properties_merger_1.TablePropertiesMergerHorizontalAlignment()
            .getProperty(table.properties, table.style, table_base_structures_1.ConditionalTableStyleFormatting.WholeTable, null);
    };
    TableAlignmentApplier.applyHorizontalAlignment = function (currTableColumnInfo, tableMaxWidth) {
        var table = currTableColumnInfo.logicInfo.grid.table;
        var tableAlignment = this.getTableAlignment(table);
        var leftBound = currTableColumnInfo.x;
        var rightBound = leftBound + tableMaxWidth;
        var avalSpace = rightBound - currTableColumnInfo.right;
        var offset;
        switch (tableAlignment != null ? tableAlignment : table_base_structures_1.TableRowAlignment.Left) {
            case table_base_structures_1.TableRowAlignment.Right:
                offset = avalSpace;
                break;
            case table_base_structures_1.TableRowAlignment.Center:
                offset = Math.floor(avalSpace / 2);
                break;
            case table_base_structures_1.TableRowAlignment.Left:
            default:
                offset = 0;
                break;
        }
        if (offset <= 0)
            return;
        TableAlignmentApplier.moveAllTable(currTableColumnInfo, function (rect) { return rect.x += offset; });
    };
    TableAlignmentApplier.applyCellsVerticalAlignment = function (defaultTableCellProps, grid, currTableColumnInfo, rowInfo) {
        var table = grid.table;
        var tableStyle = table.style;
        for (var _i = 0, _a = currTableColumnInfo.tableRows; _i < _a.length; _i++) {
            var tblRow = _a[_i];
            for (var _b = 0, _c = tblRow.rowCells; _b < _c.length; _b++) {
                var tblCell = _c[_b];
                if (!(tblCell.boundFlags.get(layout_table_cell_info_1.TableCellBoundFlags.StartOnThisColumn) && tblCell.boundFlags.get(layout_table_cell_info_1.TableCellBoundFlags.EndOnThisColumn)))
                    continue;
                var cellGridInfo = grid.tableCellGridInfos[tblRow.rowIndex][tblCell.cellGridIndex];
                var cellStartRowIndex = cellGridInfo.getStartRowIndex();
                var cellIndex = cellGridInfo.getCellIndex(0);
                var cell = table.rows[cellStartRowIndex].cells[cellIndex];
                var verticalAlignmentType = new table_cell_properties_merger_1.TableCellVerticalAlignmentMerger()
                    .getProperty(cell.properties, tableStyle, cell.conditionalFormatting, defaultTableCellProps);
                var topAndBottomMargins = rowInfo[cellStartRowIndex].topAndBottomMargins;
                var bottomBound = tblCell.bottom - topAndBottomMargins.bottomMargin -
                    rowInfo[tblRow.rowIndex].cellSpacing * (tblRow.rowIndex == table.rows.length - 1 ? 2 : 1);
                var numLayoutRows = tblCell.layoutRows.length;
                var lastInnerTable = tblCell.internalTables[numLayoutRows];
                var rowsBottomBound = lastInnerTable ?
                    lastInnerTable.bottom :
                    tblCell.layoutRows[numLayoutRows - 1].bottom;
                var avalSpace = bottomBound - rowsBottomBound;
                var offset;
                switch (verticalAlignmentType) {
                    case table_base_structures_1.TableCellVerticalAlignment.Bottom:
                        offset = avalSpace;
                        break;
                    case table_base_structures_1.TableCellVerticalAlignment.Center:
                        offset = Math.floor(avalSpace / 2);
                        break;
                    case table_base_structures_1.TableCellVerticalAlignment.Top:
                    default:
                        offset = 0;
                        break;
                }
                if (offset <= 0)
                    continue;
                for (var _d = 0, _e = tblCell.layoutRows; _d < _e.length; _d++) {
                    var layoutRow = _e[_d];
                    layoutRow.y += offset;
                }
                number_1.NumberMapUtils.forEach(tblCell.internalTables, function (table) {
                    return TableAlignmentApplier.moveAllTable(table, function (rect) { return rect.y += offset; });
                });
            }
        }
    };
    TableAlignmentApplier.moveAllTable = function (tblCol, mover) {
        mover(tblCol);
        for (var _i = 0, _a = tblCol.tableRows; _i < _a.length; _i++) {
            var tblRow = _a[_i];
            mover(tblRow);
            for (var _b = 0, _c = tblRow.rowCells; _b < _c.length; _b++) {
                var tblCell = _c[_b];
                mover(tblCell);
                number_1.NumberMapUtils.forEach(tblCell.internalTables, function (table) {
                    return TableAlignmentApplier.moveAllTable(table, mover);
                });
                for (var _d = 0, _e = tblCell.layoutRows; _d < _e.length; _d++) {
                    var layoutRow = _e[_d];
                    mover(layoutRow);
                }
            }
        }
    };
    return TableAlignmentApplier;
}());
exports.TableAlignmentApplier = TableAlignmentApplier;
