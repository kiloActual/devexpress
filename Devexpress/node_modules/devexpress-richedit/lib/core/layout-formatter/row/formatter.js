"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var errors_1 = require("@devexpress/utils/lib/errors");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var layout_box_1 = require("../../layout/main-structures/layout-boxes/layout-box");
var layout_row_1 = require("../../layout/main-structures/layout-row");
var piece_table_numbering_list_counters_manager_1 = require("../../model/numbering-lists/piece-table-numbering-list-counters-manager");
var log_1 = require("../../rich-utils/debug/logger/base-logger/log");
var log_obj_to_str_1 = require("../../rich-utils/debug/logger/base-logger/log-obj-to-str");
var log_source_1 = require("../../rich-utils/debug/logger/base-logger/log-source");
var box_iterator_1 = require("../box/box-iterator");
var box_wrap_1 = require("../box/box-wrap");
var result_1 = require("./result");
var row_sizes_manager_1 = require("./size-engine/row-sizes-manager");
var states_1 = require("./states");
var tab_info_1 = require("./tab-info");
var word_holder_1 = require("./word-holder");
var TextRowFormatterState;
(function (TextRowFormatterState) {
    TextRowFormatterState[TextRowFormatterState["None"] = 0] = "None";
    TextRowFormatterState[TextRowFormatterState["Base"] = 1] = "Base";
    TextRowFormatterState[TextRowFormatterState["EndedWithPageBreak"] = 2] = "EndedWithPageBreak";
    TextRowFormatterState[TextRowFormatterState["EndedWithParagraphMark"] = 3] = "EndedWithParagraphMark";
})(TextRowFormatterState = exports.TextRowFormatterState || (exports.TextRowFormatterState = {}));
var RowFormatter = (function () {
    function RowFormatter(formatterManager, subDocumentId) {
        this.rowFormatting = true;
        this.manager = formatterManager;
        this.iterator = new box_iterator_1.BoxIterator(this.manager, subDocumentId);
        this.numberingListCountersManager = new piece_table_numbering_list_counters_manager_1.SubDocumentNumberingListCountersManager(this.subDocument);
        this.stateMap = {};
        this.stateMap[TextRowFormatterState.Base] = new states_1.RowBaseFormatterState(this);
        this.stateMap[TextRowFormatterState.EndedWithPageBreak] = new states_1.RowEndedWithPageBreakState(this);
        this.stateMap[TextRowFormatterState.EndedWithParagraphMark] = new states_1.RowEndedWithParagraphMarkFormatterState(this);
        if (RowFormatter.addBoxFunctionMap)
            return;
        RowFormatter.addBoxFunctionMap = {};
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.Space] = function () { this.currentState.addSpaceBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.NonBreakingSpace] = function () { this.currentState.addTextBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.Dash] = function () { this.currentState.addPictureBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.Text] = function () { this.currentState.addTextBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.Picture] = function () { this.currentState.addPictureBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.ParagraphMark] = function () { this.currentState.addParagraphBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.LineBreak] = function () { this.currentState.addLineBreakBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.SectionMark] = function () { this.currentState.addSectionBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.PageBreak] = function () { this.currentState.addPageBreakBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.ColumnBreak] = function () { this.currentState.addColumnBreakBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.TabSpace] = function () { this.currentState.addTabulationBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.FieldCodeStart] = function () { this.currentState.addTextBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.FieldCodeEnd] = function () { this.currentState.addTextBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.LayoutDependent] = function () { this.currentState.addTextBox(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.AnchorTextBox] = function () { this.currentState.addAnchorObject(); };
        RowFormatter.addBoxFunctionMap[layout_box_1.LayoutBoxType.AnchorPicture] = function () { this.currentState.addAnchorObject(); };
    }
    Object.defineProperty(RowFormatter.prototype, "subDocument", {
        get: function () { return this.iterator.subDocument; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(RowFormatter.prototype, "row", {
        get: function () { return this.result.row; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RowFormatter.prototype, "paragraph", {
        get: function () { return this.subDocument.paragraphs[this.result.paragraphIndex]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RowFormatter.prototype, "paragraphProps", {
        get: function () { return this.paragraph.getParagraphMergedProperties(); },
        enumerable: true,
        configurable: true
    });
    RowFormatter.prototype.getNextBoxWrapInfo = function () { return this.iterator.getWrap(false); };
    RowFormatter.prototype.setPosition = function (position, forceResetBoxInfos, checkStartTable) { this.iterator.setPosition(position, forceResetBoxInfos, checkStartTable); };
    RowFormatter.prototype.getPosition = function () { return this.iterator.getPosition(); };
    RowFormatter.prototype.documentStart = function () { this.iterator.documentStart(); };
    RowFormatter.prototype.formatRow = function (minY, paragraphHorizontalBounds, rowSpacingBeforeApplier) {
        this.paragraphHorizontalBounds = paragraphHorizontalBounds;
        this.initResult(minY);
        log_1.Log.print(log_source_1.LogSource.RowFormatter, "formatRow", "paragraphHorizontalBounds: " + log_obj_to_str_1.LogObjToStr.fixedInterval(paragraphHorizontalBounds) + ", firstBoxOffset: " + this.currBox.rowOffset);
        var prevRow = this.manager.activeFormatter.lastRowInfo.row;
        var isFirstRowInParagraph = !prevRow || prevRow.flags.get(layout_row_1.LayoutRowStateFlags.ParagraphEnd) ||
            this.manager.activeFormatter.lastRowInfo.paragraphIndex != this.currWrapInfo.paragraphIndex;
        var rowParagraphLeftIndent = isFirstRowInParagraph ?
            unit_converter_1.UnitConverter.twipsToPixelsF(this.paragraphProps.getLeftIndentForFirstRow()) :
            unit_converter_1.UnitConverter.twipsToPixelsF(this.paragraphProps.getLeftIndentForOtherRow());
        var rowContentHorizontalBounds = fixed_1.FixedInterval.fromPositions(paragraphHorizontalBounds.start + rowParagraphLeftIndent, paragraphHorizontalBounds.end - unit_converter_1.UnitConverter.twipsToPixelsF(this.paragraphProps.rightIndent));
        this.rowSizesManager = new row_sizes_manager_1.RowSizesManager(this, rowContentHorizontalBounds, minY, rowSpacingBeforeApplier, this.manager.activeFormatter.layoutRowBoundsCalculator.getRectangleBounds(this.manager), isFirstRowInParagraph);
        this.tabInfo = new tab_info_1.RowTabInfo(this, paragraphHorizontalBounds.start);
        this.wordHolder = new word_holder_1.WordHolderInfo(this);
        this.rowFormatting = true;
        var cycleCounter = 0;
        while (this.rowFormatting) {
            this.setState(TextRowFormatterState.Base);
            this.innerFormatRow();
            if (++cycleCounter > 10000)
                throw new Error(errors_1.Errors.InternalException);
        }
    };
    RowFormatter.prototype.innerFormatRow = function () {
        while (this.rowFormatting && this.currBox) {
            var oldWrapTablPos = this.currWrapInfo.tablePosition;
            RowFormatter.addBoxFunctionMap[this.currBox.getType()].call(this);
            if (this.currWrapInfo) {
                if (!oldWrapTablPos && this.currWrapInfo.tablePosition) {
                    this.finishRow();
                    break;
                }
                if (oldWrapTablPos && (!this.currWrapInfo.tablePosition || !this.currWrapInfo.equalsTablePositions(oldWrapTablPos))) {
                    this.wordHolder.pushBoxes();
                    this.row.flags.set(layout_row_1.LayoutRowStateFlags.CellTableEnd, true);
                    this.finishRow();
                    break;
                }
            }
            else {
                if (oldWrapTablPos)
                    this.row.flags.set(layout_row_1.LayoutRowStateFlags.CellTableEnd, true);
            }
        }
        if (!this.currBox) {
            if (!this.iterator.allBoxesGiven()) {
                this.iterator.setPosition(this.startPos, false, false);
                this.result.flags.set(result_1.RowFormatterResultFlag.NotEnoughChunks, true);
                this.rowFormatting = false;
                return;
            }
            this.row.flags.set(layout_row_1.LayoutRowStateFlags.DocumentEnd, true);
        }
        this.rowFormatting = !this.rowSizesManager.finishRow();
    };
    RowFormatter.prototype.finishRow = function () {
        if (!this.result.row.boxes.length && !this.result.newAnchoredObjects.length)
            throw new Error(errors_1.Errors.InternalException);
        this.rowFormatting = false;
    };
    RowFormatter.prototype.setState = function (state) {
        this.currentState = this.stateMap[state];
    };
    RowFormatter.prototype.addAnchorObject = function () {
        var ancBox = this.currBox;
        this.setBoxInfo(true);
        if (this.manager.activeFormatter.layoutPosition.page.anchoredObjectHolder.isObjectExist(ancBox))
            return;
        if (ancBox.getType() == layout_box_1.LayoutBoxType.AnchorTextBox) {
            var calculator = this.manager.anchoredObjectsManager.textBoxContextSizeCalculators[ancBox.objectId];
            calculator.calculateSize(this.manager.boundsCalculator);
            ancBox.setContentSize(calculator.layoutSize);
        }
        this.result.newAnchoredObjects.push(ancBox);
    };
    RowFormatter.prototype.initResult = function (minY) {
        this.result = new result_1.RowFormatterResult(this, minY);
        this.setBoxInfo(false);
        if (this.currBox)
            this.startPos = this.currBox.rowOffset;
        this.result.paragraphIndex = this.currWrapInfo.paragraphIndex;
        this.result.sectionIndex = this.currWrapInfo.sectionIndex;
    };
    RowFormatter.prototype.setBoxInfo = function (getNextWrap) {
        var wrap = this.iterator.getWrap(getNextWrap);
        if (!wrap) {
            this.currBox = null;
            this.currWrapInfo = null;
            return;
        }
        this.currBox = wrap.box.getType() == layout_box_1.LayoutBoxType.TabSpace ? wrap.box : wrap.box.clone();
        this.currWrapInfo = wrap.info;
        if (this.currBox.getType() == layout_box_1.LayoutBoxType.LayoutDependent) {
            this.currBox.calculateText(this.manager);
            layout_box_1.LayoutBox.initializeWithMeasurer([new box_wrap_1.BoxWrap(this.currBox, null)], this.manager.measurer, false);
        }
    };
    return RowFormatter;
}());
exports.RowFormatter = RowFormatter;
