"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("@devexpress/utils/lib/errors");
var list_1 = require("@devexpress/utils/lib/utils/list");
var layout_box_1 = require("../../../layout/main-structures/layout-boxes/layout-box");
var paragraph_properties_1 = require("../../../model/paragraph/paragraph-properties");
var BoxAligner = (function () {
    function BoxAligner() {
    }
    BoxAligner.findLastVisibleBoxIndex = function (boxes, startIndex, endIndex) {
        return list_1.ListUtils.reverseIndexBy(boxes, function (box) { return box.isVisibleForRowAlign(); }, startIndex, endIndex);
    };
    BoxAligner.align = function (row, alignment, endXPosition, fromBoxIndex, dontJustifyLinesEndingInSoftLineBreak) {
        switch (alignment) {
            case paragraph_properties_1.ParagraphAlignment.Right:
                BoxAligner.alignRightCenter(BoxAligner.getBoxes(row, fromBoxIndex), endXPosition, 1);
                break;
            case paragraph_properties_1.ParagraphAlignment.Center:
                BoxAligner.alignRightCenter(BoxAligner.getBoxes(row, fromBoxIndex), endXPosition, 2);
                break;
            case paragraph_properties_1.ParagraphAlignment.Justify:
            case paragraph_properties_1.ParagraphAlignment.JustifyHigh:
            case paragraph_properties_1.ParagraphAlignment.JustifyLow:
            case paragraph_properties_1.ParagraphAlignment.JustifyMedium:
            case paragraph_properties_1.ParagraphAlignment.Distribute:
            case paragraph_properties_1.ParagraphAlignment.ThaiDistribute:
                BoxAligner.alignJustify(BoxAligner.getBoxes(row, fromBoxIndex), endXPosition, dontJustifyLinesEndingInSoftLineBreak);
                break;
            case paragraph_properties_1.ParagraphAlignment.Left:
                break;
            default:
                throw new Error(errors_1.Errors.InternalException);
        }
    };
    BoxAligner.getBoxes = function (row, fromBoxIndex) {
        if (fromBoxIndex)
            return row.boxes.slice(fromBoxIndex);
        if (!row.numberingListBox)
            return row.boxes;
        var boxes = row.boxes.slice();
        if (row.numberingListBox.separatorBox)
            boxes.unshift(row.numberingListBox.separatorBox);
        boxes.unshift(row.numberingListBox.textBox);
        return boxes;
    };
    BoxAligner.alignRightCenter = function (boxes, endXPosition, divider) {
        var avaliableWidth = BoxAligner.calculateFreeSpace(boxes, BoxAligner.findLastVisibleBoxIndex(boxes), endXPosition);
        if (divider > 1)
            avaliableWidth = Math.floor(avaliableWidth / divider);
        if (avaliableWidth > 0)
            for (var _i = 0, boxes_1 = boxes; _i < boxes_1.length; _i++) {
                var box = boxes_1[_i];
                box.x += avaliableWidth;
            }
    };
    BoxAligner.alignJustify = function (boxes, endXPosition, dontJustifyLinesEndingInSoftLineBreak) {
        switch (list_1.ListUtils.last(boxes).getType()) {
            case layout_box_1.LayoutBoxType.ParagraphMark:
            case layout_box_1.LayoutBoxType.ColumnBreak:
            case layout_box_1.LayoutBoxType.PageBreak:
            case layout_box_1.LayoutBoxType.SectionMark:
                return;
            case layout_box_1.LayoutBoxType.LineBreak:
                if (dontJustifyLinesEndingInSoftLineBreak)
                    return;
        }
        var prevBox = boxes[boxes.length - 2];
        var lastVisibleBoxIndex = BoxAligner.findLastVisibleBoxIndex(boxes);
        if (prevBox && (prevBox.getType() == layout_box_1.LayoutBoxType.ParagraphMark || prevBox.getType() == layout_box_1.LayoutBoxType.PageBreak) ||
            prevBox && prevBox.getType() == layout_box_1.LayoutBoxType.PageBreak ||
            lastVisibleBoxIndex < 0)
            return;
        var firstNonSpaceBoxIndex = BoxAligner.firstNonSpaceBoxIndex(boxes);
        if (firstNonSpaceBoxIndex < 0)
            return;
        var totalSpaceWidth = 0;
        for (var i = firstNonSpaceBoxIndex + 1; i <= lastVisibleBoxIndex; i++) {
            var box = boxes[i];
            var boxType = box.getType();
            if (boxType == layout_box_1.LayoutBoxType.Space || boxType == layout_box_1.LayoutBoxType.NonBreakingSpace)
                totalSpaceWidth += box.width;
        }
        var freeSpace = BoxAligner.calculateFreeSpace(boxes, lastVisibleBoxIndex, endXPosition);
        if (totalSpaceWidth == 0 || freeSpace <= 0)
            return;
        var leftX = boxes[firstNonSpaceBoxIndex].right;
        for (var i = firstNonSpaceBoxIndex + 1; i <= lastVisibleBoxIndex; i++) {
            var box = boxes[i];
            box.x = leftX;
            var boxType = box.getType();
            if (boxType == layout_box_1.LayoutBoxType.Space || boxType == layout_box_1.LayoutBoxType.NonBreakingSpace)
                box.width += (freeSpace * box.width) / totalSpaceWidth;
            leftX += box.width;
        }
        for (var i = lastVisibleBoxIndex + 1, box = void 0; box = boxes[i]; i++) {
            box.x = leftX;
            leftX += box.width;
        }
    };
    BoxAligner.calculateFreeSpace = function (boxes, lastVisibleBoxIndex, rightBoundsPosition) {
        return rightBoundsPosition - (lastVisibleBoxIndex >= 0 ? boxes[lastVisibleBoxIndex].right : boxes[0].x);
    };
    BoxAligner.firstNonSpaceBoxIndex = function (boxes) {
        var lastNonSpace = -1;
        for (var i = boxes.length - 1; i >= 0; i--)
            switch (boxes[i].getType()) {
                case layout_box_1.LayoutBoxType.TabSpace: return lastNonSpace;
                case layout_box_1.LayoutBoxType.Space:
                case layout_box_1.LayoutBoxType.NonBreakingSpace:
                    break;
                default: lastNonSpace = i;
            }
        return lastNonSpace;
    };
    return BoxAligner;
}());
exports.BoxAligner = BoxAligner;
