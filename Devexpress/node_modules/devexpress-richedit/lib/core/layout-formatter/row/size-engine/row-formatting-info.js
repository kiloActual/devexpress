"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var rectangle_1 = require("@devexpress/utils/lib/geometry/rectangle");
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var list_1 = require("@devexpress/utils/lib/utils/list");
var log_1 = require("../../../rich-utils/debug/logger/base-logger/log");
var log_obj_to_str_1 = require("../../../rich-utils/debug/logger/base-logger/log-obj-to-str");
var log_source_1 = require("../../../rich-utils/debug/logger/base-logger/log-source");
var RowIntervalInfo = (function (_super) {
    tslib_1.__extends(RowIntervalInfo, _super);
    function RowIntervalInfo(start, length, avaliableWidth) {
        if (avaliableWidth === void 0) { avaliableWidth = length; }
        var _this = _super.call(this, start, length) || this;
        _this.avaliableWidth = avaliableWidth;
        return _this;
    }
    Object.defineProperty(RowIntervalInfo.prototype, "busyWidth", {
        get: function () {
            return this.length - this.avaliableWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RowIntervalInfo.prototype, "startOfFreeSpace", {
        get: function () {
            return this.start + this.busyWidth;
        },
        enumerable: true,
        configurable: true
    });
    RowIntervalInfo.prototype.isConsiderBoxes = function () {
        return this.avaliableWidth != this.length;
    };
    return RowIntervalInfo;
}(fixed_1.FixedInterval));
exports.RowIntervalInfo = RowIntervalInfo;
var RowFormattingInfo = (function () {
    function RowFormattingInfo(minY, height, outerHorizontalRowContentBounds, boundsOfAnchoredOblectsOnThisColumn) {
        this.intervals = [];
        this.currIndex = 0;
        this.minY = minY;
        this.height = Math.max(1, height);
        this.outerHorizontalRowContentBounds = outerHorizontalRowContentBounds;
        this.boundsOfAnchoredOblectsOnThisColumn = boundsOfAnchoredOblectsOnThisColumn;
        this.lastNonEmptyIntervalIndex = 0;
    }
    Object.defineProperty(RowFormattingInfo.prototype, "isFloatingIntersectRow", {
        get: function () { return !!this.intersectsObjects.length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RowFormattingInfo.prototype, "lastNonEmptyInterval", {
        get: function () { return this.intervals[this.lastNonEmptyIntervalIndex]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RowFormattingInfo.prototype, "currInterval", {
        get: function () {
            return this.intervals[this.currIndex];
        },
        enumerable: true,
        configurable: true
    });
    RowFormattingInfo.prototype.indexOfFreeInterval = function (width) {
        return list_1.ListUtils.indexBy(this.intervals, function (curr) { return curr.avaliableWidth >= width; }, this.currIndex);
    };
    RowFormattingInfo.prototype.indexOfIntervalContainsPositon = function (pos) {
        var ind = list_1.ListUtils.indexBy(this.intervals, function (curr) { return curr.start > pos || pos < curr.end; }, this.currIndex + 1);
        return ind < 0 ? this.intervals.length - 1 : ind;
    };
    RowFormattingInfo.prototype.calculate = function () {
        this.setIntersectObjects();
        var busyIntervals = algorithms_1.IntervalAlgorithms.getMergedIntervals(list_1.ListUtils.map(this.intersectsObjects, function (objBnds) { return new fixed_1.FixedInterval(objBnds.x, objBnds.width); }), true);
        var freeIntervals = algorithms_1.IntervalAlgorithms.reflectIntervals(busyIntervals, this.outerHorizontalRowContentBounds);
        if (freeIntervals.length) {
            this.intervals = list_1.ListUtils.map(freeIntervals, function (curr) { return new RowIntervalInfo(curr.start, curr.length); });
            return;
        }
        this.resetMinY(list_1.ListUtils.min);
        log_1.Log.print(log_source_1.LogSource.RowFormatter, "RowFormattingInfo.calculate ", "minY:" + this.minY + ", height:" + this.height + ", currIndex: " + this.currIndex + " intervals:\n" + log_1.Log.join("\n", list_1.ListUtils.map(this.intervals, function (curr) { return log_obj_to_str_1.LogObjToStr.fixedInterval(curr); })));
    };
    RowFormattingInfo.prototype.canIncrementHeightTo = function (newHeight) {
        var _this = this;
        var contentBounds = list_1.ListUtils.map(this.intervals, function (c) { return new rectangle_1.Rectangle(c.start, _this.minY, c.busyWidth, newHeight); });
        return !list_1.ListUtils.unsafeAnyOf(this.boundsOfAnchoredOblectsOnThisColumn, function (ancBound) {
            return list_1.ListUtils.unsafeAnyOf(contentBounds, function (contentBound) { return rectangle_1.Rectangle.getNonCollapsedIntersection(contentBound, ancBound); });
        });
    };
    RowFormattingInfo.prototype.findNextYPos = function () {
        this.resetMinY(list_1.ListUtils.min);
    };
    RowFormattingInfo.prototype.findNextYPosWhatNoIntersectFloatingObjects = function () {
        while (this.isFloatingIntersectRow)
            this.resetMinY(list_1.ListUtils.max);
        this.currIndex = 0;
    };
    RowFormattingInfo.prototype.setIntersectObjects = function () {
        var initRect = new rectangle_1.Rectangle(this.outerHorizontalRowContentBounds.start, this.minY, this.outerHorizontalRowContentBounds.length, this.height);
        this.intersectsObjects = list_1.ListUtils.reducedMap(this.boundsOfAnchoredOblectsOnThisColumn, function (objBnds) {
            return rectangle_1.Rectangle.getNonCollapsedIntersection(initRect, objBnds) ? objBnds : null;
        });
    };
    RowFormattingInfo.prototype.resetMinY = function (getVal) {
        this.minY = getVal(this.intersectsObjects, function (a) { return a.bottom; }).bottom;
        this.calculate();
    };
    return RowFormattingInfo;
}());
exports.RowFormattingInfo = RowFormattingInfo;
