"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var errors_1 = require("@devexpress/utils/lib/errors");
var polygon_1 = require("@devexpress/utils/lib/geometry/polygon");
var rectangle_1 = require("@devexpress/utils/lib/geometry/rectangle");
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var list_1 = require("@devexpress/utils/lib/utils/list");
var number_1 = require("@devexpress/utils/lib/utils/map/number");
var layout_anchored_object_box_1 = require("../../layout/main-structures/layout-boxes/layout-anchored-object-box");
var enums_1 = require("../../model/floating-objects/enums");
var RectangleRowBoundsCalculatorInfo = (function (_super) {
    tslib_1.__extends(RectangleRowBoundsCalculatorInfo, _super);
    function RectangleRowBoundsCalculatorInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RectangleRowBoundsCalculatorInfo;
}(rectangle_1.Rectangle));
exports.RectangleRowBoundsCalculatorInfo = RectangleRowBoundsCalculatorInfo;
var LayoutRowBoundsCalculator = (function () {
    function LayoutRowBoundsCalculator() {
    }
    LayoutRowBoundsCalculator.prototype.getRectangleBounds = function (manager) {
        var _this = this;
        var tableFormatter = manager.activeFormatter.tableFormatter;
        if (!tableFormatter)
            return this.rectangleBounds;
        var posInfo = manager.layout.anchorObjectsPositionInfo;
        var tableEndPos = tableFormatter.tableInfo.table.getEndPosition();
        return list_1.ListUtils.reducedMap(this.rectangleBounds, function (b, i) {
            return posInfo.getPosition(_this.ancObjectsId[i]) < tableEndPos ? b : null;
        });
    };
    LayoutRowBoundsCalculator.prototype.addTableInTextObject = function (obj, horizOuterBounds) {
        this.addAnchoredObject(obj, horizOuterBounds);
    };
    LayoutRowBoundsCalculator.prototype.resetByColumn = function (objects, horizOuterBounds, ignoreFo) {
        var _this = this;
        this.rectangleBounds = [];
        this.ancObjectsId = [];
        if (!ignoreFo) {
            var inTextObjects = number_1.NumberMapUtils.reducedMap(objects, function (obj) { return obj.levelType == layout_anchored_object_box_1.AnchoredObjectLevelType.InText ? obj : null; });
            number_1.NumberMapUtils.forEach(inTextObjects, function (obj) { return _this.addAnchoredObject(obj, horizOuterBounds); });
        }
    };
    LayoutRowBoundsCalculator.prototype.removeAnchorObjectId = function (id) {
        this.ancObjectsId.splice(id, 1);
        this.rectangleBounds.splice(id, 1);
    };
    LayoutRowBoundsCalculator.prototype.addAnchoredObject = function (obj, horizOuterBounds) {
        var anchorInfo = obj.anchorInfo;
        var extBounds = obj.getExtendedBounds();
        var center = extBounds.center;
        var polygon = polygon_1.Polygon.fromRectangle(extBounds);
        polygon.rotateAround(center, obj.rotationInRadians, false, true);
        var bounds = polygon.bounds;
        switch (anchorInfo.wrapType) {
            case enums_1.AnchorObjectTextWrapType.Tight:
            case enums_1.AnchorObjectTextWrapType.Through:
            case enums_1.AnchorObjectTextWrapType.Square: {
                bounds.applyOffsetsOutside(anchorInfo.getDistanceMargins());
                LayoutRowBoundsCalculator.applySquareWrapSide(anchorInfo.wrapSide, bounds, horizOuterBounds);
                this.rectangleBounds.push(bounds);
                break;
            }
            case enums_1.AnchorObjectTextWrapType.TopAndBottom: {
                bounds.applyOffsetsOutside(anchorInfo.getDistanceMargins());
                bounds.x = horizOuterBounds.start;
                bounds.width = horizOuterBounds.length;
                this.rectangleBounds.push(bounds);
                break;
            }
            default: throw new Error(errors_1.Errors.InternalException);
        }
        this.ancObjectsId.push(obj.objectId);
    };
    LayoutRowBoundsCalculator.applySquareWrapSide = function (wrapSide, bounds, horizOuterBounds) {
        var intersection = algorithms_1.IntervalAlgorithms.getIntersectionNonNullLength(new fixed_1.FixedInterval(bounds.x, bounds.width), horizOuterBounds);
        if (!intersection)
            return;
        var getBounds;
        switch (wrapSide) {
            case enums_1.AnchorObjectTextWrapSide.Right:
                getBounds = LayoutRowBoundsCalculator.getRightBounds;
                break;
            case enums_1.AnchorObjectTextWrapSide.Left:
                getBounds = LayoutRowBoundsCalculator.getLeftBounds;
                break;
            case enums_1.AnchorObjectTextWrapSide.Largest:
                getBounds = intersection.start - horizOuterBounds.start >= horizOuterBounds.end - intersection.end ?
                    LayoutRowBoundsCalculator.getLeftBounds :
                    LayoutRowBoundsCalculator.getRightBounds;
                break;
            case enums_1.AnchorObjectTextWrapSide.Both:
                getBounds = function (b) { return b; };
                break;
        }
        var horB = getBounds(intersection, horizOuterBounds);
        bounds.x = horB.start;
        bounds.width = horB.length;
    };
    LayoutRowBoundsCalculator.getLeftBounds = function (intersection, horizOuterBounds) {
        return fixed_1.FixedInterval.fromPositions(intersection.start, horizOuterBounds.end);
    };
    LayoutRowBoundsCalculator.getRightBounds = function (intersection, horizOuterBounds) {
        return fixed_1.FixedInterval.fromPositions(horizOuterBounds.start, intersection.end);
    };
    return LayoutRowBoundsCalculator;
}());
exports.LayoutRowBoundsCalculator = LayoutRowBoundsCalculator;
