"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var errors_1 = require("@devexpress/utils/lib/errors");
var document_layout_details_level_1 = require("../../../layout/document-layout-details-level");
var enums_1 = require("../../../model/floating-objects/enums");
var base_calculator_1 = require("./base-calculator");
var AnchorObjectVerticalPositionCalculator = (function (_super) {
    tslib_1.__extends(AnchorObjectVerticalPositionCalculator, _super);
    function AnchorObjectVerticalPositionCalculator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnchorObjectVerticalPositionCalculator.prototype.calculate = function (obj) {
        this.init(obj);
        this.obj.y = this.getY();
        this.correctInTextAnchorPosition();
    };
    Object.defineProperty(AnchorObjectVerticalPositionCalculator.prototype, "topCellMargin", {
        get: function () {
            return this.manager.activeFormatter.tableFormatter.actualFormatter.tableInfo.currRowInfo.topAndBottomMargins.topMargin;
        },
        enumerable: true,
        configurable: true
    });
    AnchorObjectVerticalPositionCalculator.prototype.getY = function () {
        if (this.anchorInfo.isUsedVerticalAbsolutePosition())
            return unit_converter_1.UnitConverter.twipsToPixelsF(this.anchorInfo.offset.y) + this.absolute();
        if (this.anchorInfo.isUsedVerticalAlignment())
            return this.alignment();
        if (this.anchorInfo.isUsedVerticalRelativePosition())
            return this.relative();
        throw new Error(errors_1.Errors.InternalException);
    };
    AnchorObjectVerticalPositionCalculator.prototype.relativeColumnPos = function () {
        return this.lp.pageArea.y + this.lp.column.y;
    };
    AnchorObjectVerticalPositionCalculator.prototype.correctInTextAnchorPosition = function () {
        if (!this.isRelativeCell || !this.obj.isInText())
            return;
        var topBounds = this.relativeColumnPos() + this.lp.row.tableCellInfo.y;
        this.obj.y = Math.max(this.obj.y, topBounds);
    };
    AnchorObjectVerticalPositionCalculator.prototype.getRowWhatStartParagraphY = function () {
        var paragraphStartPosition = this.lp.pageArea.subDocument
            .paragraphs[this.manager.activeFormatter.rowFormatter.result.paragraphIndex].startLogPosition.value;
        var rows = this.lp.column.rows;
        var parRelativeColumnOffset = paragraphStartPosition - this.lp.getLogPosition(document_layout_details_level_1.DocumentLayoutDetailsLevel.Column);
        var rowInd = this.lp.rowIndex;
        var rowWhatStartParagraph = rowInd >= rows.length ? this.lp.row : rows[rowInd];
        for (var row = void 0, rowIndex = rowInd - 1; (row = rows[rowIndex]) &&
            row.columnOffset >= parRelativeColumnOffset; rowIndex--)
            rowWhatStartParagraph = row;
        var relativeY = rowWhatStartParagraph.initialY - this.manager.activeFormatter.layoutPosition.getOffsetRelativeColumn().y;
        return Math.min(relativeY, rowWhatStartParagraph.y);
    };
    AnchorObjectVerticalPositionCalculator.prototype.absolute = function () {
        switch (this.anchorInfo.verticalPositionType) {
            case enums_1.AnchorObjectVerticalPositionType.Page:
                return this.isRelativeCell ? this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin : 0;
            case enums_1.AnchorObjectVerticalPositionType.Paragraph:
                return this.relativeColumnPos() + this.getRowWhatStartParagraphY();
            case enums_1.AnchorObjectVerticalPositionType.Line:
                return this.relativeColumnPos() + this.lp.row.y;
            case enums_1.AnchorObjectVerticalPositionType.Margin:
                return this.isRelativeCell ? this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin :
                    this.manager.boundsCalculator.marginTop;
            case enums_1.AnchorObjectVerticalPositionType.TopMargin:
            case enums_1.AnchorObjectVerticalPositionType.InsideMargin:
                return this.isRelativeCell ? this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin : 0;
            case enums_1.AnchorObjectVerticalPositionType.BottomMargin:
            case enums_1.AnchorObjectVerticalPositionType.OutsideMargin:
                return this.isRelativeCell ? this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin :
                    this.manager.boundsCalculator.pageHeight - this.manager.boundsCalculator.marginBottom;
            default:
                throw new Error(errors_1.Errors.InternalException);
        }
    };
    AnchorObjectVerticalPositionCalculator.prototype.alignment = function () {
        switch (this.anchorInfo.verticalPositionType) {
            case enums_1.AnchorObjectVerticalPositionType.Page:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin :
                    this.getAlignPosition(this.manager.boundsCalculator.pageHeight);
            case enums_1.AnchorObjectVerticalPositionType.Line:
                return this.lp.getLayoutY(document_layout_details_level_1.DocumentLayoutDetailsLevel.Column) + this.lp.row.y +
                    this.getAlignPosition(this.lp.row.height);
            case enums_1.AnchorObjectVerticalPositionType.Paragraph:
                return this.relativeColumnPos() + this.getRowWhatStartParagraphY();
            case enums_1.AnchorObjectVerticalPositionType.Margin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin :
                    this.manager.boundsCalculator.marginTop +
                        this.getAlignPosition(this.manager.boundsCalculator.pageHeight - this.manager.boundsCalculator.marginTop -
                            this.manager.boundsCalculator.marginBottom);
            case enums_1.AnchorObjectVerticalPositionType.TopMargin:
            case enums_1.AnchorObjectVerticalPositionType.InsideMargin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin :
                    this.getAlignPosition(this.manager.boundsCalculator.marginTop);
            case enums_1.AnchorObjectVerticalPositionType.BottomMargin:
            case enums_1.AnchorObjectVerticalPositionType.OutsideMargin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin :
                    this.manager.boundsCalculator.pageHeight - this.manager.boundsCalculator.marginBottom +
                        this.getAlignPosition(this.manager.boundsCalculator.marginBottom);
            default:
                throw new Error(errors_1.Errors.InternalException);
        }
    };
    AnchorObjectVerticalPositionCalculator.prototype.getAlignPosition = function (height) {
        var alignment = this.anchorInfo.verticalPositionAlignment;
        switch (alignment) {
            case enums_1.AnchorObjectVerticalPositionAlignment.Top:
            case enums_1.AnchorObjectVerticalPositionAlignment.Inside:
                return 0;
            case enums_1.AnchorObjectVerticalPositionAlignment.Center:
                return height / 2 - this.obj.height / 2;
            case enums_1.AnchorObjectVerticalPositionAlignment.Bottom:
            case enums_1.AnchorObjectVerticalPositionAlignment.Outside:
                return height - this.obj.height;
            default:
                throw new Error(errors_1.Errors.InternalException);
        }
    };
    AnchorObjectVerticalPositionCalculator.prototype.relative = function () {
        switch (this.anchorInfo.verticalPositionType) {
            case enums_1.AnchorObjectVerticalPositionType.Page:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin :
                    this.anchorInfo.getRelativeOffsetY(this.manager.boundsCalculator.pageHeight);
            case enums_1.AnchorObjectVerticalPositionType.Margin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin :
                    this.manager.boundsCalculator.marginTop +
                        this.anchorInfo.getRelativeOffsetY(this.manager.boundsCalculator.pageHeight - this.manager.boundsCalculator.marginTop - this.manager.boundsCalculator.marginBottom);
            case enums_1.AnchorObjectVerticalPositionType.TopMargin:
            case enums_1.AnchorObjectVerticalPositionType.InsideMargin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin :
                    this.anchorInfo.getRelativeOffsetY(this.manager.boundsCalculator.marginTop);
            case enums_1.AnchorObjectVerticalPositionType.BottomMargin:
            case enums_1.AnchorObjectVerticalPositionType.OutsideMargin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.y + this.topCellMargin :
                    this.manager.boundsCalculator.pageHeight - this.manager.boundsCalculator.marginBottom +
                        this.anchorInfo.getRelativeOffsetY(this.manager.boundsCalculator.marginBottom);
            default:
                throw new Error(errors_1.Errors.InternalException);
        }
    };
    return AnchorObjectVerticalPositionCalculator;
}(base_calculator_1.AnchorObjectPositionCalculatorBase));
exports.AnchorObjectVerticalPositionCalculator = AnchorObjectVerticalPositionCalculator;
