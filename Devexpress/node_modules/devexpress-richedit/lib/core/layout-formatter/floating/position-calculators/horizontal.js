"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var errors_1 = require("@devexpress/utils/lib/errors");
var search_1 = require("@devexpress/utils/lib/utils/search");
var document_layout_details_level_1 = require("../../../layout/document-layout-details-level");
var enums_1 = require("../../../model/floating-objects/enums");
var base_calculator_1 = require("./base-calculator");
var AnchorObjectHorizontalPositionCalculator = (function (_super) {
    tslib_1.__extends(AnchorObjectHorizontalPositionCalculator, _super);
    function AnchorObjectHorizontalPositionCalculator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnchorObjectHorizontalPositionCalculator.prototype.calculate = function (obj) {
        this.init(obj);
        this.isRelativeCell = this.isRelativeCell && obj.anchorInfo.layoutTableCell;
        this.obj.x = this.getX();
        this.correctInTextAnchorPosition();
    };
    Object.defineProperty(AnchorObjectHorizontalPositionCalculator.prototype, "leftCellMargin", {
        get: function () { return this.manager.activeFormatter.tableFormatter.actualFormatter.tableInfo.currCellInfo.marginLeft; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnchorObjectHorizontalPositionCalculator.prototype, "rightCellMargin", {
        get: function () { return this.manager.activeFormatter.tableFormatter.actualFormatter.tableInfo.currCellInfo.marginRight; },
        enumerable: true,
        configurable: true
    });
    AnchorObjectHorizontalPositionCalculator.prototype.getX = function () {
        if (this.anchorInfo.isUsedHorizontalAlignment())
            return this.alignment(this.anchorInfo.horizontalPositionType, this.anchorInfo.horizontalPositionAlignment);
        if (this.anchorInfo.isUsedHorizontalAbsolutePosition())
            return unit_converter_1.UnitConverter.twipsToPixelsF(this.anchorInfo.offset.x) + this.absolute();
        if (this.anchorInfo.isUsedHorizontalBookLayout())
            return this.bookLayout();
        if (this.anchorInfo.isUsedHorizontalRelativePosition())
            return this.relative();
        throw new Error(errors_1.Errors.InternalException);
    };
    AnchorObjectHorizontalPositionCalculator.prototype.relativeColumnPos = function () {
        return this.lp.pageArea.x + this.lp.column.x;
    };
    AnchorObjectHorizontalPositionCalculator.prototype.correctInTextAnchorPosition = function () {
        if (!this.isRelativeCell || !this.obj.isInText())
            return;
        var leftBounds = this.relativeColumnPos() + this.lp.row.tableCellInfo.x;
        this.obj.x = Math.max(this.obj.x, leftBounds);
        var rightBound = this.relativeColumnPos() + this.lp.row.tableCellInfo.right;
        var leftOffset = this.obj.right - rightBound;
        if (leftOffset > 0) {
            var avalLeftOffset = this.obj.x - leftBounds;
            this.obj.x -= Math.min(leftOffset, avalLeftOffset);
        }
    };
    AnchorObjectHorizontalPositionCalculator.prototype.alignment = function (type, alignment) {
        switch (type) {
            case enums_1.AnchorObjectHorizontalPositionType.Character:
                return this.getAlignPosition(alignment, 0);
            case enums_1.AnchorObjectHorizontalPositionType.Column:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.x +
                        this.getAlignPosition(alignment, this.lp.row.tableCellInfo.width - this.leftCellMargin - this.rightCellMargin) :
                    this.relativeColumnPos() + this.getAlignPosition(alignment, this.lp.column.width);
            case enums_1.AnchorObjectHorizontalPositionType.Page:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.x + this.getAlignPosition(alignment, this.lp.row.tableCellInfo.width) :
                    this.getAlignPosition(alignment, this.manager.boundsCalculator.pageWidth);
            case enums_1.AnchorObjectHorizontalPositionType.Margin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.x + this.leftCellMargin +
                        this.getAlignPosition(alignment, this.lp.row.tableCellInfo.width - this.leftCellMargin - this.rightCellMargin) :
                    this.manager.boundsCalculator.marginLeft + this.getAlignPosition(alignment, this.lp.pageArea.width);
            case enums_1.AnchorObjectHorizontalPositionType.LeftMargin:
            case enums_1.AnchorObjectHorizontalPositionType.InsideMargin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.x + this.getAlignPosition(alignment, this.leftCellMargin) :
                    this.getAlignPosition(alignment, this.manager.boundsCalculator.marginLeft);
            case enums_1.AnchorObjectHorizontalPositionType.RightMargin:
            case enums_1.AnchorObjectHorizontalPositionType.OutsideMargin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.right - this.rightCellMargin +
                        this.getAlignPosition(enums_1.AnchorObjectHorizontalPositionAlignment.Right, this.rightCellMargin) :
                    this.manager.boundsCalculator.pageWidth - this.manager.boundsCalculator.marginRight +
                        this.getAlignPosition(alignment, this.manager.boundsCalculator.marginRight);
            default:
                throw new Error(errors_1.Errors.InternalException);
        }
    };
    AnchorObjectHorizontalPositionCalculator.prototype.getAlignPosition = function (alignment, width) {
        switch (alignment) {
            case enums_1.AnchorObjectHorizontalPositionAlignment.Left:
                return 0;
            case enums_1.AnchorObjectHorizontalPositionAlignment.Center:
                return width / 2 - this.obj.width / 2;
            case enums_1.AnchorObjectHorizontalPositionAlignment.Right:
                return width - this.obj.width;
            default:
                throw new Error(errors_1.Errors.InternalException);
        }
    };
    AnchorObjectHorizontalPositionCalculator.prototype.absolute = function () {
        switch (this.anchorInfo.horizontalPositionType) {
            case enums_1.AnchorObjectHorizontalPositionType.Page:
                return this.isRelativeCell ? this.relativeColumnPos() + this.lp.row.tableCellInfo.x : 0;
            case enums_1.AnchorObjectHorizontalPositionType.Column:
                return this.isRelativeCell ? this.relativeColumnPos() + this.lp.row.tableCellInfo.x : this.relativeColumnPos();
            case enums_1.AnchorObjectHorizontalPositionType.Character: {
                var rowAbsPos_1 = this.lp.getLogPosition(document_layout_details_level_1.DocumentLayoutDetailsLevel.Row);
                var ancBoxAbsPos = this.obj.rowOffset;
                var boxIndex = search_1.SearchUtils.normedInterpolationIndexOf(this.lp.row.boxes, function (box) { return rowAbsPos_1 + box.rowOffset; }, ancBoxAbsPos);
                var box = this.lp.row.boxes[boxIndex];
                if (!box)
                    return this.lp.getLayoutX(null, document_layout_details_level_1.DocumentLayoutDetailsLevel.Row);
                var symbolCount = Math.max(0, ancBoxAbsPos - rowAbsPos_1 - box.rowOffset);
                return this.lp.getLayoutX(null, document_layout_details_level_1.DocumentLayoutDetailsLevel.Row) + box.x +
                    box.getCharOffsetXInPixels(this.manager.measurer, symbolCount);
            }
            case enums_1.AnchorObjectHorizontalPositionType.Margin:
                return this.isRelativeCell ? this.relativeColumnPos() + this.lp.row.tableCellInfo.x + this.leftCellMargin :
                    this.manager.boundsCalculator.marginLeft;
            case enums_1.AnchorObjectHorizontalPositionType.LeftMargin:
            case enums_1.AnchorObjectHorizontalPositionType.OutsideMargin:
                return this.isRelativeCell ? this.relativeColumnPos() + this.lp.row.tableCellInfo.x + this.leftCellMargin :
                    0;
            case enums_1.AnchorObjectHorizontalPositionType.RightMargin:
            case enums_1.AnchorObjectHorizontalPositionType.InsideMargin:
                return this.isRelativeCell ? this.relativeColumnPos() +
                    this.lp.row.tableCellInfo.right - this.rightCellMargin :
                    this.manager.boundsCalculator.pageWidth - this.manager.boundsCalculator.marginRight;
            default:
                throw new Error(errors_1.Errors.InternalException);
        }
    };
    AnchorObjectHorizontalPositionCalculator.prototype.bookLayout = function () {
        return this.alignment(this.anchorInfo.horizontalPositionType, AnchorObjectHorizontalPositionCalculator.mapBookLayoutALignmentType[this.anchorInfo.horizontalPositionAlignment]);
    };
    AnchorObjectHorizontalPositionCalculator.prototype.relative = function () {
        var type = this.anchorInfo.horizontalPositionType;
        switch (type) {
            case enums_1.AnchorObjectHorizontalPositionType.Page:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.x + this.anchorInfo.getRelativeOffsetX(this.lp.row.tableCellInfo.width) :
                    this.anchorInfo.getRelativeOffsetX(this.manager.boundsCalculator.pageWidth);
            case enums_1.AnchorObjectHorizontalPositionType.Margin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.x + this.leftCellMargin +
                        this.anchorInfo.getRelativeOffsetX(this.lp.row.tableCellInfo.width - this.leftCellMargin - this.rightCellMargin) :
                    this.manager.boundsCalculator.marginLeft +
                        this.anchorInfo.getRelativeOffsetX(this.manager.boundsCalculator.pageWidth - this.manager.boundsCalculator.marginLeft - this.manager.boundsCalculator.marginRight);
            case enums_1.AnchorObjectHorizontalPositionType.LeftMargin:
            case enums_1.AnchorObjectHorizontalPositionType.InsideMargin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.x + this.anchorInfo.getRelativeOffsetX(this.leftCellMargin) :
                    this.anchorInfo.getRelativeOffsetX(this.manager.boundsCalculator.marginLeft);
            case enums_1.AnchorObjectHorizontalPositionType.RightMargin:
            case enums_1.AnchorObjectHorizontalPositionType.OutsideMargin:
                return this.isRelativeCell ?
                    this.relativeColumnPos() + this.lp.row.tableCellInfo.right - this.rightCellMargin +
                        this.anchorInfo.getRelativeOffsetX(this.rightCellMargin) :
                    this.manager.boundsCalculator.pageWidth - this.manager.boundsCalculator.marginRight +
                        this.anchorInfo.getRelativeOffsetX(this.manager.boundsCalculator.marginRight);
            default: throw new Error(errors_1.Errors.InternalException);
        }
    };
    AnchorObjectHorizontalPositionCalculator.mapBookLayoutALignmentType = (_a = {},
        _a[enums_1.AnchorObjectHorizontalPositionAlignment.Inside] = enums_1.AnchorObjectHorizontalPositionAlignment.Left,
        _a[enums_1.AnchorObjectHorizontalPositionAlignment.Outside] = enums_1.AnchorObjectHorizontalPositionAlignment.Right,
        _a);
    return AnchorObjectHorizontalPositionCalculator;
}(base_calculator_1.AnchorObjectPositionCalculatorBase));
exports.AnchorObjectHorizontalPositionCalculator = AnchorObjectHorizontalPositionCalculator;
