"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var enum_1 = require("@devexpress/utils/lib/utils/enum");
var list_1 = require("@devexpress/utils/lib/utils/list");
var cell_grid_info_manager_1 = require("../../layout-formatter/table/grid-engine/cell-grid-info-manager");
var table_1 = require("../../model/tables/main-structures/table");
var table_base_structures_1 = require("../../model/tables/secondary-structures/table-base-structures");
var table_utils_1 = require("../../model/tables/table-utils");
var __DEBUG_TABLE = (function () {
    function __DEBUG_TABLE() {
    }
    __DEBUG_TABLE.tables = function (subDocument) {
        var tables = subDocument.tables;
        if (!tables.length)
            return;
        list_1.ListUtils.forEach(subDocument.tablesByLevels, function (levelTables, levelInd) {
            if (levelTables.length) {
                var prevTblInd_1 = levelTables[0].index - 1;
                list_1.ListUtils.forEach(levelTables, function (tbl) {
                    if (tbl.nestedLevel != levelInd)
                        throw new Error("DEBUG_TABLES_CHECKS incorrect position of table(his index = " + tbl.index + "), level = " + levelInd);
                    if (tbl.index <= prevTblInd_1)
                        throw new Error("DEBUG_TABLES_CHECKS incorrect order of tables on level " + levelInd);
                    prevTblInd_1 = tbl.index;
                });
            }
        });
        if (!list_1.ListUtils.allOf(tables, function (t, i) { return t.index > tables[i - 1].index; }, 1))
            throw new Error("DEBUG_TABLES_CHECKS incorrect order of subDocument[" + subDocument.id + "].tables");
        for (var _i = 0, tables_1 = tables; _i < tables_1.length; _i++) {
            var t = tables_1[_i];
            __DEBUG_TABLE.table(t);
        }
    };
    __DEBUG_TABLE.table = function (table) {
        var colCount = table_utils_1.TableCellUtils.getColumnCount(table);
        if (!table.rows.length)
            throw new Error("DEBUG_TABLE_CHECKS no rowsOnTable");
        list_1.ListUtils.forEach(table.rows, function (r, rInd) {
            if (r.logicColumnCount != colCount)
                throw new Error("DEBUG_TABLE_CHECKS incorrectColCount on row[" + rInd + "]. Must be = " + colCount);
            if (!r.cells.length)
                throw new Error("DEBUG_TABLE_CHECKS no cellsOnRow on row[" + rInd + "]");
        });
        new TableData(table, colCount).check();
    };
    __DEBUG_TABLE.VISUALIZE_SELECTED_CELLS = function (tableInfo) {
        if (tableInfo.extendedData.numRows == 0)
            return "noCells";
        var table = tableInfo.table;
        var result = list_1.ListUtils.initByCallback(table.rows.length, function () {
            return list_1.ListUtils.initByValue(table_utils_1.TableCellUtils.getColumnCount(table), "*");
        });
        var cgim = new cell_grid_info_manager_1.CellGridInfoManager(table);
        tableInfo.extendedData.foreach(function () { }, function (cellInfo, rowInfo) {
            var cellGridInfo = cgim.tableCellInfos[rowInfo.rowIndex][cellInfo.cellIndex];
            list_1.ListUtils.forEachOnInterval(cellGridInfo.rowIndexesInterval, function (rowIndex) {
                list_1.ListUtils.forEachOnInterval(new fixed_1.FixedInterval(cellGridInfo.getGridCellIndex(), cellInfo.cell.columnSpan), function (colIndex) {
                    result[rowIndex][colIndex] = "X";
                });
            });
        });
        return list_1.ListUtils.map(result, function (r) { return r.join(""); }).join("\n");
    };
    return __DEBUG_TABLE;
}());
exports.__DEBUG_TABLE = __DEBUG_TABLE;
var DebugTableCellState;
(function (DebugTableCellState) {
    DebugTableCellState[DebugTableCellState["NotVisited"] = 0] = "NotVisited";
    DebugTableCellState[DebugTableCellState["None"] = 1] = "None";
    DebugTableCellState[DebugTableCellState["Continious"] = 2] = "Continious";
    DebugTableCellState[DebugTableCellState["Restart"] = 3] = "Restart";
    DebugTableCellState[DebugTableCellState["BeforeAfter"] = 4] = "BeforeAfter";
})(DebugTableCellState || (DebugTableCellState = {}));
var Data = (function () {
    function Data(startCellSpan, cellLen, state) {
        this.startCellSpan = startCellSpan;
        this.state = state;
        this.cellLen = cellLen;
    }
    Data.prototype.toString = function () {
        return Data.toStrMap[this.state] + "[" + this.startCellSpan + "|" + (this.startCellSpan + this.cellLen) + ")";
    };
    Data.toStrMap = (_a = {},
        _a[DebugTableCellState.None] = "N",
        _a[DebugTableCellState.Restart] = "R",
        _a[DebugTableCellState.Continious] = "C",
        _a[DebugTableCellState.NotVisited] = "NoVis",
        _a[DebugTableCellState.BeforeAfter] = "BA",
        _a);
    return Data;
}());
var TableData = (function () {
    function TableData(table, colCount) {
        this.colCount = colCount;
        this.table = table;
    }
    TableData.prototype.check = function () {
        this.fill();
        this.checkData();
        __DEBUG_TABLE.lastString = this.toString();
    };
    TableData.prototype.fill = function () {
        var _this = this;
        this.tblData = list_1.ListUtils.initByCallback(this.table.rows.length, function () { return list_1.ListUtils.initByValue(_this.colCount, new Data(-1, -1, DebugTableCellState.NotVisited)); });
        var tblPos = new table_1.TablePosition(this.table, -1, -1);
        var _loop_1 = function () {
            list_1.ListUtils.forEachOnInterval(new fixed_1.FixedInterval(0, tblPos.row.gridBefore), function (colIndex) { return _this.add(new table_1.TablePositionIndexes(tblPos.rowIndex, colIndex), null, -1, -1); });
            var cellSpan = tblPos.row.gridBefore;
            while (tblPos.moveToNextCell()) {
                list_1.ListUtils.forEachOnInterval(new fixed_1.FixedInterval(cellSpan, tblPos.cell.columnSpan), function (colIndex) { return _this.add(new table_1.TablePositionIndexes(tblPos.rowIndex, colIndex), tblPos.cell, cellSpan, tblPos.cell.columnSpan); });
                cellSpan += tblPos.cell.columnSpan;
            }
            list_1.ListUtils.forEachOnInterval(new fixed_1.FixedInterval(cellSpan, tblPos.row.gridAfter), function (colIndex) { return _this.add(new table_1.TablePositionIndexes(tblPos.rowIndex, colIndex), null, -1, -1); });
        };
        while (tblPos.moveToNextRow()) {
            _loop_1();
        }
    };
    TableData.prototype.add = function (ind, cell, startCellSpan, cellSpanLength) {
        var oldVal = this.tblData[ind.rowIndex][ind.cellIndex];
        if (oldVal.state != DebugTableCellState.NotVisited)
            throw new Error("DEBUG_TABLE_CHECKS Table model is incorrect");
        this.tblData[ind.rowIndex][ind.cellIndex] = new Data(startCellSpan, cellSpanLength, this.getState(cell));
    };
    TableData.prototype.checkData = function () {
        var _this = this;
        list_1.ListUtils.forEach(this.tblData, function (rowData, rowInd) {
            list_1.ListUtils.forEach(rowData, function (data, colInd) {
                switch (data.state) {
                    case DebugTableCellState.NotVisited:
                        throw new Error("DEBUG_TABLE_CHECKS some of logic cells is free");
                    case DebugTableCellState.Continious: {
                        if (rowInd == 0)
                            throw new Error("DEBUG_TABLE_CHECKS obvious error [" + rowInd + "][" + colInd + "]");
                        var neighborRowData = _this.tblData[rowInd - 1][colInd];
                        if (neighborRowData.cellLen != data.cellLen || neighborRowData.startCellSpan != data.startCellSpan ||
                            !enum_1.EnumUtils.isAnyOf(neighborRowData.state, DebugTableCellState.Continious, DebugTableCellState.Restart)) {
                            console.log(_this.toString());
                            throw new Error("DEBUG_TABLE_CHECKS error");
                        }
                        break;
                    }
                    case DebugTableCellState.Restart: {
                        if (rowInd == _this.table.rows.length - 1)
                            throw new Error("DEBUG_TABLE_CHECKS obvious error [" + rowInd + "][" + colInd + "]");
                        var neighborRowData = _this.tblData[rowInd + 1][colInd];
                        if (neighborRowData.cellLen != data.cellLen || neighborRowData.startCellSpan != data.startCellSpan ||
                            neighborRowData.state != DebugTableCellState.Continious) {
                            console.log(_this.toString());
                            throw new Error("DEBUG_TABLE_CHECKS error");
                        }
                        break;
                    }
                    case DebugTableCellState.None:
                }
            });
        });
    };
    TableData.prototype.toString = function () {
        return list_1.ListUtils.map(this.tblData, function (d) {
            return list_1.ListUtils.map(d, function (val) { return val.toString(); }).join("\t");
        }).join("\n");
    };
    TableData.prototype.getState = function (cell) {
        if (!cell)
            return DebugTableCellState.BeforeAfter;
        switch (cell.verticalMerging) {
            case table_base_structures_1.TableCellMergingState.None: return DebugTableCellState.None;
            case table_base_structures_1.TableCellMergingState.Restart: return DebugTableCellState.Restart;
            case table_base_structures_1.TableCellMergingState.Continue: return DebugTableCellState.Continious;
        }
    };
    return TableData;
}());
