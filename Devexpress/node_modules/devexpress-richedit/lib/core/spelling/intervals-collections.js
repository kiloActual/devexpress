"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var algorithms_1 = require("@devexpress/utils/lib/intervals/algorithms");
var fixed_1 = require("@devexpress/utils/lib/intervals/fixed");
var list_1 = require("@devexpress/utils/lib/utils/list");
var intervals_1 = require("./intervals");
var spell_checker_1 = require("./spell-checker");
var SpellCheckerIntervalCollection = (function () {
    function SpellCheckerIntervalCollection() {
        this.intervals = [];
    }
    SpellCheckerIntervalCollection.prototype.getIntervals = function () {
        return this.intervals;
    };
    SpellCheckerIntervalCollection.prototype.add = function (newInterval) {
        var index = this.intervals.length;
        while (index > 0) {
            if (this.intervals[index - 1].start < newInterval.start)
                break;
            index--;
        }
        this.intervals.splice(index, 0, newInterval);
    };
    SpellCheckerIntervalCollection.prototype.remove = function (index) {
        this.intervals.splice(index, 1);
    };
    SpellCheckerIntervalCollection.prototype.onModelIntervalChanged = function (start, length, isSeparator) {
        if (length > 0)
            this.onModelIntervalInserted(start, length, isSeparator);
        else
            this.onModelIntervalRemoved(start, -length);
    };
    SpellCheckerIntervalCollection.prototype.onModelIntervalInserted = function (start, length, _isSeparator) {
        this.forEach(function (interval) {
            if (interval.start > start)
                interval.setStart(interval.start + length);
            else if (interval.end >= start)
                interval.setLength(interval.length + length);
        });
    };
    SpellCheckerIntervalCollection.prototype.onModelIntervalRemoved = function (start, length) {
        var _this = this;
        var removedInterval = new fixed_1.FixedInterval(start, length);
        this.forEach(function (interval, index) {
            if (removedInterval.containsInterval(interval))
                _this.remove(index);
            else if (removedInterval.start < interval.start) {
                interval.setLength(interval.length - Math.max(0, removedInterval.end - interval.start));
                interval.setStart(interval.start - Math.min(removedInterval.length, interval.start - removedInterval.start));
            }
            else if (interval.end > removedInterval.start)
                interval.setLength(interval.length - Math.min(removedInterval.length, interval.end - removedInterval.start));
        });
    };
    SpellCheckerIntervalCollection.prototype.forEach = function (callback) {
        var index = this.intervals.length;
        while (--index >= 0)
            callback(this.intervals[index], index);
    };
    SpellCheckerIntervalCollection.prototype.deleteIntervalsByPositions = function (start, end) {
        var _this = this;
        var defInterval = fixed_1.FixedInterval.fromPositions(start, end);
        this.forEach(function (interval, index) {
            var intersection = algorithms_1.IntervalAlgorithms.getIntersection(interval, defInterval);
            if (intersection && intersection.length > 0)
                _this.remove(index);
        });
    };
    SpellCheckerIntervalCollection.prototype.findIntervalIndexByPositions = function (start, end) {
        return list_1.ListUtils.indexBy(this.intervals, function (interval) { return interval.start == start && interval.end == end; });
    };
    return SpellCheckerIntervalCollection;
}());
exports.SpellCheckerIntervalCollection = SpellCheckerIntervalCollection;
var UncheckedIntervalCollection = (function (_super) {
    tslib_1.__extends(UncheckedIntervalCollection, _super);
    function UncheckedIntervalCollection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UncheckedIntervalCollection.prototype.findCheckingIntervalByPositions = function (start, end) {
        var index = this.findIntervalIndexByPositions(start, end);
        return index >= 0 && this.intervals[index].info.isChecking ? this.intervals[index] : null;
    };
    UncheckedIntervalCollection.prototype.onModelIntervalInserted = function (start, length, isSeparator) {
        var hasIntersection = false;
        var separatorWasAdded = false;
        this.forEach(function (interval) {
            if (interval.containsWithIntervalEnd(start)) {
                hasIntersection = true;
                if (isSeparator && interval.end == start)
                    separatorWasAdded = true;
                else
                    interval.info.isSplitted = false;
            }
        });
        if (!separatorWasAdded)
            _super.prototype.onModelIntervalInserted.call(this, start, length, isSeparator);
        if (!hasIntersection)
            this.add(new intervals_1.UncheckedInterval(start, length, false));
    };
    UncheckedIntervalCollection.prototype.onModelIntervalRemoved = function (start, length) {
        var removedInterval = new fixed_1.FixedInterval(start, length);
        var hasIntersection = false;
        this.forEach(function (interval) {
            if (algorithms_1.IntervalAlgorithms.getIntersection(interval, removedInterval))
                hasIntersection = true;
        });
        _super.prototype.onModelIntervalRemoved.call(this, start, length);
        if (!hasIntersection)
            this.add(new intervals_1.UncheckedInterval(start, 1));
    };
    return UncheckedIntervalCollection;
}(SpellCheckerIntervalCollection));
exports.UncheckedIntervalCollection = UncheckedIntervalCollection;
var MisspelledIntervalCollection = (function (_super) {
    tslib_1.__extends(MisspelledIntervalCollection, _super);
    function MisspelledIntervalCollection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MisspelledIntervalCollection.prototype.addIfNotExists = function (newInterval) {
        if (this.findIntervalIndexByPositions(newInterval.start, newInterval.end) < 0)
            this.add(newInterval);
    };
    MisspelledIntervalCollection.prototype.findNext = function (position) {
        for (var i = 0, interval = void 0; interval = this.intervals[i]; i++)
            if (interval.end >= position)
                return interval;
        return this.intervals[0] ? this.intervals[0] : null;
    };
    MisspelledIntervalCollection.prototype.deleteOldIntervals = function (defInterval, isIntervalStartWithParagraph) {
        var _this = this;
        this.forEach(function (interval, index) {
            var intersection = algorithms_1.IntervalAlgorithms.getIntersection(interval, defInterval);
            if (intersection && intersection.length > 0)
                if (isIntervalStartWithParagraph || interval.start !== defInterval.start || interval.errorInfo.errorType !== spell_checker_1.SpellingErrorType.Repeating)
                    _this.remove(index);
        });
    };
    return MisspelledIntervalCollection;
}(SpellCheckerIntervalCollection));
exports.MisspelledIntervalCollection = MisspelledIntervalCollection;
var IgnoredIntervalCollection = (function (_super) {
    tslib_1.__extends(IgnoredIntervalCollection, _super);
    function IgnoredIntervalCollection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoredIntervalCollection.prototype.contains = function (start, length, word) {
        var index = this.findIntervalIndexByPositions(start, start + length);
        return index >= 0 && this.intervals[index].word == word;
    };
    return IgnoredIntervalCollection;
}(SpellCheckerIntervalCollection));
exports.IgnoredIntervalCollection = IgnoredIntervalCollection;
var IgnoredWordsCollection = (function () {
    function IgnoredWordsCollection() {
        this.ignoredWords = [];
    }
    IgnoredWordsCollection.prototype.add = function (word) {
        if (!this.contains(word))
            this.ignoredWords.push(word);
    };
    IgnoredWordsCollection.prototype.contains = function (word) {
        return this.ignoredWords.indexOf(word) !== -1;
    };
    return IgnoredWordsCollection;
}());
exports.IgnoredWordsCollection = IgnoredWordsCollection;
