"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var decoder_helper_1 = require("../dx-decoding/decoder-helper");
var character_decoder_1 = require("./character-decoder");
var CodePageCharacterDecoder = (function (_super) {
    tslib_1.__extends(CodePageCharacterDecoder, _super);
    function CodePageCharacterDecoder(codePage) {
        var _this = _super.call(this, codePage) || this;
        _this.bytes = [];
        return _this;
    }
    CodePageCharacterDecoder.prototype.processChar = function (importer, ch) {
        if (this.bytes.length == CodePageCharacterDecoder.capacity)
            this.flush(importer);
        this.bytes.push(ch);
    };
    CodePageCharacterDecoder.prototype.flushByChar = function (importer, chars) {
        var count = chars.length;
        for (var i = 0; i < count; i++)
            importer.processChar(chars[i]);
    };
    CodePageCharacterDecoder.prototype.flushByString = function (importer, chars) {
        importer.destination.processText(chars.join(""));
    };
    CodePageCharacterDecoder.prototype.flush = function (importer) {
        if (this.bytes.length > 0) {
            var chars = decoder_helper_1.DecoderHelper.getChars(this.bytes, this.codePage);
            if (!importer.destination.canAppendText || chars.length <= 1) {
                this.flushByChar(importer, chars);
            }
            else {
                this.flushByString(importer, chars);
            }
            this.bytes = [];
        }
    };
    CodePageCharacterDecoder.capacity = 2048;
    return CodePageCharacterDecoder;
}(character_decoder_1.CharacterDecoder));
exports.CodePageCharacterDecoder = CodePageCharacterDecoder;
