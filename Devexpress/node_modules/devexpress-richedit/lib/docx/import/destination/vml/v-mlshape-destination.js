"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var map_creator_1 = require("../../../../base-utils/map-creator");
var color_1 = require("../../../../core/model/color/color");
var dx_color_1 = require("../../../../core/model/color/dx-color");
var enums_1 = require("../../../../core/model/enums");
var field_1 = require("../../../../core/model/fields/field");
var enums_2 = require("../../../../core/model/floating-objects/enums");
var unit_converter_1 = require("@devexpress/utils/lib/class/unit-converter");
var color_2 = require("@devexpress/utils/lib/utils/color");
var string_1 = require("@devexpress/utils/lib/utils/map/string");
var string_2 = require("@devexpress/utils/lib/utils/string");
var translation_tables_1 = require("../../../translation-table/translation-tables");
var constants_1 = require("../../../utils/constants");
var string_value_parser_1 = require("../../../utils/string-value-parser");
var units_converter_1 = require("../../../utils/units-converter");
var open_xml_color_import_helper_1 = require("../../color/open-xml-color-import-helper");
var floating_object_import_info_1 = require("../../model/floating-object-import-info");
var destination_1 = require("../destination");
var drawing_destination_1 = require("../drawing/drawing-destination");
var VMLShapeDestination = (function (_super) {
    tslib_1.__extends(VMLShapeDestination, _super);
    function VMLShapeDestination(data, inlineObjectDestination) {
        var _this = _super.call(this, data) || this;
        _this.inlineObjectDestination = inlineObjectDestination;
        return _this;
    }
    Object.defineProperty(VMLShapeDestination.prototype, "elementHandlerTable", {
        get: function () {
            return VMLShapeDestination.handlerTable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VMLShapeDestination.prototype, "floatingObjectImportInfo", {
        get: function () {
            return this.inlineObjectDestination.floatingObjectImportInfo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VMLShapeDestination.prototype, "style", {
        get: function () {
            return this.inlineObjectDestination.style;
        },
        enumerable: true,
        configurable: true
    });
    VMLShapeDestination.getThis = function (data) {
        return data.destinationStack.getThis();
    };
    VMLShapeDestination.onWrap = function (data, _reader) {
        return new WrapDestination(data, VMLShapeDestination.getThis(data).floatingObjectImportInfo.anchorInfo);
    };
    VMLShapeDestination.onLock = function (data, _reader) {
        return new ShapeLockDestination(data, VMLShapeDestination.getThis(data).floatingObjectImportInfo.size);
    };
    VMLShapeDestination.onTextBox = function (data, _reader) {
        VMLShapeDestination.getThis(data).floatingObjectImportInfo.shapeType = floating_object_import_info_1.ShapeType.TextBox;
        return new VMLTextBoxDestination(data, VMLShapeDestination.getThis(data).floatingObjectImportInfo);
    };
    VMLShapeDestination.onAnchorLock = function (data, _reader) {
        return new AnchorLockDestination(data, VMLShapeDestination.getThis(data).floatingObjectImportInfo.anchorInfo);
    };
    VMLShapeDestination.onImageData = function (data, _reader) {
        return new VmlShapeImageDataDestination(data, VMLShapeDestination.getThis(data).floatingObjectImportInfo);
    };
    VMLShapeDestination.prototype.processElementOpen = function (reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var name;
            return tslib_1.__generator(this, function (_a) {
                this.inlineObjectDestination.style = reader.getAttribute('style');
                this.readFloatingObjectProperties(reader);
                this.readShapeProperties(reader);
                name = reader.getAttribute('id');
                if (!string_2.StringUtils.isNullOrEmpty(name) && string_2.StringUtils.isNullOrEmpty(this.floatingObjectImportInfo.constainerProperties.name))
                    this.floatingObjectImportInfo.constainerProperties.name = name;
                this.readFlatingObjectHyperlinkInfo(reader);
                return [2];
            });
        });
    };
    VMLShapeDestination.prototype.readFlatingObjectHyperlinkInfo = function (reader) {
        var href = reader.getAttribute('href');
        if (string_2.StringUtils.isNullOrEmpty(href))
            return;
        var hyperlinkInfo = new field_1.HyperlinkInfo('', '', '', false);
        var anchorSeparatorIndex = href.lastIndexOf('#');
        if (anchorSeparatorIndex >= 0) {
            hyperlinkInfo.uri = href.substring(0, anchorSeparatorIndex);
            hyperlinkInfo.anchor = href.substring(anchorSeparatorIndex + 1);
        }
        else
            hyperlinkInfo.uri = href;
        var title = reader.getAttribute('title');
        if (!string_2.StringUtils.isNullOrEmpty(title))
            hyperlinkInfo.tip = title;
        this.floatingObjectImportInfo.hyperlinkInfo = hyperlinkInfo;
    };
    VMLShapeDestination.prototype.processElementClose = function (reader) {
        _super.prototype.processElementClose.call(this, reader);
        var shape = this.floatingObjectImportInfo.shape;
        try {
            this.applyShapeProperties(shape);
        }
        catch (_a) { }
    };
    VMLShapeDestination.prototype.applyShapeProperties = function (shape) {
        if (this.floatingObjectImportInfo.shapeType == floating_object_import_info_1.ShapeType.TextBox)
            this.applyTextBoxShapeProperties(shape);
        else
            this.applyPictureShapeProperties(shape);
    };
    VMLShapeDestination.prototype.applyTextBoxShapeProperties = function (shape) {
        if (this.isStroked) {
            if (this.outlineColor == dx_color_1.DXColor.empty)
                this.outlineColor = color_1.ColorHelper.BLACK_COLOR;
            shape.outlineColor = this.outlineColor;
        }
        if (this.isFilled) {
            if (this.fillColor != dx_color_1.DXColor.empty)
                shape.fillColor = this.fillColor;
        }
        if (this.outlineWidth == Number.MIN_SAFE_INTEGER)
            this.outlineWidth = 0.75;
        shape.outlineWidth = Math.round(unit_converter_1.UnitConverter.pointsToTwips(this.outlineWidth));
    };
    VMLShapeDestination.prototype.applyPictureShapeProperties = function (shape) {
        if (this.isStroked) {
            if (this.outlineColor != dx_color_1.DXColor.empty)
                shape.outlineColor = this.outlineColor;
        }
        if (this.isFilled) {
            if (this.fillColor != dx_color_1.DXColor.empty)
                shape.fillColor = this.fillColor;
        }
        if (this.outlineWidth != Number.MIN_SAFE_INTEGER)
            shape.outlineWidth = Math.round(unit_converter_1.UnitConverter.pointsToTwips(this.outlineWidth));
    };
    VMLShapeDestination.prototype.readFloatingObjectProperties = function (reader) {
        var properties = this.floatingObjectImportInfo.anchorInfo;
        this.readFloatingObjectPropertiesCore(reader, properties);
    };
    VMLShapeDestination.prototype.readShapeProperties = function (reader) {
        try {
            this.readShapePropertiesCore(reader);
        }
        catch (_a) { }
    };
    VMLShapeDestination.prototype.readFloatingObjectPropertiesCore = function (reader, properties) {
        if (!string_2.StringUtils.isNullOrEmpty(reader.getAttribute('side')))
            properties.wrapSide = this.data.readerHelper.getWpEnumValue(reader, 'wrapText', translation_tables_1.TranslationTables.floatingObjectTextWrapSideTable.importMap, enums_2.AnchorObjectTextWrapSide.Both);
        var layoutInTableCell = reader.getAttributeNS('allowincell', this.data.constants.namespaces[constants_1.DocxNsType.Office].namespace);
        if (!string_2.StringUtils.isNullOrEmpty(layoutInTableCell))
            properties.layoutTableCell = this.getBoolValue(layoutInTableCell);
        else
            properties.layoutTableCell = true;
        var allowOverlap = reader.getAttributeNS('allowoverlap', this.data.constants.namespaces[constants_1.DocxNsType.Office].namespace);
        if (!string_2.StringUtils.isNullOrEmpty(allowOverlap))
            properties.allowOverlap = this.getBoolValue(allowOverlap);
    };
    VMLShapeDestination.prototype.readShapePropertiesCore = function (reader) {
        var strokedAttribute = reader.getAttribute('stroked');
        this.isStroked = strokedAttribute != 'f' && strokedAttribute != 'false';
        var filledAttribute = reader.getAttribute('filled');
        this.isFilled = filledAttribute != 'f' && filledAttribute != 'false';
        var outlineColor = open_xml_color_import_helper_1.OpenXmlColorImportHelper.tryConvertAttributeToColor(this.data, reader, 'strokecolor');
        this.outlineColor = outlineColor == undefined ? color_1.ColorHelper.BLACK_COLOR : outlineColor;
        var fillColor = open_xml_color_import_helper_1.OpenXmlColorImportHelper.tryConvertAttributeToColor(this.data, reader, 'fillcolor');
        this.fillColor = fillColor == undefined || fillColor == dx_color_1.DXColor.empty ? color_2.ColorUtils.LIGHT_COLOR : fillColor;
        this.outlineWidth = this.data.readerHelper.getFloatValueInPoints(reader, 'strokeweight', Number.MIN_SAFE_INTEGER);
    };
    VMLShapeDestination.prototype.getBoolValue = function (value) {
        return value == 't';
    };
    VMLShapeDestination.handlerTable = new map_creator_1.MapCreator()
        .add('wrap', VMLShapeDestination.onWrap)
        .add('lock', VMLShapeDestination.onLock)
        .add('textbox', VMLShapeDestination.onTextBox)
        .add('anchorlock', VMLShapeDestination.onAnchorLock)
        .add('imagedata', VMLShapeDestination.onImageData)
        .get();
    return VMLShapeDestination;
}(destination_1.ElementDestination));
exports.VMLShapeDestination = VMLShapeDestination;
var WrapDestination = (function (_super) {
    tslib_1.__extends(WrapDestination, _super);
    function WrapDestination(data, floatingObjectProperties) {
        var _this = _super.call(this, data) || this;
        _this.floatingObject = floatingObjectProperties;
        return _this;
    }
    WrapDestination.prototype.importTextWrapType = function (reader) {
        var textWrapType = reader.getAttribute('type');
        var result = string_1.StringMapUtils.elementBy(translation_tables_1.TranslationTables.floatingObjectTextWrapTypeTable.importMap, function (elem) { return elem.mlValue.wordMLValue == textWrapType; });
        if (result)
            this.floatingObject.wrapType = result.modelValue;
    };
    WrapDestination.prototype.importTextWrapSide = function (reader) {
        var textWrapSide = reader.getAttribute('side');
        var result = string_1.StringMapUtils.elementBy(translation_tables_1.TranslationTables.floatingObjectTextWrapSideTable.importMap, function (elem) { return elem.mlValue.wordMLValue == textWrapSide; });
        if (result)
            this.floatingObject.wrapSide = result.modelValue;
    };
    WrapDestination.prototype.processElementOpen = function (reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.importTextWrapType(reader);
                this.importTextWrapSide(reader);
                return [2];
            });
        });
    };
    return WrapDestination;
}(destination_1.LeafElementDestination));
exports.WrapDestination = WrapDestination;
var ShapeLockDestination = (function (_super) {
    tslib_1.__extends(ShapeLockDestination, _super);
    function ShapeLockDestination(data, size) {
        var _this = _super.call(this, data) || this;
        _this.size = size;
        return _this;
    }
    ShapeLockDestination.prototype.processElementOpen = function (reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var aspectRatioValue;
            return tslib_1.__generator(this, function (_a) {
                aspectRatioValue = reader.getAttribute('aspectratio');
                if (!string_2.StringUtils.isNullOrEmpty(aspectRatioValue))
                    this.size.lockAspectRatio = (aspectRatioValue == 't');
                return [2];
            });
        });
    };
    return ShapeLockDestination;
}(destination_1.LeafElementDestination));
exports.ShapeLockDestination = ShapeLockDestination;
var AnchorLockDestination = (function (_super) {
    tslib_1.__extends(AnchorLockDestination, _super);
    function AnchorLockDestination(data, floatingObjectProperties) {
        var _this = _super.call(this, data) || this;
        _this.floatingObjectProperties = floatingObjectProperties;
        return _this;
    }
    AnchorLockDestination.prototype.processElementOpen = function (_reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.floatingObjectProperties.locked = true;
                return [2];
            });
        });
    };
    return AnchorLockDestination;
}(destination_1.LeafElementDestination));
exports.AnchorLockDestination = AnchorLockDestination;
var VMLTextBoxDestination = (function (_super) {
    tslib_1.__extends(VMLTextBoxDestination, _super);
    function VMLTextBoxDestination(data, floatingObjectImportInfo) {
        var _this = _super.call(this, data) || this;
        _this.floatingObjectImportInfo = floatingObjectImportInfo;
        _this.floatingObjectImportInfo.shapeType = floating_object_import_info_1.ShapeType.TextBox;
        _this.data.pushCurrentSubDocument(_this.documentModel.createSubDocument(enums_1.SubDocumentInfoType.TextBox, _this.data.subDocument.id, true));
        return _this;
    }
    Object.defineProperty(VMLTextBoxDestination.prototype, "elementHandlerTable", {
        get: function () {
            return VMLTextBoxDestination.handlerTable;
        },
        enumerable: true,
        configurable: true
    });
    VMLTextBoxDestination.onTextBoxContent = function (data, _reader) {
        return new drawing_destination_1.TextBoxContentDestination(data);
    };
    VMLTextBoxDestination.prototype.processElementOpen = function (reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var style, inset, textBoxProperties, margins;
            return tslib_1.__generator(this, function (_a) {
                style = reader.getAttribute('style');
                inset = reader.getAttribute('inset');
                textBoxProperties = this.floatingObjectImportInfo.textBoxProperties;
                if (string_2.StringUtils.isNullOrEmpty(style))
                    textBoxProperties.resizeShapeToFitText = false;
                else
                    textBoxProperties.resizeShapeToFitText = this.getResizeShapeToFitText(style);
                if (string_2.StringUtils.isNullOrEmpty(inset))
                    return [2];
                margins = this.getMargins(inset);
                textBoxProperties.leftMargin = this.getValidMarginValue(margins[0], 144);
                textBoxProperties.rightMargin = this.getValidMarginValue(margins[1], 144);
                textBoxProperties.topMargin = this.getValidMarginValue(margins[2], 72);
                textBoxProperties.bottomMargin = this.getValidMarginValue(margins[3], 72);
                return [2];
            });
        });
    };
    VMLTextBoxDestination.prototype.processElementClose = function (_reader) {
        this.floatingObjectImportInfo.subDocId = this.data.subDocument.id;
        this.data.popCurrentSubDocument();
    };
    VMLTextBoxDestination.prototype.getMargins = function (strMargins) {
        var result = new Array(4);
        var margins = strMargins.split(',');
        for (var i = 0; i < margins.length; i++)
            result[i] = this.getFloatValue(margins[i]);
        if (margins.length < 4)
            for (var i = margins.length; i < result.length; i++)
                result[i] = 72 + ((i < 2) ? 72 : 0);
        return result;
    };
    VMLTextBoxDestination.prototype.getResizeShapeToFitText = function (style) {
        return style.substring(style.length - 1) == 't';
    };
    VMLTextBoxDestination.prototype.getValidMarginValue = function (value, defaultValue) {
        if (value < 0)
            return defaultValue;
        else
            return value;
    };
    VMLTextBoxDestination.prototype.getFloatValue = function (numb) {
        var valueUnit = string_value_parser_1.StringValueParser.parse(numb);
        if (valueUnit.isEmpty || valueUnit.value == undefined)
            return Number.MIN_VALUE;
        return units_converter_1.UnitsConverter.valueUnitToModelUnitsF(valueUnit);
    };
    VMLTextBoxDestination.handlerTable = new map_creator_1.MapCreator()
        .add('txbxContent', VMLTextBoxDestination.onTextBoxContent)
        .get();
    return VMLTextBoxDestination;
}(destination_1.ElementDestination));
exports.VMLTextBoxDestination = VMLTextBoxDestination;
var VmlShapeImageDataDestination = (function (_super) {
    tslib_1.__extends(VmlShapeImageDataDestination, _super);
    function VmlShapeImageDataDestination(data, floatingObjectImportInfo) {
        var _this = _super.call(this, data) || this;
        _this.floatingObjectImportInfo = floatingObjectImportInfo;
        _this.floatingObjectImportInfo.shapeType = floating_object_import_info_1.ShapeType.PictureFrame;
        return _this;
    }
    VmlShapeImageDataDestination.prototype.processElementOpen = function (reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var relationId, imageId;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        relationId = reader.getAttributeNS('id', this.data.constants.relsNamespaceConst);
                        if (!!string_2.StringUtils.isNullOrEmpty(relationId)) return [3, 2];
                        return [4, this.data.relationsStack.last.lookupImageByRelationId(relationId, 'word')];
                    case 1:
                        imageId = _a.sent();
                        if (imageId != null)
                            this.floatingObjectImportInfo.imageId = imageId;
                        return [2];
                    case 2: return [2];
                }
            });
        });
    };
    return VmlShapeImageDataDestination;
}(destination_1.LeafElementDestination));
exports.VmlShapeImageDataDestination = VmlShapeImageDataDestination;
