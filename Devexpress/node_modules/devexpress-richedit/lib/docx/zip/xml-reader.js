"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var stack_1 = require("@devexpress/utils/lib/class/stack");
var string_1 = require("@devexpress/utils/lib/utils/string");
var constants_1 = require("../utils/constants");
var XmlReaderState;
(function (XmlReaderState) {
    XmlReaderState[XmlReaderState["Ok"] = 0] = "Ok";
    XmlReaderState[XmlReaderState["Error"] = 1] = "Error";
    XmlReaderState[XmlReaderState["EndOfFile"] = 2] = "EndOfFile";
})(XmlReaderState = exports.XmlReaderState || (exports.XmlReaderState = {}));
var XmlNodeType;
(function (XmlNodeType) {
    XmlNodeType[XmlNodeType["None"] = 0] = "None";
    XmlNodeType[XmlNodeType["Element"] = 1] = "Element";
    XmlNodeType[XmlNodeType["EndElement"] = 2] = "EndElement";
    XmlNodeType[XmlNodeType["Text"] = 3] = "Text";
    XmlNodeType[XmlNodeType["CDATA"] = 4] = "CDATA";
    XmlNodeType[XmlNodeType["SignificantWhitespace"] = 5] = "SignificantWhitespace";
    XmlNodeType[XmlNodeType["Whitespace"] = 6] = "Whitespace";
    XmlNodeType[XmlNodeType["Comment"] = 7] = "Comment";
})(XmlNodeType = exports.XmlNodeType || (exports.XmlNodeType = {}));
var ElementStages;
(function (ElementStages) {
    ElementStages[ElementStages["ElementStart"] = 0] = "ElementStart";
    ElementStages[ElementStages["ChildElements"] = 1] = "ChildElements";
    ElementStages[ElementStages["ElementEnd"] = 2] = "ElementEnd";
    ElementStages[ElementStages["ToNextNode"] = 3] = "ToNextNode";
})(ElementStages || (ElementStages = {}));
var ElementInfo = (function () {
    function ElementInfo(node, nodeType) {
        this.elementStage = ElementStages.ElementStart;
        this.node = node;
        this.nodeType = nodeType;
    }
    Object.defineProperty(ElementInfo.prototype, "localName", {
        get: function () { return this.node.localName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementInfo.prototype, "name", {
        get: function () { return this.node.nodeName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementInfo.prototype, "namespaceURI", {
        get: function () { return this.node.namespaceURI; },
        enumerable: true,
        configurable: true
    });
    return ElementInfo;
}());
var XmlReader = (function () {
    function XmlReader(str, options, filePath) {
        str = string_1.StringUtils.trimStart(str);
        this.filePath = filePath;
        this.document = new DOMParser().parseFromString(str, constants_1.ContentType.xml);
        this.state = XmlReaderState.Ok;
        this.elementStack = new stack_1.Stack();
        this.elementStack.push(new ElementInfo(this.document.firstChild, XmlNodeType.None));
        this.handleNewNode(this.document.firstChild);
        this.options = options;
    }
    Object.defineProperty(XmlReader.prototype, "elementInfo", {
        get: function () { return this.elementStack.last; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XmlReader.prototype, "nodeType", {
        get: function () { return this.elementInfo.nodeType; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XmlReader.prototype, "localName", {
        get: function () { return this.elementInfo.localName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XmlReader.prototype, "name", {
        get: function () { return this.elementInfo.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XmlReader.prototype, "namespaceURI", {
        get: function () { return this.elementInfo.namespaceURI; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XmlReader.prototype, "attributes", {
        get: function () { return this.elementInfo.node.attributes; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XmlReader.prototype, "value", {
        get: function () { return this.elementInfo.node.nodeValue; },
        enumerable: true,
        configurable: true
    });
    XmlReader.prototype.getAttribute = function (name) {
        return this.elementInfo.node.getAttribute(name);
    };
    XmlReader.prototype.getAttributeNS = function (name, namespaceUri) {
        return this.elementInfo.node.getAttributeNS(namespaceUri, name);
    };
    XmlReader.prototype.skipElement = function () {
        this.elementInfo.elementStage = ElementStages.ToNextNode;
    };
    XmlReader.prototype.readToFollowingNS = function (name, ns) {
        do {
            if (this.nodeType == XmlNodeType.Element && this.localName == name && this.namespaceURI == ns)
                return true;
        } while (this.read());
        return false;
    };
    XmlReader.prototype.readToFollowing = function (name) {
        do {
            if (this.nodeType == XmlNodeType.Element && this.localName == name && this.handleNewNode(this.elementInfo.node))
                return true;
        } while (this.read());
        return false;
    };
    XmlReader.prototype.read = function () {
        var info = this.elementInfo;
        if (!info)
            return false;
        switch (info.elementStage) {
            case ElementStages.ElementStart: {
                info.elementStage++;
                switch (info.node.nodeType) {
                    case Node.COMMENT_NODE:
                        info.nodeType = XmlNodeType.Comment;
                        if (this.options.ignoreComments) {
                            this.elementInfo.elementStage = ElementStages.ToNextNode;
                            return this.read();
                        }
                        this.elementInfo.elementStage = ElementStages.ToNextNode;
                        break;
                    case Node.TEXT_NODE:
                        info.nodeType = XmlNodeType.Text;
                        info.elementStage = ElementStages.ToNextNode;
                        break;
                    default:
                        info.nodeType = XmlNodeType.Element;
                        break;
                }
                if (info.node.nodeName == '#cdata-section') {
                    info.nodeType = XmlNodeType.CDATA;
                    this.elementInfo.elementStage = ElementStages.ToNextNode;
                }
                break;
            }
            case ElementStages.ChildElements: {
                info.elementStage++;
                var child = this.elementInfo.node.firstChild;
                if (child) {
                    if (!this.handleNewNode(child))
                        return false;
                    this.elementStack.push(new ElementInfo(child, XmlNodeType.None));
                }
                return this.read();
            }
            case ElementStages.ElementEnd: {
                info.elementStage++;
                info.nodeType = XmlNodeType.EndElement;
                break;
            }
            case ElementStages.ToNextNode: {
                var nextNode = info.node.nextSibling;
                if (nextNode) {
                    this.elementStack.pop();
                    if (!this.handleNewNode(nextNode))
                        return false;
                    this.elementStack.push(new ElementInfo(nextNode, XmlNodeType.None));
                }
                else {
                    this.elementStack.pop();
                    if (!this.elementStack.count) {
                        this.state = XmlReaderState.EndOfFile;
                        return false;
                    }
                }
                return this.read();
            }
        }
        return true;
    };
    XmlReader.prototype.handleNewNode = function (node) {
        if (node.nodeName == 'parsererror') {
            this.state = XmlReaderState.Error;
            return false;
        }
        return true;
    };
    return XmlReader;
}());
exports.XmlReader = XmlReader;
